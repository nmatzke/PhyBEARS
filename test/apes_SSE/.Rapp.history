st2 <- asr.marginal(lik2, pars)#
nodelabels(thermo=t(st2), piecol=cols, cex=0.5)#
t(st2)
# Gives weird result -- green nodes, blue truth#
set.seed(47) # Rare to have a transition, but observed here#
pars <- c(0.222222222, 0.222222222, 0.111111111, 0.222222222, 0.1, 0.05)#
#
# Seems accurate#
pars <- c(0.222222222, 0.222222222, 0.111111111, 0.05, 0.1, 0.15)#
#
set.seed(59) # Rare to have a transition, but observed here#
phy <- trees(pars, "bisse", max.taxa=10, max.t=Inf, x0=0)[[1]]#
cols = c("blue", "green3")#
lower = rep(0.0, times=length(pars))#
upper = rep(10.0, times=length(pars))
## Here is the true history#
h <- history.from.sim.discrete(phy, 0:1)#
diversitree:::plot.history(h, phy, main="True history", cols=cols)
lik <- make.bisse(phy, phy$tip.state)#
#fit <- find.mle(lik, pars, method="subplex")#
fit <- find.mle(func=lik, x.init=pars, method="subplex", fail.value=-1e10, lower=lower, upper=upper)#
parsdf = cft(adf2(matrix(coef(fit),nrow=1))); names(parsdf)=names(coef(fit))#
parsdf
st <- asr.marginal(lik, coef(fit))#
states_df = cft(adf2(t(st)))#
states_df
nodelabels(thermo=t(st), piecol=cols, cex=0.5)
?plot.phylo
plot(phy, label.offset=0.05)
plot(phy, label.offset=0.5)
plot(phy, label.offset=0.5, main="Inferred history")#
lik <- make.bisse(phy, phy$tip.state)#
#fit <- find.mle(lik, pars, method="subplex")#
fit <- find.mle(func=lik, x.init=pars, method="subplex", fail.value=-1e10, lower=lower, upper=upper)#
parsdf = cft(adf2(matrix(coef(fit),nrow=1))); names(parsdf)=names(coef(fit))#
parsdf#
#
st <- asr.marginal(lik, coef(fit))#
states_df = cft(adf2(t(st)))#
states_df#
#
nodelabels(thermo=t(st), piecol=cols, cex=0.5)
set.seed(59) # Rare to have a transition, but observed here#
phy <- trees(pars, "bisse", max.taxa=5, max.t=Inf, x0=0)[[1]]#
cols = c("blue", "green3")#
lower = rep(0.0, times=length(pars))#
upper = rep(10.0, times=length(pars))#
#
## Here is the true history#
h <- history.from.sim.discrete(phy, 0:1)#
diversitree:::plot.history(h, phy, main="True history", cols=cols)#
#
lik <- make.bisse(phy, phy$tip.state)#
#fit <- find.mle(lik, pars, method="subplex")#
fit <- find.mle(func=lik, x.init=pars, method="subplex", fail.value=-1e10, lower=lower, upper=upper)
fit
names(fit)
fit$par
set.seed(59) # Rare to have a transition, but observed here#
pars <- c(0.222222222, 0.222222222, 0.111111111, 0.222222222, 0.1, 0.05)#
#
phy <- trees(pars, "bisse", max.taxa=5, max.t=Inf, x0=0)[[1]]#
cols = c("blue", "green3")#
lower = rep(0.0, times=length(pars))#
upper = rep(10.0, times=length(pars))#
#
## Here is the true history#
h <- history.from.sim.discrete(phy, 0:1)#
diversitree:::plot.history(h, phy, main="True history", cols=cols)#
#
lik <- make.bisse(phy, phy$tip.state)#
#fit <- find.mle(lik, pars, method="subplex")#
fit <- find.mle(func=lik, x.init=pars, method="subplex", fail.value=-1e10, lower=lower, upper=upper)#
#
# ML on this tiny dataset is meaningless#
fit$par[1:length(fit$par)] = pars
lik
st <- asr.marginal(lik, pars)
st
set.seed(59) # Rare to have a transition, but observed here#
pars <- c(0.222222222, 0.222222222, 0.111111111, 0.222222222, 0.03, 0.02)#
#
phy <- trees(pars, "bisse", max.taxa=5, max.t=Inf, x0=0)[[1]]#
cols = c("blue", "green3")#
lower = rep(0.0, times=length(pars))#
upper = rep(10.0, times=length(pars))#
#
## Here is the true history#
h <- history.from.sim.discrete(phy, 0:1)#
diversitree:::plot.history(h, phy, main="True history", cols=cols)#
#
lik <- make.bisse(phy, phy$tip.state)#
#fit <- find.mle(lik, pars, method="subplex")#
fit <- find.mle(func=lik, x.init=pars, method="subplex", fail.value=-1e10, lower=lower, upper=upper)#
#
# ML on this tiny dataset is meaningless#
fit$par[1:length(fit$par)] = pars#
#
plot(phy, label.offset=0.1)#
tiplabels(text=phy$tip.state, tip=1:5, col="black", bg=cols[phy2$tip.state+1])#
#diversitree:::plot.history(h, phy, main="True history", cols=cols)#
#
#fit2 <- find.mle(lik2, pars, method="subplex", fail.value=-1e10)#
st <- asr.marginal(lik, pars)#
nodelabels(thermo=t(st2), piecol=cols, cex=0.5)#
t(st2)
set.seed(61) # Rare to have a transition, but observed here#
pars <- c(0.222222222, 0.222222222, 0.111111111, 0.222222222, 0.03, 0.02)#
#
phy <- trees(pars, "bisse", max.taxa=5, max.t=Inf, x0=0)[[1]]#
cols = c("blue", "green3")#
lower = rep(0.0, times=length(pars))#
upper = rep(10.0, times=length(pars))#
#
## Here is the true history#
h <- history.from.sim.discrete(phy, 0:1)#
diversitree:::plot.history(h, phy, main="True history", cols=cols)
set.seed(63) # Rare to have a transition, but observed here#
pars <- c(0.222222222, 0.222222222, 0.111111111, 0.222222222, 0.03, 0.02)#
#
phy <- trees(pars, "bisse", max.taxa=5, max.t=Inf, x0=0)[[1]]#
cols = c("blue", "green3")#
lower = rep(0.0, times=length(pars))#
upper = rep(10.0, times=length(pars))#
#
## Here is the true history#
h <- history.from.sim.discrete(phy, 0:1)#
diversitree:::plot.history(h, phy, main="True history", cols=cols)
set.seed(65) # Rare to have a transition, but observed here#
pars <- c(0.222222222, 0.222222222, 0.111111111, 0.222222222, 0.03, 0.02)#
#
phy <- trees(pars, "bisse", max.taxa=5, max.t=Inf, x0=0)[[1]]#
cols = c("blue", "green3")#
lower = rep(0.0, times=length(pars))#
upper = rep(10.0, times=length(pars))#
#
## Here is the true history#
h <- history.from.sim.discrete(phy, 0:1)#
diversitree:::plot.history(h, phy, main="True history", cols=cols)
set.seed(67) # Rare to have a transition, but observed here#
pars <- c(0.222222222, 0.222222222, 0.111111111, 0.222222222, 0.03, 0.02)#
#
phy <- trees(pars, "bisse", max.taxa=5, max.t=Inf, x0=0)[[1]]#
cols = c("blue", "green3")#
lower = rep(0.0, times=length(pars))#
upper = rep(10.0, times=length(pars))#
#
## Here is the true history#
h <- history.from.sim.discrete(phy, 0:1)#
diversitree:::plot.history(h, phy, main="True history", cols=cols)
set.seed(75) # Rare to have a transition, but observed here#
pars <- c(0.222222222, 0.222222222, 0.111111111, 0.222222222, 0.03, 0.02)#
#
phy <- trees(pars, "bisse", max.taxa=5, max.t=Inf, x0=0)[[1]]#
cols = c("blue", "green3")#
lower = rep(0.0, times=length(pars))#
upper = rep(10.0, times=length(pars))#
#
## Here is the true history#
h <- history.from.sim.discrete(phy, 0:1)#
diversitree:::plot.history(h, phy, main="True history", cols=cols)
set.seed(75) # Rare to have a transition, but observed here#
pars <- c(0.222222222, 0.222222222, 0.111111111, 0.222222222, 0.06, 0.05)#
#
phy <- trees(pars, "bisse", max.taxa=5, max.t=Inf, x0=0)[[1]]#
cols = c("blue", "green3")#
lower = rep(0.0, times=length(pars))#
upper = rep(10.0, times=length(pars))#
#
## Here is the true history#
h <- history.from.sim.discrete(phy, 0:1)#
diversitree:::plot.history(h, phy, main="True history", cols=cols)
lik <- make.bisse(phy, phy$tip.state)#
#fit <- find.mle(lik, pars, method="subplex")#
fit <- find.mle(func=lik, x.init=pars, method="subplex", fail.value=-1e10, lower=lower, upper=upper)#
#
# ML on this tiny dataset is meaningless#
fit$par[1:length(fit$par)] = pars
plot(phy, label.offset=0.1)#
tiplabels(text=phy$tip.state, tip=1:5, col="black", bg=cols[phy2$tip.state+1])
st <- asr.marginal(lik, pars)#
nodelabels(thermo=t(st2), piecol=cols, cex=0.5)#
t(st2)
set.seed(75) # Rare to have a transition, but observed here#
pars <- c(0.222222222, 0.222222222, 0.111111111, 0.0111111111, 0.06, 0.05)#
#
phy <- trees(pars, "bisse", max.taxa=5, max.t=Inf, x0=0)[[1]]#
cols = c("blue", "green3")#
lower = rep(0.0, times=length(pars))#
upper = rep(10.0, times=length(pars))#
#
## Here is the true history#
h <- history.from.sim.discrete(phy, 0:1)#
diversitree:::plot.history(h, phy, main="True history", cols=cols)
lik <- make.bisse(phy, phy$tip.state)#
#fit <- find.mle(lik, pars, method="subplex")#
fit <- find.mle(func=lik, x.init=pars, method="subplex", fail.value=-1e10, lower=lower, upper=upper)#
#
# ML on this tiny dataset is meaningless#
fit$par[1:length(fit$par)] = pars#
#
plot(phy, label.offset=0.1)#
tiplabels(text=phy$tip.state, tip=1:5, col="black", bg=cols[phy2$tip.state+1])#
#diversitree:::plot.history(h, phy, main="True history", cols=cols)#
#
#fit2 <- find.mle(lik2, pars, method="subplex", fail.value=-1e10)#
st <- asr.marginal(lik, pars)#
nodelabels(thermo=t(st2), piecol=cols, cex=0.5)#
t(st2)
set.seed(75) # Rare to have a transition, but observed here#
pars <- c(0.222222222, 0.222222222, 0.111111111, 0.0111111111, 0.06, 0.05)#
#
phy <- trees(pars, "bisse", max.taxa=5, max.t=Inf, x0=0)[[1]]#
cols = c("blue", "green3")#
lower = rep(0.0, times=length(pars))#
upper = rep(10.0, times=length(pars))#
#
## Here is the true history#
h <- history.from.sim.discrete(phy, 0:1)#
diversitree:::plot.history(h, phy, main="True history", cols=cols)
lik <- make.bisse(phy, phy$tip.state)#
#fit <- find.mle(lik, pars, method="subplex")#
fit <- find.mle(func=lik, x.init=pars, method="subplex", fail.value=-1e10, lower=lower, upper=upper)
fit$par[1:length(fit$par)] = pars#
#
plot(phy, label.offset=0.1)#
tiplabels(text=phy$tip.state, tip=1:5, col="black", bg=cols[phy2$tip.state+1])
phy$tip.state
diversitree:::plot.history(h, phy, main="True history", cols=cols)
h
set.seed(75) # Rare to have a transition, but observed here#
pars <- c(0.222222222, 0.222222222, 0.111111111, 0.0111111111, 0.06, 0.05)#
#
phy <- trees(pars, "bisse", max.taxa=5, max.t=Inf, x0=0)[[1]]#
cols = c("blue", "green3")#
lower = rep(0.0, times=length(pars))#
upper = rep(10.0, times=length(pars))#
#
## Here is the true history#
h <- history.from.sim.discrete(phy, 0:1)#
diversitree:::plot.history(h, phy, main="True history", cols=cols)#
#
lik <- make.bisse(phy, phy$tip.state)#
#fit <- find.mle(lik, pars, method="subplex")#
fit <- find.mle(func=lik, x.init=pars, method="subplex", fail.value=-1e10, lower=lower, upper=upper)#
#
# ML on this tiny dataset is meaningless#
fit$par[1:length(fit$par)] = pars#
#
plot(phy, label.offset=0.1)#
tiplabels(text=phy$tip.state, tip=1:5, col="black", bg=cols[phy2$tip.state+1])#
#diversitree:::plot.history(h, phy, main="True history", cols=cols)#
#
#fit2 <- find.mle(lik2, pars, method="subplex", fail.value=-1e10)#
st <- asr.marginal(lik, pars)#
nodelabels(thermo=t(st2), piecol=cols, cex=0.5)#
t(st2)#
#
states_df2 = cft(adf2(t(st2)))#
states_df2#
#
nodelabels(thermo=t(st2), piecol=cols, cex=0.5)
set.seed(75) # Rare to have a transition, but observed here#
pars <- c(0.222222222, 0.222222222, 0.111111111, 0.0111111111, 0.06, 0.05)#
#
phy <- trees(pars, "bisse", max.taxa=5, max.t=Inf, x0=0)[[1]]#
cols = c("blue", "green3")#
lower = rep(0.0, times=length(pars))#
upper = rep(10.0, times=length(pars))#
#
## Here is the true history#
h <- history.from.sim.discrete(phy, 0:1)#
diversitree:::plot.history(h, phy, main="True history", cols=cols)
set.seed(77) # Rare to have a transition, but observed here#
pars <- c(0.222222222, 0.222222222, 0.111111111, 0.0111111111, 0.06, 0.05)#
#
phy <- trees(pars, "bisse", max.taxa=5, max.t=Inf, x0=0)[[1]]#
cols = c("blue", "green3")#
lower = rep(0.0, times=length(pars))#
upper = rep(10.0, times=length(pars))#
#
## Here is the true history#
h <- history.from.sim.discrete(phy, 0:1)#
diversitree:::plot.history(h, phy, main="True history", cols=cols)
set.seed(79) # Rare to have a transition, but observed here#
pars <- c(0.222222222, 0.222222222, 0.111111111, 0.0111111111, 0.06, 0.05)#
#
phy <- trees(pars, "bisse", max.taxa=5, max.t=Inf, x0=0)[[1]]#
cols = c("blue", "green3")#
lower = rep(0.0, times=length(pars))#
upper = rep(10.0, times=length(pars))#
#
## Here is the true history#
h <- history.from.sim.discrete(phy, 0:1)#
diversitree:::plot.history(h, phy, main="True history", cols=cols)
set.seed(81) # Rare to have a transition, but observed here#
pars <- c(0.222222222, 0.222222222, 0.111111111, 0.0111111111, 0.06, 0.05)#
#
phy <- trees(pars, "bisse", max.taxa=5, max.t=Inf, x0=0)[[1]]#
cols = c("blue", "green3")#
lower = rep(0.0, times=length(pars))#
upper = rep(10.0, times=length(pars))#
#
## Here is the true history#
h <- history.from.sim.discrete(phy, 0:1)#
diversitree:::plot.history(h, phy, main="True history", cols=cols)
set.seed(813) # Rare to have a transition, but observed here#
pars <- c(0.222222222, 0.222222222, 0.111111111, 0.0111111111, 0.06, 0.05)#
#
phy <- trees(pars, "bisse", max.taxa=5, max.t=Inf, x0=0)[[1]]#
cols = c("blue", "green3")#
lower = rep(0.0, times=length(pars))#
upper = rep(10.0, times=length(pars))#
#
## Here is the true history#
h <- history.from.sim.discrete(phy, 0:1)#
diversitree:::plot.history(h, phy, main="True history", cols=cols)#
#
lik <- make.bisse(phy, phy$tip.state)#
#fit <- find.mle(lik, pars, method="subplex")#
fit <- find.mle(func=lik, x.init=pars, method="subplex", fail.value=-1e10, lower=lower, upper=upper)
set.seed(8153) # Rare to have a transition, but observed here#
pars <- c(0.222222222, 0.222222222, 0.111111111, 0.0111111111, 0.06, 0.05)#
#
phy <- trees(pars, "bisse", max.taxa=5, max.t=Inf, x0=0)[[1]]#
cols = c("blue", "green3")#
lower = rep(0.0, times=length(pars))#
upper = rep(10.0, times=length(pars))#
#
## Here is the true history#
h <- history.from.sim.discrete(phy, 0:1)#
diversitree:::plot.history(h, phy, main="True history", cols=cols)
set.seed(654) # Rare to have a transition, but observed here#
pars <- c(0.222222222, 0.222222222, 0.111111111, 0.0111111111, 0.06, 0.05)#
#
phy <- trees(pars, "bisse", max.taxa=5, max.t=Inf, x0=0)[[1]]#
cols = c("blue", "green3")#
lower = rep(0.0, times=length(pars))#
upper = rep(10.0, times=length(pars))#
#
## Here is the true history#
h <- history.from.sim.discrete(phy, 0:1)#
diversitree:::plot.history(h, phy, main="True history", cols=cols)
set.seed(6534) # Rare to have a transition, but observed here#
pars <- c(0.222222222, 0.222222222, 0.111111111, 0.0111111111, 0.06, 0.05)#
#
phy <- trees(pars, "bisse", max.taxa=5, max.t=Inf, x0=0)[[1]]#
cols = c("blue", "green3")#
lower = rep(0.0, times=length(pars))#
upper = rep(10.0, times=length(pars))#
#
## Here is the true history#
h <- history.from.sim.discrete(phy, 0:1)#
diversitree:::plot.history(h, phy, main="True history", cols=cols)
lik <- make.bisse(phy, phy$tip.state)#
#fit <- find.mle(lik, pars, method="subplex")#
fit <- find.mle(func=lik, x.init=pars, method="subplex", fail.value=-1e10, lower=lower, upper=upper)#
#
# ML on this tiny dataset is meaningless#
fit$par[1:length(fit$par)] = pars#
#
plot(phy, label.offset=0.1)#
tiplabels(text=phy$tip.state, tip=1:5, col="black", bg=cols[phy2$tip.state+1])
phy$tip.state
plot(phy, label.offset=0.1)#
tiplabels(text=phy$tip.state, tip=names(phy$tip.state), col="black", bg=cols[phy2$tip.state+1])
*phy$tip.state
phy$tip.state
plot(phy, label.offset=0.2)#
axisPhylo()#
tiplabels(text=phy$tip.state, col="black", bg=cols[phy2$tip.state+1])
phy
prt(phy)
set.seed(6534) # Rare to have a transition, but observed here#
pars <- c(0.222222222, 0.222222222, 0.111111111, 0.0111111111, 0.06, 0.05)#
#
phy <- trees(pars, "bisse", max.taxa=5, max.t=Inf, x0=0)[[1]]#
cols = c("blue", "green3")#
lower = rep(0.0, times=length(pars))#
upper = rep(10.0, times=length(pars))#
#
## Here is the true history#
h <- history.from.sim.discrete(phy, 0:1)#
diversitree:::plot.history(h, phy, main="True history", cols=cols)#
#
lik <- make.bisse(phy, phy$tip.state)#
#fit <- find.mle(lik, pars, method="subplex")#
fit <- find.mle(func=lik, x.init=pars, method="subplex", fail.value=-1e10, lower=lower, upper=upper)#
#
# ML on this tiny dataset is meaningless#
fit$par[1:length(fit$par)] = pars#
#
plot(phy, label.offset=0.2)#
axisPhylo()#
tiplabels(text=phy$tip.state, tip=names(phy$tip.state), col="black", bg=cols[phy$tip.state+1])
tiplabels(text=phy$tip.state, tip=1:5, col="black", bg=cols[phy$tip.state+1])
st <- asr.marginal(lik, pars)#
nodelabels(thermo=t(st), piecol=cols, cex=0.5)#
t(st)
st <- asr.marginal(lik, pars)#
nodelabels(thermo=t(st), piecol=cols, cex=0.5)#
t(st)#
#
states_df = cft(adf2(t(st)))#
states_df#
#
nodelabels(thermo=t(st), piecol=cols, cex=0.5)
write.tree(phy, file="")
pht$tip.data
phy$tip.data
phy$tip.state
pars
/GitHub/PhyBEARS.jl/test/simtree_5taxa_SSE
t(st)
lik
lik(pars)
make.bisse
make.classe
lik(pars)
lik(pars, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)
attr(reslnls,"intermediates")$lq
reslnls = lik(pars, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
# -15.63256#
attr(reslnls,"intermediates")$lq
sum(attr(reslnls,"intermediates")$lq)
pars
sum(attr(reslnls,"intermediates")$lq)
reslnls = lik(pars, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
# -15.63256#
sum(attr(reslnls,"intermediates")$lq)
reslnls = lik(pars, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
# -15.63256#
sum(attr(reslnls,"intermediates")$lq)#
# -12.87511#
reslnls = lik(pars, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
# -12.87511#
sum(attr(reslnls,"intermediates")$lq)
library(BioGeoBEARS)#
library(diversitree)#
source("/GitHub/PhyBEARS.jl/Rsrc/ClaSSE_mods_v2.R")#
source("/GitHub/PhyBEARS.jl/Rsrc/ClaSSE_functions_v3.R")#
#
## Start with a simple tree evolved under a BiSSE with all rates#
## asymmetric:#
# lambda0, lambda1, mu0, mu1, q01, q10#
#
# Gives weird result -- green nodes, blue truth#
set.seed(47) # Rare to have a transition, but observed here#
pars <- c(0.222222222, 0.222222222, 0.111111111, 0.05, 0.1, 0.15)#
bisse_params = pars#
birthRate = pars[1]#
deathRate = pars[3]#
#
set.seed(48) # Rare to have a transition, but observed here#
phy <- trees(pars, "bisse", max.taxa=4, max.t=Inf, x0=0)[[1]]#
write.tree(phy, file="")#
#
cols = c("blue", "green3")#
lower = rep(0.0, times=length(pars))#
upper = rep(10.0, times=length(pars))#
#
## Here is the true history#
h <- history.from.sim.discrete(phy, 0:1)#
diversitree:::plot.history(h, phy, main="True history", cols=cols)#
#
lik <- make.bisse(phy, phy$tip.state)#
phy$tip.state#
#
bisse_2areas = lik#
#fit <- find.mle(lik, pars, method="subplex")#
fit <- find.mle(func=lik, x.init=pars, method="subplex", fail.value=-1e10, lower=lower, upper=upper)#
coef(fit)#
st <- asr.marginal(lik, coef(fit))#
nodelabels(thermo=t(st), piecol=cols, cex=0.5)#
res1 = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
res2 = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0, 1)#
res3 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.25, 0.75)#
res4 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.5,0.5)#
res5 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
res6 = bisse_2areas(pars=bisse_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
#
# Res1t is BiSSE default#
res1t = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
res2t = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0, 1)#
res3t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.25, 0.75)#
res4t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.5,0.5)#
res5t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
res6t = bisse_2areas(pars=bisse_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
# get_classe_LnLs returns the total log-likelihood, and #
# the total of the branch likelihoods#
LnLs1 = get_classe_LnLs(res1)#
LnLs2 = get_classe_LnLs(res2)#
LnLs3 = get_classe_LnLs(res3)#
LnLs4 = get_classe_LnLs(res4)#
LnLs5 = get_classe_LnLs(res5)#
LnLs6 = get_classe_LnLs(res6)#
LnLs1t = get_classe_LnLs(res1t)#
LnLs2t = get_classe_LnLs(res2t)#
LnLs3t = get_classe_LnLs(res3t)#
LnLs4t = get_classe_LnLs(res4t)#
LnLs5t = get_classe_LnLs(res5t)#
LnLs6t = get_classe_LnLs(res6t)#
#
LnLst = as.data.frame(rbind(LnLs1, LnLs2, LnLs3, LnLs4, LnLs5, LnLs6, LnLs1t, LnLs2t, LnLs3t, LnLs4t, LnLs5t, LnLs6t), stringsAsFactors=FALSE)#
names(LnLst) = c("ttl_LnL", "branch_LnL")#
ObsDiff = (LnLst$ttl_LnL - LnLst$branch_LnL)#
exp_ObsDiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL))#
LnLdiff = round((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)), digits=4)#
exp_LnLdiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)))#
LnLst2 = cbind(LnLst, ObsDiff, LnLdiff, exp_ObsDiff, exp_LnLdiff)#
cft(LnLst2, numdigits_inbetween_have_fixed_digits=8)
res1t
res5t
LnLst5
LnLst2
LnLst2["LnLs5t",]
LnLst2["LnLs5t","branch_LnL"]
LnLst2["LnLs5t","ttl_LnL"]
LnLst2["LnLs1t","branch_LnL"]
LnLst2["LnLs1t","ttl_LnL"]
LnLst2["LnLs1","ttl_LnL"]
LnLst2["LnLs1","branch_LnL"]
LnLst2["LnLs1","branch_LnL"]#
LnLst2["LnLs1","ttl_LnL"]
-6.670978+-0.7933087125199055
LnLst2["LnLs1","branch_LnL"]#
LnLst2["LnLs1t","ttl_LnL"]
LnLs1t
LnLs1
reLnLs1
LnLs1
LnLs1t
-9.574440+-2.9034623
EsDs = t(attr(res1t,"intermediates")$init)#
sum(log(rowSums(EsDs[,3:4])))#
attr(res1t,"intermediates")$lq
sum(attr(res1t,"intermediates")$lq)
res1t
sum(log(rowSums(EsDs[,3:4])))#
attr(res1t,"intermediates")$lq
EsDs = t(attr(res1t,"intermediates")$init)#
sum(log(rowSums(EsDs[,3:4])))#
attr(res1t,"intermediates")$lq#
sum(attr(res1t,"intermediates")$lq)#
sum(log(rowSums(EsDs[,3:4]))) + sum(attr(res1t,"intermediates")$lq)
########################################################
# Look at find.mle#
########################################################
methods("find.mle")#
diversitree:::find.mle.default#
diversitree:::find.mle.dtlik#
diversitree:::find.mle.mixed#
diversitree:::do.mle.search#
# change to create some ambiguity#
#
phy2 = phy#
phy2$edge.length[c(1,4)] = c(1-phy2$edge.length[2], 1-phy2$edge.length[6])#
phy2$tip.state[1:4] = c(0, 1, 0, 1)#
#
plot(phy2, label.offset=0.1)#
tiplabels(text=phy2$tip.state, tip=1:4, col="black", bg=cols[phy2$tip.state+1])#
#diversitree:::plot.history(h, phy, main="True history", cols=cols)#
#
lik2 <- make.bisse(phy2, phy2$tip.state)#
fit2 <- find.mle(func=lik2, x.init=coef(fit), method="subplex", fail.value=-1e10, lower=lower, upper=upper)#
coef(fit2 )#
#fit2 <- find.mle(lik2, pars, method="subplex", fail.value=-1e10)#
st2 <- asr.marginal(lik2, coef(fit2))#
nodelabels(thermo=t(st2), piecol=cols, cex=0.5)#
t(st2)
pars
st
t(st)
st2
LIK2
lik2
names(lik2)
str(lik2)
attributes(lik2)
attr(lik2)
attr(lik2, "dtlik")
st2 <- asr.marginal(lik2, pars)
st2
coef(fit2)
pars
st2 <- asr.marginal(lik2, coef(fit2))#
names(pars) = names(coef(fit2))#
st2 <- asr.marginal(lik2, pars)
st2
pars
st2
pars$mu0 = 0#
pars$mu1 = 0#
st2 <- asr.marginal(lik2, pars)
names(pars) = names(coef(fit2))#
pars["mu0"] = 0#
pars["mu1"] = 0#
st2 <- asr.marginal(lik2, pars)
set.seed(47) # Rare to have a transition, but observed here#
pars <- c(0.222222222, 0.222222222, 0.111111111, 0.05, 0.1, 0.15)#
bisse_params = pars#
birthRate = pars[1]#
deathRate = pars[3]#
#
set.seed(48) # Rare to have a transition, but observed here#
phy <- trees(pars, "bisse", max.taxa=4, max.t=Inf, x0=0)[[1]]#
write.tree(phy, file="")#
#
cols = c("blue", "green3")#
lower = rep(0.0, times=length(pars))#
upper = rep(10.0, times=length(pars))#
#
## Here is the true history#
h <- history.from.sim.discrete(phy, 0:1)#
diversitree:::plot.history(h, phy, main="True history", cols=cols)#
#
lik <- make.bisse(phy, phy$tip.state)#
phy$tip.state#
#
bisse_2areas = lik#
#fit <- find.mle(lik, pars, method="subplex")#
# MLE doesn't make much sense with tiny data#
fit <- find.mle(func=lik, x.init=pars, method="subplex", fail.value=-1e10, lower=lower, upper=upper)#
coef(fit)#
st <- asr.marginal(lik, coef(fit))#
nodelabels(thermo=t(st), piecol=cols, cex=0.5)#
t(st)#
res1 = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
res2 = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0, 1)#
res3 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.25, 0.75)#
res4 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.5,0.5)#
res5 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
res6 = bisse_2areas(pars=bisse_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
#
# Res1t is BiSSE default#
res1t = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
res2t = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0, 1)#
res3t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.25, 0.75)#
res4t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.5,0.5)#
res5t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
res6t = bisse_2areas(pars=bisse_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
# get_classe_LnLs returns the total log-likelihood, and #
# the total of the branch likelihoods#
LnLs1 = get_classe_LnLs(res1)#
LnLs2 = get_classe_LnLs(res2)#
LnLs3 = get_classe_LnLs(res3)#
LnLs4 = get_classe_LnLs(res4)#
LnLs5 = get_classe_LnLs(res5)#
LnLs6 = get_classe_LnLs(res6)#
LnLs1t = get_classe_LnLs(res1t)#
LnLs2t = get_classe_LnLs(res2t)#
LnLs3t = get_classe_LnLs(res3t)#
LnLs4t = get_classe_LnLs(res4t)#
LnLs5t = get_classe_LnLs(res5t)#
LnLs6t = get_classe_LnLs(res6t)#
#
LnLst = as.data.frame(rbind(LnLs1, LnLs2, LnLs3, LnLs4, LnLs5, LnLs6, LnLs1t, LnLs2t, LnLs3t, LnLs4t, LnLs5t, LnLs6t), stringsAsFactors=FALSE)#
names(LnLst) = c("ttl_LnL", "branch_LnL")#
ObsDiff = (LnLst$ttl_LnL - LnLst$branch_LnL)#
exp_ObsDiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL))#
LnLdiff = round((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)), digits=4)#
exp_LnLdiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)))#
LnLst2 = cbind(LnLst, ObsDiff, LnLdiff, exp_ObsDiff, exp_LnLdiff)#
cft(LnLst2, numdigits_inbetween_have_fixed_digits=8)#
#
# Compare to Julia:#
# > LnLs1#
# [1] -9.574440 -6.670978#
# > LnLs1t#
# [1] -7.464283 -6.670978#
EsDs = t(attr(res1t,"intermediates")$init)#
sum(log(rowSums(EsDs[,3:4])))#
attr(res1t,"intermediates")$lq#
sum(attr(res1t,"intermediates")$lq)#
#
# This corresponds to:#
# Julia_sum_lq_nodes = sum(log.(sum.(res.likes_at_each_nodeIndex_branchTop))) + Julia_sum_lq#
# R_sum_lq_nodes = R_result_sum_log_computed_likelihoods_at_each_node_x_lambda#
sum(log(rowSums(EsDs[,3:4]))) + sum(attr(res1t,"intermediates")$lq)#
# ...but is double-counting lnLs#
########################################################
# Look at ASRs#
########################################################
########################################################
# TRYING TO FIT TO SIMULATED DATA#
# This **FAILS** with such tiny data#
########################################################
########################################################
# Look at find.mle#
########################################################
methods("find.mle")#
diversitree:::find.mle.default#
diversitree:::find.mle.dtlik#
diversitree:::find.mle.mixed#
diversitree:::do.mle.search#
# change to create some ambiguity#
#
phy2 = phy#
#
plot(phy2, label.offset=0.1)#
tiplabels(text=phy2$tip.state, tip=1:4, col="black", bg=cols[phy2$tip.state+1])#
#diversitree:::plot.history(h, phy, main="True history", cols=cols)#
#
lik2 <- make.bisse(phy2, phy2$tip.state)#
fit2 <- find.mle(func=lik2, x.init=coef(fit), method="subplex", fail.value=-1e10, lower=lower, upper=upper)#
coef(fit2 )#
#fit2 <- find.mle(lik2, pars, method="subplex", fail.value=-1e10)#
st2 <- asr.marginal(lik2, coef(fit2))#
names(pars) = names(coef(fit2))#
pars["mu0"] = 0#
pars["mu1"] = 0#
st2 <- asr.marginal(lik2, pars)
st2
tr
phy
plot(phy)
axisPhylo()
lik
res1t
?asr.marginal
st2 <- asr.marginal(lik2, pars, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
t(st2)
st2 <- asr.marginal(lik2, pars, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
st2 <- asr.marginal(lik2, pars)
st2 <- asr.marginal(lik2, pars, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
t(st2)#
st2 <- asr.marginal(lik2, pars)#
t(st2)
attr(res1t,"intermediates")$root.p
attr(res1,"intermediates")$root.p#
attr(res2,"intermediates")$root.p#
attr(res3,"intermediates")$root.p#
attr(res4,"intermediates")$root.p#
attr(res5,"intermediates")$root.p#
attr(res6,"intermediates")$root.p#
#
attr(res1t,"intermediates")$root.p#
attr(res2t,"intermediates")$root.p#
attr(res3t,"intermediates")$root.p#
attr(res4t,"intermediates")$root.p#
attr(res5t,"intermediates")$root.p#
attr(res6t,"intermediates")$root.p
rbind(attr(res6t,"intermediates")$root.p#
,attr(res6t,"intermediates")$root.p#
,attr(res6t,"intermediates")$root.p#
)
tmpmat = rbind(attr(res1,"intermediates")$root.p, #
attr(res2,"intermediates")$root.p, #
attr(res3,"intermediates")$root.p, #
attr(res4,"intermediates")$root.p, #
attr(res5,"intermediates")$root.p, #
attr(res6,"intermediates")$root.p, #
attr(res1t,"intermediates")$root.p, #
attr(res2t,"intermediates")$root.p, #
attr(res3t,"intermediates")$root.p, #
attr(res4t,"intermediates")$root.p, #
attr(res5t,"intermediates")$root.p, #
attr(res6t,"intermediates")$root.p#
)
tmpmat
tmpmat = rbind(attr(res1,"intermediates")$root.p, #
attr(res2,"intermediates")$root.p, #
attr(res3,"intermediates")$root.p, #
attr(res4,"intermediates")$root.p, #
attr(res5,"intermediates")$root.p, #
attr(res6,"intermediates")$root.p, #
attr(res1t,"intermediates")$root.p, #
attr(res2t,"intermediates")$root.p, #
attr(res3t,"intermediates")$root.p, #
attr(res4t,"intermediates")$root.p, #
attr(res5t,"intermediates")$root.p, #
attr(res6t,"intermediates")$root.p#
)#
#
tmpnames = paste0("ancstate", seq(1,ncol(tmpmat),1))
tmpnames
tmpmat = rbind(attr(res1,"intermediates")$root.p, #
attr(res2,"intermediates")$root.p, #
attr(res3,"intermediates")$root.p, #
attr(res4,"intermediates")$root.p, #
attr(res5,"intermediates")$root.p, #
attr(res6,"intermediates")$root.p, #
attr(res1t,"intermediates")$root.p, #
attr(res2t,"intermediates")$root.p, #
attr(res3t,"intermediates")$root.p, #
attr(res4t,"intermediates")$root.p, #
attr(res5t,"intermediates")$root.p, #
attr(res6t,"intermediates")$root.p#
)#
#
tmpnames = paste0("ancstate", seq(1,ncol(tmpmat),1))#
#
tmprownames = c("res1", "res2", "res3", "res4", "res5", "res6", "res1t", "res2t", "res3t", "res4t", "res5t", "res6t")#
#
rootstates_df = adf2(tmpmat)#
names(rootstates_df) = tmpnames#
row.names(rootstates_df) = tmprownames#
rootstates_df
phy2 = phy#
#
plot(phy2, label.offset=0.1)#
tiplabels(text=phy2$tip.state, tip=1:4, col="black", bg=cols[phy2$tip.state+1])#
#diversitree:::plot.history(h, phy, main="True history", cols=cols)#
#
lik2 <- make.bisse(phy2, phy2$tip.state)#
fit2 <- find.mle(func=lik2, x.init=coef(fit), method="subplex", fail.value=-1e10, lower=lower, upper=upper)#
coef(fit2 )#
#fit2 <- find.mle(lik2, pars, method="subplex", fail.value=-1e10)#
st2 <- asr.marginal(lik2, coef(fit2))#
nodelabels(thermo=t(st2), piecol=cols, cex=0.5)#
t(st2)#
#
names(pars) = names(coef(fit2))#
st2 <- asr.marginal(lik2, pars)#
t(st2)
pars
pars <- c(0.222222222, 0.222222222, 0.111111111, 0.05, 0.1, 0.15)#
orig_pars = pars
# change to create some ambiguity#
#
phy2 = phy#
#
plot(phy2, label.offset=0.1)#
tiplabels(text=phy2$tip.state, tip=1:4, col="black", bg=cols[phy2$tip.state+1])#
#diversitree:::plot.history(h, phy, main="True history", cols=cols)#
#
lik2 <- make.bisse(phy2, phy2$tip.state)#
fit2 <- find.mle(func=lik2, x.init=coef(fit), method="subplex", fail.value=-1e10, lower=lower, upper=upper)#
coef(fit2 )#
#fit2 <- find.mle(lik2, pars, method="subplex", fail.value=-1e10)#
st2 <- asr.marginal(lik2, coef(fit2))#
nodelabels(thermo=t(st2), piecol=cols, cex=0.5)#
t(st2)#
#
orig_pars = pars#
names(pars) = names(coef(fit2))#
st2 <- asr.marginal(lik2, pars)#
t(st2)
st2 <- asr.marginal(lik2, pars, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)
t(st2)
ROOT.OBS
st2 <- asr.marginal(lik2, pars, root=ROOT.OBS, root.p=NULL, condition.surv=TRUE)#
t(st2)
st2 <- asr.marginal(lik2, pars, root=ROOT.OBS, root.p=NULL, condition.surv=FALSE)
t(st2)
st2 <- asr.marginal(lik2, pars, condition.surv=TRUE)#
t(st2)
st2 <- asr.marginal(lik2, pars, root=ROOT.OBS, condition.surv=TRUE)#
t(st2)
st2 <- asr.marginal(lik2, pars, root=ROOT.OBS, root.p=NULL, condition.surv=FALSE)#
t(st2)
res1
t(attr(res1,"intermediates")$init)
rootnode = length(phy$tip.label)+1#
EsDs = t(attr(res1,"intermediates")$init)#
EsDs[rootnode, 3:4]#
EsDs[rootnode, 3:4] / sum(EsDs[rootnode, 3:4])
rootnode = length(phy$tip.label)+1#
EsDs = t(attr(res2,"intermediates")$init)#
EsDs[rootnode, 3:4]#
EsDs[rootnode, 3:4] / sum(EsDs[rootnode, 3:4])
rootnode = length(phy$tip.label)+1#
EsDs = t(attr(res3,"intermediates")$init)#
EsDs[rootnode, 3:4] / sum(EsDs[rootnode, 3:4])
rootnode = length(phy$tip.label)+1#
EsDs = t(attr(res4,"intermediates")$init)#
EsDs[rootnode, 3:4] / sum(EsDs[rootnode, 3:4])
rootnode = length(phy$tip.label)+1#
EsDs = t(attr(res5,"intermediates")$init)#
EsDs[rootnode, 3:4] / sum(EsDs[rootnode, 3:4])
rootnode = length(phy$tip.label)+1#
EsDs = t(attr(res6,"intermediates")$init)#
EsDs[rootnode, 3:4] / sum(EsDs[rootnode, 3:4])
rootnode = length(phy$tip.label)+1#
EsDs = t(attr(res6t,"intermediates")$init)#
EsDs[rootnode, 3:4] / sum(EsDs[rootnode, 3:4])
res1
t(st2)
solver_options.solver = CVODE_BDF{:Newton, :GMRES, Nothing, Nothing}(0, 0, 0, false, 10, 5, 7, 3, 10, nothing, nothing, 0)#
#solver_options.solver = Tsit5()#
solver_options.solver = Vern9()#
solver_options.abstol = 1e-6#
solver_options.reltol = 1e-6#
solver_options.save_everystep = false#
include("/GitHub/PhyBEARS.jl/notes/nodeOp_Cmat_uppass_v12.jl")#
tspan = (anctime, dectime)#
#
prob_Ds_v5 = DifferentialEquations.ODEProblem(calcDs_4states2A, u0, tspan, p_Ds_v5);#
sol_Ds_v5 = solve(prob_Ds_v5, solver_options.solver, save_everystep=solver_options.save_everystep, abstol=solver_options.abstol, reltol=solver_options.reltol);#
#
sol_Ds_v5(anctime)#
sol_Ds_v5(anctime) ./ sum(sol_Ds_v5(anctime))#
sol_Ds_v5(dectime)#
lbranch_top = sol_Ds_v5(dectime) ./ sum(sol_Ds_v5(dectime))#
#
uppass_likes = lbranch_top .* res.normlikes_at_each_nodeIndex_branchTop[lnode]#
uppass_likes ./ sum(uppass_likes)
library(BioGeoBEARS)#
library(diversitree)#
source("/GitHub/PhyBEARS.jl/Rsrc/ClaSSE_mods_v2.R")#
source("/GitHub/PhyBEARS.jl/Rsrc/ClaSSE_functions_v3.R")#
#
## Start with a simple tree evolved under a BiSSE with all rates#
## asymmetric:#
# lambda0, lambda1, mu0, mu1, q01, q10#
#
# Gives weird result -- green nodes, blue truth#
set.seed(47) # Rare to have a transition, but observed here#
pars <- c(0.222222222, 0.222222222, 0.111111111, 0.05, 0.1, 0.15)#
orig_pars = pars#
bisse_params = pars#
birthRate = pars[1]#
deathRate = pars[3]#
#
set.seed(48) # Rare to have a transition, but observed here#
phy <- trees(pars, "bisse", max.taxa=4, max.t=Inf, x0=0)[[1]]#
write.tree(phy, file="")#
#
cols = c("blue", "green3")#
lower = rep(0.0, times=length(pars))#
upper = rep(10.0, times=length(pars))#
#
## Here is the true history#
h <- history.from.sim.discrete(phy, 0:1)#
diversitree:::plot.history(h, phy, main="True history", cols=cols)#
#
lik <- make.bisse(phy, phy$tip.state)#
phy$tip.state#
#
bisse_2areas = lik#
#fit <- find.mle(lik, pars, method="subplex")#
# MLE doesn't make much sense with tiny data#
fit <- find.mle(func=lik, x.init=pars, method="subplex", fail.value=-1e10, lower=lower, upper=upper)#
coef(fit)#
st <- asr.marginal(lik, coef(fit))#
nodelabels(thermo=t(st), piecol=cols, cex=0.5)#
t(st)#
res1 = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
res2 = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0, 1)#
res3 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.25, 0.75)#
res4 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.5,0.5)#
res5 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
res6 = bisse_2areas(pars=bisse_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
#
# Res1t is BiSSE default#
# "lik" matches res1t#
res1t = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
res2t = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0, 1)#
res3t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.25, 0.75)#
res4t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.5,0.5)#
res5t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
res6t = bisse_2areas(pars=bisse_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
# get_classe_LnLs returns the total log-likelihood, and #
# the total of the branch likelihoods#
LnLs1 = get_classe_LnLs(res1)#
LnLs2 = get_classe_LnLs(res2)#
LnLs3 = get_classe_LnLs(res3)#
LnLs4 = get_classe_LnLs(res4)#
LnLs5 = get_classe_LnLs(res5)#
LnLs6 = get_classe_LnLs(res6)#
LnLs1t = get_classe_LnLs(res1t)#
LnLs2t = get_classe_LnLs(res2t)#
LnLs3t = get_classe_LnLs(res3t)#
LnLs4t = get_classe_LnLs(res4t)#
LnLs5t = get_classe_LnLs(res5t)#
LnLs6t = get_classe_LnLs(res6t)#
#
LnLst = as.data.frame(rbind(LnLs1, LnLs2, LnLs3, LnLs4, LnLs5, LnLs6, LnLs1t, LnLs2t, LnLs3t, LnLs4t, LnLs5t, LnLs6t), stringsAsFactors=FALSE)#
names(LnLst) = c("ttl_LnL", "branch_LnL")#
ObsDiff = (LnLst$ttl_LnL - LnLst$branch_LnL)#
exp_ObsDiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL))#
LnLdiff = round((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)), digits=4)#
exp_LnLdiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)))#
LnLst2 = cbind(LnLst, ObsDiff, LnLdiff, exp_ObsDiff, exp_LnLdiff)#
cft(LnLst2, numdigits_inbetween_have_fixed_digits=8)#
#
# Compare to Julia:#
# > LnLs1#
# [1] -9.574440 -6.670978#
# > LnLs1t#
# [1] -7.464283 -6.670978#
EsDs = t(attr(res1t,"intermediates")$init)#
sum(log(rowSums(EsDs[,3:4])))#
attr(res1t,"intermediates")$lq#
sum(attr(res1t,"intermediates")$lq)#
#
# This corresponds to:#
# Julia_sum_lq_nodes = sum(log.(sum.(res.likes_at_each_nodeIndex_branchTop))) + Julia_sum_lq#
# R_sum_lq_nodes = R_result_sum_log_computed_likelihoods_at_each_node_x_lambda#
sum(log(rowSums(EsDs[,3:4]))) + sum(attr(res1t,"intermediates")$lq)#
# ...but is double-counting lnLs#
########################################################
# Look at ASRs#
########################################################
tmpmat = rbind(attr(res1,"intermediates")$root.p, #
attr(res2,"intermediates")$root.p, #
attr(res3,"intermediates")$root.p, #
attr(res4,"intermediates")$root.p, #
attr(res5,"intermediates")$root.p, #
attr(res6,"intermediates")$root.p, #
attr(res1t,"intermediates")$root.p, #
attr(res2t,"intermediates")$root.p, #
attr(res3t,"intermediates")$root.p, #
attr(res4t,"intermediates")$root.p, #
attr(res5t,"intermediates")$root.p, #
attr(res6t,"intermediates")$root.p#
)#
#
tmpnames = paste0("ancstate", seq(1,ncol(tmpmat),1))#
#
tmprownames = c("res1", "res2", "res3", "res4", "res5", "res6", "res1t", "res2t", "res3t", "res4t", "res5t", "res6t")#
#
rootstates_df = adf2(tmpmat)#
names(rootstates_df) = tmpnames#
row.names(rootstates_df) = tmprownames#
rootstates_df#
#
# rootstates_df#
#       ancstate1 ancstate2#
# res1  0.4303571 0.5696429 # <- this is what asr.marginal gives#
# res2  0.5000000 0.5000000#
# res3  0.0000000 1.0000000#
# res4  0.2500000 0.7500000#
# res5  0.5000000 0.5000000#
# res6  0.5392658 0.4607342#
# res1t 0.4303571 0.5696429 # <- this is what asr.marginal gives#
# res2t 0.5000000 0.5000000#
# res3t 0.0000000 1.0000000#
# res4t 0.2500000 0.7500000#
# res5t 0.5000000 0.5000000#
# res6t 0.5392658 0.4607342#
#
# Same for everything:#
rootnode = length(phy$tip.label)+1#
EsDs = t(attr(res1,"intermediates")$init)#
EsDs[rootnode, 3:4] / sum(EsDs[rootnode, 3:4])#
########################################################
# TRYING TO FIT TO SIMULATED DATA#
# This **FAILS** with such tiny data#
########################################################
########################################################
# Look at find.mle#
########################################################
methods("find.mle")#
diversitree:::find.mle.default#
diversitree:::find.mle.dtlik#
diversitree:::find.mle.mixed#
diversitree:::do.mle.search#
# change to create some ambiguity#
#
phy2 = phy#
#
plot(phy2, label.offset=0.1)#
tiplabels(text=phy2$tip.state, tip=1:4, col="black", bg=cols[phy2$tip.state+1])#
#diversitree:::plot.history(h, phy, main="True history", cols=cols)#
#
lik2 <- make.bisse(phy2, phy2$tip.state)#
fit2 <- find.mle(func=lik2, x.init=coef(fit), method="subplex", fail.value=-1e10, lower=lower, upper=upper)#
coef(fit2 )#
#fit2 <- find.mle(lik2, pars, method="subplex", fail.value=-1e10)#
st2 <- asr.marginal(lik2, coef(fit2))#
nodelabels(thermo=t(st2), piecol=cols, cex=0.5)#
t(st2)#
#
orig_pars = pars#
names(pars) = names(coef(fit2))#
st2 <- asr.marginal(lik2, pars)#
t(st2)#
st2 <- asr.marginal(lik2, pars, root=ROOT.OBS, root.p=NULL, condition.surv=FALSE)#
t(st2)#
#
# t(st2)#
#             [,1]         [,2]#
# [1,] 0.430357148 0.5696428522  # <- matches res1 or res1t#
# [2,] 0.005145312 0.9948546878#
# [3,] 0.999681941 0.0003180585#
st2 <- asr.marginal(lik2, pars, root=ROOT.OBS, condition.surv=TRUE)#
t(st2)#
# > t(st2)#
#           [,1]        [,2]#
# [1,] 0.49926227 0.500737731#
# [2,] 0.00570688 0.994293120#
# [3,] 0.99963639 0.000363611#
# Turn off extinction; the speciation/extinction thing dominates on large branches I guess#
pars["mu0"] = 0#
pars["mu1"] = 0#
st2 <- asr.marginal(lik2, pars, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
t(st2)#
st2 <- asr.marginal(lik2, pars)#
t(st2)#
#
########################################################
# Edit to clarify node structure#
########################################################
st2[,1] = c(0.5, 0.5)#
st2[,2] = c(0.75, 0.25)#
st2[,3] = c(1.0, 0.0)#
#
nodelabels(thermo=t(st2), piecol=cols, cex=0.5)#
# So, this shows nodes 5,6,7:#
t(st2)
include("/GitHub/PhyBEARS.jl/notes/nodeOp_Cmat_uppass_v12.jl")#
#
ctable1 = prtCp(p_Ds_v5)#
make_ctable_single_events(ctable1)#
u0 = left_likes#
prob_Ds_v5 = DifferentialEquations.ODEProblem(calcDs_4states2G, u0, tspan, p_Ds_v5);#
sol_Ds_v5 = solve(prob_Ds_v5, solver_options.solver, save_everystep=solver_options.save_everystep, abstol=solver_options.abstol, reltol=solver_options.reltol);#
#
sol_Ds_v5(anctime)#
sol_Ds_v5(anctime) ./ sum(sol_Ds_v5(anctime))#
sol_Ds_v5(dectime)#
rbranch_top = sol_Ds_v5(dectime) ./ sum(sol_Ds_v5(dectime))#
#
uppass_likes = rbranch_top .* res.normlikes_at_each_nodeIndex_branchTop[rnode]#
asr_at_node7 = uppass_likes ./ sum(uppass_likes)#
#
# calcDs_4states2B, calcDs_4states2C   # <- closest! (and same)#
#  0.9996842305583383#
#  0.00031576944166156017#
# Diversitree: asr.marginal#
# 0.999620338 0.0003796623#
#
diversitree_bisse_Rnode7_01 = [0.999620338, 0.0003796623]#
asr_at_node7 .== diversitree_bisse_Rnode7_01#
#
@test round(asr_at_node7[1]; digits=3) .== round(diversitree_bisse_Rnode7_01[1]; digits=3)#
@test round(asr_at_node7[2]; digits=3) .== round(diversitree_bisse_Rnode7_01[2]; digits=3)
methods("find.mle")#
diversitree:::find.mle.default#
diversitree:::find.mle.dtlik#
diversitree:::find.mle.mixed#
diversitree:::do.mle.search#
# change to create some ambiguity#
#
phy2 = phy#
#
plot(phy2, label.offset=0.1)#
tiplabels(text=phy2$tip.state, tip=1:4, col="black", bg=cols[phy2$tip.state+1])#
#diversitree:::plot.history(h, phy, main="True history", cols=cols)#
#
lik2 <- make.bisse(phy2, phy2$tip.state)#
fit2 <- find.mle(func=lik2, x.init=coef(fit), method="subplex", fail.value=-1e10, lower=lower, upper=upper)#
coef(fit2 )#
#fit2 <- find.mle(lik2, pars, method="subplex", fail.value=-1e10)#
st2 <- asr.marginal(lik2, coef(fit2))#
nodelabels(thermo=t(st2), piecol=cols, cex=0.5)#
t(st2)#
#
orig_pars = pars#
names(pars) = names(coef(fit2))#
st2 <- asr.marginal(lik2, pars)#
t(st2)#
st2 <- asr.marginal(lik2, pars, root=ROOT.OBS, root.p=NULL, condition.surv=FALSE)#
t(st2)
library(BioGeoBEARS)#
library(diversitree)#
source("/GitHub/PhyBEARS.jl/Rsrc/ClaSSE_mods_v2.R")#
source("/GitHub/PhyBEARS.jl/Rsrc/ClaSSE_functions_v3.R")#
#
## Start with a simple tree evolved under a BiSSE with all rates#
## asymmetric:#
# lambda0, lambda1, mu0, mu1, q01, q10#
#
# Gives weird result -- green nodes, blue truth#
set.seed(47) # Rare to have a transition, but observed here#
pars <- c(0.222222222, 0.222222222, 0.111111111, 0.05, 0.1, 0.15)#
orig_pars = pars#
bisse_params = pars#
birthRate = pars[1]#
deathRate = pars[3]#
#
set.seed(48) # Rare to have a transition, but observed here#
phy <- trees(pars, "bisse", max.taxa=4, max.t=Inf, x0=0)[[1]]#
write.tree(phy, file="")#
#
cols = c("blue", "green3")#
lower = rep(0.0, times=length(pars))#
upper = rep(10.0, times=length(pars))#
#
## Here is the true history#
h <- history.from.sim.discrete(phy, 0:1)#
diversitree:::plot.history(h, phy, main="True history", cols=cols)#
#
lik <- make.bisse(phy, phy$tip.state)#
phy$tip.state#
#
bisse_2areas = lik#
#fit <- find.mle(lik, pars, method="subplex")#
# MLE doesn't make much sense with tiny data#
fit <- find.mle(func=lik, x.init=pars, method="subplex", fail.value=-1e10, lower=lower, upper=upper)#
coef(fit)#
st <- asr.marginal(lik, coef(fit))#
nodelabels(thermo=t(st), piecol=cols, cex=0.5)#
t(st)#
res1 = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
res2 = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0, 1)#
res3 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.25, 0.75)#
res4 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.5,0.5)#
res5 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
res6 = bisse_2areas(pars=bisse_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
#
# Res1t is BiSSE default#
# "lik" matches res1t#
res1t = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
res2t = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0, 1)#
res3t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.25, 0.75)#
res4t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.5,0.5)#
res5t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
res6t = bisse_2areas(pars=bisse_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
# get_classe_LnLs returns the total log-likelihood, and #
# the total of the branch likelihoods#
LnLs1 = get_classe_LnLs(res1)#
LnLs2 = get_classe_LnLs(res2)#
LnLs3 = get_classe_LnLs(res3)#
LnLs4 = get_classe_LnLs(res4)#
LnLs5 = get_classe_LnLs(res5)#
LnLs6 = get_classe_LnLs(res6)#
LnLs1t = get_classe_LnLs(res1t)#
LnLs2t = get_classe_LnLs(res2t)#
LnLs3t = get_classe_LnLs(res3t)#
LnLs4t = get_classe_LnLs(res4t)#
LnLs5t = get_classe_LnLs(res5t)#
LnLs6t = get_classe_LnLs(res6t)#
#
LnLst = as.data.frame(rbind(LnLs1, LnLs2, LnLs3, LnLs4, LnLs5, LnLs6, LnLs1t, LnLs2t, LnLs3t, LnLs4t, LnLs5t, LnLs6t), stringsAsFactors=FALSE)#
names(LnLst) = c("ttl_LnL", "branch_LnL")#
ObsDiff = (LnLst$ttl_LnL - LnLst$branch_LnL)#
exp_ObsDiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL))#
LnLdiff = round((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)), digits=4)#
exp_LnLdiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)))#
LnLst2 = cbind(LnLst, ObsDiff, LnLdiff, exp_ObsDiff, exp_LnLdiff)#
cft(LnLst2, numdigits_inbetween_have_fixed_digits=8)#
#
# Compare to Julia:#
# > LnLs1#
# [1] -9.574440 -6.670978#
# > LnLs1t#
# [1] -7.464283 -6.670978#
EsDs = t(attr(res1t,"intermediates")$init)#
sum(log(rowSums(EsDs[,3:4])))#
attr(res1t,"intermediates")$lq#
sum(attr(res1t,"intermediates")$lq)#
#
# This corresponds to:#
# Julia_sum_lq_nodes = sum(log.(sum.(res.likes_at_each_nodeIndex_branchTop))) + Julia_sum_lq#
# R_sum_lq_nodes = R_result_sum_log_computed_likelihoods_at_each_node_x_lambda#
sum(log(rowSums(EsDs[,3:4]))) + sum(attr(res1t,"intermediates")$lq)#
# ...but is double-counting lnLs#
########################################################
# Look at ASRs#
########################################################
tmpmat = rbind(attr(res1,"intermediates")$root.p, #
attr(res2,"intermediates")$root.p, #
attr(res3,"intermediates")$root.p, #
attr(res4,"intermediates")$root.p, #
attr(res5,"intermediates")$root.p, #
attr(res6,"intermediates")$root.p, #
attr(res1t,"intermediates")$root.p, #
attr(res2t,"intermediates")$root.p, #
attr(res3t,"intermediates")$root.p, #
attr(res4t,"intermediates")$root.p, #
attr(res5t,"intermediates")$root.p, #
attr(res6t,"intermediates")$root.p#
)#
#
tmpnames = paste0("ancstate", seq(1,ncol(tmpmat),1))#
#
tmprownames = c("res1", "res2", "res3", "res4", "res5", "res6", "res1t", "res2t", "res3t", "res4t", "res5t", "res6t")#
#
rootstates_df = adf2(tmpmat)#
names(rootstates_df) = tmpnames#
row.names(rootstates_df) = tmprownames#
rootstates_df#
#
# rootstates_df#
#       ancstate1 ancstate2#
# res1  0.4303571 0.5696429 # <- this is what asr.marginal gives#
# res2  0.5000000 0.5000000#
# res3  0.0000000 1.0000000#
# res4  0.2500000 0.7500000#
# res5  0.5000000 0.5000000#
# res6  0.5392658 0.4607342#
# res1t 0.4303571 0.5696429 # <- this is what asr.marginal gives#
# res2t 0.5000000 0.5000000#
# res3t 0.0000000 1.0000000#
# res4t 0.2500000 0.7500000#
# res5t 0.5000000 0.5000000#
# res6t 0.5392658 0.4607342#
#
# Same for everything:#
rootnode = length(phy$tip.label)+1#
EsDs = t(attr(res1,"intermediates")$init)#
EsDs[rootnode, 3:4] / sum(EsDs[rootnode, 3:4])#
########################################################
# TRYING TO FIT TO SIMULATED DATA#
# This **FAILS** with such tiny data#
########################################################
########################################################
# Look at find.mle#
########################################################
methods("find.mle")#
diversitree:::find.mle.default#
diversitree:::find.mle.dtlik#
diversitree:::find.mle.mixed#
diversitree:::do.mle.search#
# change to create some ambiguity#
#
phy2 = phy#
#
plot(phy2, label.offset=0.1)#
tiplabels(text=phy2$tip.state, tip=1:4, col="black", bg=cols[phy2$tip.state+1])#
#diversitree:::plot.history(h, phy, main="True history", cols=cols)#
#
lik2 <- make.bisse(phy2, phy2$tip.state)#
fit2 <- find.mle(func=lik2, x.init=coef(fit), method="subplex", fail.value=-1e10, lower=lower, upper=upper)#
coef(fit2 )#
#fit2 <- find.mle(lik2, pars, method="subplex", fail.value=-1e10)#
st2 <- asr.marginal(lik2, coef(fit2))#
nodelabels(thermo=t(st2), piecol=cols, cex=0.5)#
t(st2)#
#
orig_pars = pars#
names(pars) = names(coef(fit2))#
st2 <- asr.marginal(lik2, pars)#
t(st2)#
st2 <- asr.marginal(lik2, pars, root=ROOT.OBS, root.p=NULL, condition.surv=FALSE)#
t(st2)
st2 <- asr.marginal(lik2, pars, root=ROOT.OBS, condition.surv=TRUE)#
t(st2)
orig_pars = pars#
names(pars) = names(coef(fit2))#
st2 <- asr.marginal(lik2, pars)#
t(st2)
st2 <- asr.marginal(lik2, pars, root=ROOT.OBS, root.p=NULL, condition.surv=FALSE)#
t(st2)
st2 <- asr.marginal(lik2, pars, root=ROOT.OBS, condition.surv=TRUE)#
t(st2)
library(ape)
rotate
? rotate
library(ape)#
library(BioGeoBEARS)#
#
# Try some basic commands: Tree reading with APE#
newick_string = "(orang:12.0,((chimp:6.0,(human:2.5,Lucy:0.5):3.5):1.0,gorilla:7.0):5.0);"#
tr = read.tree(file="", text=newick_string)#
tr#
plot(tr)#
title("Example phylogeny: great apes")#
axisPhylo() # plots timescale#
mtext(text="Mega-annum (Ma)", side=1, line=2)#
# Try some basic commands: BioGeoBEARS#
#
# The function "prt": prints the tree to a table#
# This can be very handy for understanding R node numbers,#
# the APE phylo object tree structure, etc.#
trtable = prt(tr, printflag=FALSE, get_tipnames=TRUE, fossils_older_than=0.001)#
trtable#
# Ladderize the tree#
tr2 = ladderize(tr, right=FALSE)#
plot(tr2)#
title("Example phylogeny: great apes, ladderized")#
axisPhylo() # plots timescale#
mtext(text="Mega-annum (Ma)", side=1, line=2)#
#
trtable2 = prt(tr2, printflag=FALSE, get_tipnames=TRUE, fossils_older_than=0.001)#
trtable2#
#
# Rotate a node#
tr3 = rotate(phy=tr2, node=9)
plot_BioGeoBEARS_results
# Load the package (after installation, see above).#
library(optimx)   # optimx seems better than R's default optim()#
library(GenSA)    # GenSA seems better than optimx (but slower) on 5+ parameters, #
                  # seems to sometimes fail on simple problems (2-3 parameters)#
library(FD)       # for FD::maxent() (make sure this is up-to-date)#
library(snow)     # (if you want to use multicore functionality; some systems/R versions prefer library(parallel), try either)#
library(parallel)#
#
########################################################
# 2018-10-10 update: I have been putting the #
# updates on CRAN/GitHub#
# You should use:#
# rexpokit version 0.26.6 from CRAN#
# cladoRcpp version 0.15 from CRAN#
# BioGeoBEARS version 1.1 from GitHub, install with:#
# library(devtools)#
# devtools::install_github(repo="nmatzke/BioGeoBEARS")#
########################################################
library(rexpokit)#
library(cladoRcpp)#
library(BioGeoBEARS)#
#
########################################################
# CUT: The old instructions to source() online upgrade .R files have been deleted,#
#         all updates are now on the GitHub version of the package, version 1.1+#
########################################################
#
########################################################
# (This local-sourcing is mostly useful for Nick, while actively developing)#
# Local source()-ing method -- uses BioGeoBEARS sourceall() function #
# on a directory of .R files, so you don't have to type them out.#
# The directories here are on my machine, you would have to make a #
# directory, save the .R files there, and refer to them.#
##
# NOTE: it's best to source the "cladoRcpp.R" update first, to avoid warnings like this:#
###
## Note: possible error in 'rcpp_calc_anclikes_sp_COOweights_faster(Rcpp_leftprobs = tmpca_1, ': #
##         unused arguments (m = m, m_null_range = include_null_range, jts_matrix = jts_matrix) #
###
##
# TO USE: Delete or comment out the 'source("http://...")' commands above, and un-comment#
#              the below...#
#########################################################################
# Un-comment (and fix directory paths) to use:#
#library(BioGeoBEARS)#
#source("/drives/Dropbox/_njm/__packages/cladoRcpp_setup/cladoRcpp.R")#
#sourceall("/drives/Dropbox/_njm/__packages/BioGeoBEARS_setup/")#
#calc_loglike_sp = compiler::cmpfun(calc_loglike_sp_prebyte)    # crucial to fix bug in uppass calculations#
#calc_independent_likelihoods_on_each_branch = compiler::cmpfun(calc_independent_likelihoods_on_each_branch_prebyte)#
#########################################################################
#
########################################################
# SETUP: YOUR WORKING DIRECTORY#
########################################################
# You will need to set your working directory to match your local system#
#
# Note these very handy functions!#
# Command "setwd(x)" sets your working directory#
# Command "getwd()" gets your working directory and tells you what it is.#
# Command "list.files()" lists the files in your working directory#
# To get help on any command, use "?".  E.g., "?list.files"#
#
# Set your working directory for output files#
# default here is your home directory ("~")#
# Change this as you like#
wd = "/GitHub/PhyBEARS.jl/test/apes_SSE/"#
setwd(wd)#
#
# Double-check your working directory with getwd()#
getwd()#
#
########################################################
# SETUP: Extension data directory#
########################################################
# When R packages contain extra files, they are stored in the "extdata" directory #
# inside the installed package.#
##
# BioGeoBEARS contains various example files and scripts in its extdata directory.#
# #
# Each computer operating system might install BioGeoBEARS in a different place, #
# depending on your OS and settings. #
# #
# However, you can find the extdata directory like this:#
extdata_dir = np(system.file("extdata", package="BioGeoBEARS"))#
extdata_dir#
list.files(extdata_dir)#
#
# "system.file" looks in the directory of a specified package (in this case BioGeoBEARS)#
# The function "np" is just a shortcut for normalizePath(), which converts the #
# path to the format appropriate for your system (e.g., Mac/Linux use "/", but #
# Windows uses "\\", if memory serves).#
#
# Even when using your own data files, you should KEEP these commands in your #
# script, since the plot_BioGeoBEARS_results function needs a script from the #
# extdata directory to calculate the positions of "corners" on the plot. This cannot#
# be made into a straight up BioGeoBEARS function because it uses C routines #
# from the package APE which do not pass R CMD check for some reason.#
#
########################################################
# SETUP: YOUR TREE FILE AND GEOGRAPHY FILE#
########################################################
# Example files are given below. To run your own data,#
# make the below lines point to your own files, e.g.#
# trfn = "/mydata/frogs/frogBGB/tree.newick"#
# geogfn = "/mydata/frogs/frogBGB/geog.data"#
#
########################################################
# Phylogeny file#
# Notes: #
# 1. Must be binary/bifurcating: no polytomies#
# 2. No negative branchlengths (e.g. BEAST MCC consensus trees sometimes have negative branchlengths)#
# 3. Be careful of very short branches, as BioGeoBEARS will interpret ultrashort branches as direct ancestors#
# 4. You can use non-ultrametric trees, but BioGeoBEARS will interpret any tips significantly below the #
#    top of the tree as fossils!  This is only a good idea if you actually do have fossils in your tree,#
#    as in e.g. Wood, Matzke et al. (2013), Systematic Biology.#
# 5. The default settings of BioGeoBEARS make sense for trees where the branchlengths are in units of #
#    millions of years, and the tree is 1-1000 units tall. If you have a tree with a total height of#
#    e.g. 0.00001, you will need to adjust e.g. the max values of d and e, or (simpler) multiply all#
#    your branchlengths to get them into reasonable units.#
# 6. DON'T USE SPACES IN SPECIES NAMES, USE E.G. "_"#
########################################################
# This is the example Newick file for Hawaiian apes#
# (from Ree & Smith 2008)#
# "trfn" = "tree file name"#
trfn = "tree.newick"#
#
# Look at the raw Newick file:#
moref(trfn)#
#
# Look at your phylogeny (plots to a PDF, which avoids issues with multiple graphics in same window):#
pdffn = "tree.pdf"#
pdf(file=pdffn, width=9, height=12)#
#
tr = read.tree(trfn)#
tr#
plot(tr)#
title("Example apes phylogeny")#
axisPhylo() # plots timescale#
#
dev.off()#
cmdstr = paste0("open ", pdffn)#
system(cmdstr)#
#
########################################################
# Geography file#
# Notes:#
# 1. This is a PHYLIP-formatted file. This means that in the #
#    first line, #
#    - the 1st number equals the number of rows (species)#
#    - the 2nd number equals the number of columns (number of areas)#
#    - after a tab, put the areas in parentheses, with spaces: (A B C D)#
##
# 1.5. Example first line:#
#    10    4    (A B C D)#
# #
# 2. The second line, and subsequent lines:#
#    speciesA    0110#
#    speciesB    0111#
#    speciesC    0001#
#         ...#
# #
# 2.5a. This means a TAB between the species name and the area 0/1s#
# 2.5b. This also means NO SPACE AND NO TAB between the area 0/1s.#
# #
# 3. See example files at:#
#    http://phylo.wikidot.com/biogeobears#files#
# #
# 4. Make you understand what a PLAIN-TEXT EDITOR is:#
#    http://phylo.wikidot.com/biogeobears#texteditors#
##
# 3. The PHYLIP format is the same format used for C++ LAGRANGE geography files.#
##
# 4. All names in the geography file must match names in the phylogeny file.#
##
# 5. DON'T USE SPACES IN SPECIES NAMES, USE E.G. "_"#
##
# 6. Operational taxonomic units (OTUs) should ideally be phylogenetic lineages, #
#    i.e. genetically isolated populations.  These may or may not be identical #
#    with species.  You would NOT want to just use specimens, as each specimen #
#    automatically can only live in 1 area, which will typically favor DEC+J #
#    models.  This is fine if the species/lineages really do live in single areas,#
#    but you wouldn't want to assume this without thinking about it at least. #
#    In summary, you should collapse multiple specimens into species/lineages if #
#    data indicates they are the same genetic population.#
#######################################################
#
# This is the example geography file for Hawaiian apes#
# (from Ree & Smith 2008)#
geogfn = "geog.data"#
#
# Look at the raw geography text file:#
moref(geogfn)#
#
# Look at your geographic range data:#
tipranges = getranges_from_LagrangePHYLIP(lgdata_fn=geogfn)#
tipranges#
#
# Maximum range size observed:#
max(rowSums(dfnums_to_numeric(tipranges@df)))#
#
# Set the maximum number of areas any species may occupy; this cannot be larger #
# than the number of areas you set up, but it can be smaller.#
max_range_size = 2#
#
#####################################################
#####################################################
# KEY HINT: The number of states (= number of different possible geographic ranges)#
# depends on (a) the number of areas and (b) max_range_size.#
# If you have more than about 500-600 states, the calculations will get REALLY slow,#
# since the program has to exponentiate a matrix of e.g. 600x600.  Often the computer#
# will just sit there and crunch, and never get through the calculation of the first#
# likelihood.#
# #
# (this is also what is usually happening when LAGRANGE hangs: you have too many states!)#
##
# To check the number of states for a given number of ranges, try:#
numstates_from_numareas(numareas=4, maxareas=4, include_null_range=TRUE)#
numstates_from_numareas(numareas=4, maxareas=4, include_null_range=FALSE)#
numstates_from_numareas(numareas=4, maxareas=3, include_null_range=TRUE)#
numstates_from_numareas(numareas=4, maxareas=2, include_null_range=TRUE)#
#
# Large numbers of areas have problems:#
numstates_from_numareas(numareas=10, maxareas=10, include_null_range=TRUE)#
#
# ...unless you limit the max_range_size:#
numstates_from_numareas(numareas=10, maxareas=2, include_null_range=TRUE)#
#####################################################
#####################################################
#
########################################################
########################################################
# DEC AND DEC+J ANALYSIS#
########################################################
########################################################
# NOTE: The BioGeoBEARS "DEC" model is identical with #
# the Lagrange DEC model, and should return identical#
# ML estimates of parameters, and the same #
# log-likelihoods, for the same datasets.#
##
# Ancestral state probabilities at nodes will be slightly #
# different, since BioGeoBEARS is reporting the #
# ancestral state probabilities under the global ML#
# model, and Lagrange is reporting ancestral state#
# probabilities after re-optimizing the likelihood#
# after fixing the state at each node. These will #
# be similar, but not identical. See Matzke (2014),#
# Systematic Biology, for discussion.#
##
# Also see Matzke (2014) for presentation of the #
# DEC+J model.#
########################################################
########################################################
#
########################################################
########################################################
#
########################################################
# Run DEC#
########################################################
#
# Intitialize a default model (DEC model)#
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
#
# Give BioGeoBEARS the location of the phylogeny Newick file#
BioGeoBEARS_run_object$trfn = trfn#
#
# Give BioGeoBEARS the location of the geography text file#
BioGeoBEARS_run_object$geogfn = geogfn#
#
# Input the maximum range size#
BioGeoBEARS_run_object$max_range_size = max_range_size#
#
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)#
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.#
# (For DEC* and other "*" models, please cite: Massana, Kathryn A.; Beaulieu, #
#  Jeremy M.; Matzke, Nicholas J.; O’Meara, Brian C. (2015). Non-null Effects of #
#  the Null Range in Biogeographic Models: Exploring Parameter Estimation in the #
#  DEC Model. bioRxiv,  http://biorxiv.org/content/early/2015/09/16/026914 )#
# Also: search script on "include_null_range" for other places to change#
#
# Set up a time-stratified analysis:#
# 1. Here, un-comment ONLY the files you want to use.#
# 2. Also un-comment "BioGeoBEARS_run_object = section_the_tree(...", below.#
# 3. For example files see (a) extdata_dir, #
#  or (b) http://phylo.wikidot.com/biogeobears#files#
#  and BioGeoBEARS Google Group posts for further hints)#
##
# Uncomment files you wish to use in time-stratified analyses:#
#BioGeoBEARS_run_object$timesfn = "timeperiods.txt"#
#BioGeoBEARS_run_object$dispersal_multipliers_fn = "manual_dispersal_multipliers.txt"#
#BioGeoBEARS_run_object$areas_allowed_fn = "areas_allowed.txt"#
#BioGeoBEARS_run_object$areas_adjacency_fn = "areas_adjacency.txt"#
#BioGeoBEARS_run_object$distsfn = "distances_matrix.txt"#
# See notes on the distances model on PhyloWiki's BioGeoBEARS updates page.#
#
# Speed options and multicore processing if desired#
BioGeoBEARS_run_object$on_NaN_error = -1e50    # returns very low lnL if parameters produce NaN error (underflow check)#
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$use_optimx = TRUE    # if FALSE, use optim() instead of optimx();#
# if "GenSA", use Generalized Simulated Annealing, which seems better on high-dimensional#
# problems (5+ parameters), but seems to sometimes fail to optimize on simple problems#
BioGeoBEARS_run_object$num_cores_to_use = 1#
# (use more cores to speed it up; this requires#
# library(parallel) and/or library(snow). The package "parallel" #
# is now default on Macs in R 3.0+, but apparently still #
# has to be typed on some Windows machines. Note: apparently #
# parallel works on Mac command-line R, but not R.app.#
# BioGeoBEARS checks for this and resets to 1#
# core with R.app)#
#
# Sparse matrix exponentiation is an option for huge numbers of ranges/states (600+)#
# I have experimented with sparse matrix exponentiation in EXPOKIT/rexpokit,#
# but the results are imprecise and so I haven't explored it further.#
# In a Bayesian analysis, it might work OK, but the ML point estimates are#
# not identical.#
# Also, I have not implemented all functions to work with force_sparse=TRUE.#
# Volunteers are welcome to work on it!!#
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Divide the tree up by timeperiods/strata (uncomment this for stratified analysis)#
#BioGeoBEARS_run_object = section_the_tree(inputs=BioGeoBEARS_run_object, make_master_table=TRUE, plot_pieces=FALSE)#
# The stratified tree is described in this table:#
#BioGeoBEARS_run_object$master_table#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run#
#
# Set up DEC model#
# (nothing to do; defaults)#
#
# Look at the BioGeoBEARS_run_object; it's just a list of settings etc.#
BioGeoBEARS_run_object#
#
# This contains the model object#
BioGeoBEARS_run_object$BioGeoBEARS_model_object#
#
# This table contains the parameters of the model #
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table#
#
# Run this to check inputs. Read the error messages if you get them!#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# For a slow analysis, run once, then set runslow=FALSE to just #
# load the saved result.#
runslow = TRUE#
resfn = "apes_DEC_M0_unconstrained_v1.Rdata"#
if (runslow)#
    {#
    res = bears_optim_run(BioGeoBEARS_run_object)#
    res    #
#
    save(res, file=resfn)#
    resDEC = res#
    } else {#
    # Loads to "res"#
    load(resfn)#
    resDEC = res#
    }#
########################################################
# For comparison to PhyBEARS#
########################################################
res = resDEC#
names(res)#
#
res$relative_probs_of_each_state_at_branch_top_AT_node_UPPASS#
res$ML_marginal_prob_each_state_at_branch_top_AT_node#
res$relative_probs_of_each_state_at_branch_bottom_below_node_UPPASS#
#
mats = get_Qmat_COOmat_from_res(res)#
Qmat = mats$Qmat#
#
u0 = res$relative_probs_of_each_state_at_branch_bottom_below_node_UPPASS[6,]#
result = u0 %*% expm(Qmat)#
#
result == res$relative_probs_of_each_state_at_branch_top_AT_node_UPPASS[6,]
cft(res$ML_marginal_prob_each_state_at_branch_top_AT_node)
resDEC$output
\
cft(res$ML_marginal_prob_each_state_at_branch_top_AT_node)
#######################################################
# Run DEC+J#
########################################################
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
BioGeoBEARS_run_object$trfn = trfn#
BioGeoBEARS_run_object$geogfn = geogfn#
BioGeoBEARS_run_object$max_range_size = max_range_size#
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)#
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.#
# (For DEC* and other "*" models, please cite: Massana, Kathryn A.; Beaulieu, #
#  Jeremy M.; Matzke, Nicholas J.; O’Meara, Brian C. (2015). Non-null Effects of #
#  the Null Range in Biogeographic Models: Exploring Parameter Estimation in the #
#  DEC Model. bioRxiv,  http://biorxiv.org/content/early/2015/09/16/026914 )#
# Also: search script on "include_null_range" for other places to change#
#
# Set up a time-stratified analysis:#
#BioGeoBEARS_run_object$timesfn = "timeperiods.txt"#
#BioGeoBEARS_run_object$dispersal_multipliers_fn = "manual_dispersal_multipliers.txt"#
#BioGeoBEARS_run_object$areas_allowed_fn = "areas_allowed.txt"#
#BioGeoBEARS_run_object$areas_adjacency_fn = "areas_adjacency.txt"#
#BioGeoBEARS_run_object$distsfn = "distances_matrix.txt"#
# See notes on the distances model on PhyloWiki's BioGeoBEARS updates page.#
#
# Speed options and multicore processing if desired#
BioGeoBEARS_run_object$on_NaN_error = -1e50    # returns very low lnL if parameters produce NaN error (underflow check)#
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$use_optimx = TRUE    # if FALSE, use optim() instead of optimx();#
# if "GenSA", use Generalized Simulated Annealing, which seems better on high-dimensional#
# problems (5+ parameters), but seems to sometimes fail to optimize on simple problems#
BioGeoBEARS_run_object$num_cores_to_use = 1#
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Divide the tree up by timeperiods/strata (uncomment this for stratified analysis)#
#BioGeoBEARS_run_object = section_the_tree(inputs=BioGeoBEARS_run_object, make_master_table=TRUE, plot_pieces=FALSE)#
# The stratified tree is described in this table:#
#BioGeoBEARS_run_object$master_table#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run#
#
# Set up DEC+J model#
# Get the ML parameter values from the 2-parameter nested model#
# (this will ensure that the 3-parameter model always does at least as good)#
dstart = resDEC$outputs@params_table["d","est"]#
estart = resDEC$outputs@params_table["e","est"]#
jstart = 0.0001#
#
# Input starting values for d, e#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","init"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","est"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","init"] = estart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","est"] = estart#
#
# Add j as a free parameter#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","type"] = "free"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","init"] = jstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","est"] = jstart#
#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
resfn = "apes_DEC+J_M0_unconstrained_v1.Rdata"#
runslow = TRUE#
if (runslow)#
    {#
    #sourceall("/Dropbox/_njm/__packages/BioGeoBEARS_setup/")#
#
    res = bears_optim_run(BioGeoBEARS_run_object)#
    res    #
#
    save(res, file=resfn)#
#
    resDECj = res#
    } else {#
    # Loads to "res"#
    load(resfn)#
    resDECj = res#
    }#
########################################################
# For comparison to PhyBEARS#
########################################################
res = resDECj#
names(res)#
#
res$relative_probs_of_each_state_at_branch_top_AT_node_UPPASS#
res$ML_marginal_prob_each_state_at_branch_top_AT_node#
res$relative_probs_of_each_state_at_branch_bottom_below_node_UPPASS#
#
mats = get_Qmat_COOmat_from_res(res)#
Qmat = mats$Qmat#
#
u0 = res$relative_probs_of_each_state_at_branch_bottom_below_node_UPPASS[6,]#
result = u0 %*% expm(Qmat)#
#
result == res$relative_probs_of_each_state_at_branch_top_AT_node_UPPASS[6,]#
#
res$ML_marginal_prob_each_state_at_branch_top_AT_node
cft(res$ML_marginal_prob_each_state_at_branch_top_AT_node)
getwd()
res$output
res$total_loglikelihood
cft(res$ML_marginal_prob_each_state_at_branch_top_AT_node)
names(res)
res. relative_probs_of_each_state_at_branch_bottom_below_node_UPPASS
cft(res$relative_probs_of_each_state_at_branch_bottom_below_node_UPPASS)
cft(res$relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS)
names(res)
res$ML_marginal_prob_each_state_at_branch_top_AT_node / res$relative_probs_of_each_state_at_branch_top_AT_node_DOWNPASS
names(res)
res$ML_marginal_prob_each_state_at_branch_bottom_below_node / res$relative_probs_of_each_state_at_branch_top_AT_node_DOWNPASS
res$ML_marginal_prob_each_state_at_branch_top_AT_nod
res$output
res$ML_marginal_prob_each_state_at_branch_top_AT_nod
names(res)
res$relative_probs_of_each_state_at_branch_top_AT_node_DOWNPASS
res$ML_marginal_prob_each_state_at_branch_top_AT_nod / res$relative_probs_of_each_state_at_branch_top_AT_node_DOWNPASS
res$ML_marginal_prob_each_state_at_branch_top_AT_nod / res$relative_probs_of_each_state_at_branch_top_AT_node_DOWNPASS /0.1044777
pi()
pi
22/3
22/6
22/7
pi
pi
23/7
res$ML_marginal_prob_each_state_at_branch_top_AT_nod / res$relative_probs_of_each_state_at_branch_top_AT_node_DOWNPASS
x=res$ML_marginal_prob_each_state_at_branch_top_AT_nod / res$relative_probs_of_each_state_at_branch_top_AT_node_DOWNPASS
x/rowSums(x)
x/rowSums(x, na.rm=TRUE)
0.9565217/0.04347828
0.8749996/0.12500000
prt(tr)
plot(tr)
resDEC = structure(list(computed_likelihoods_at_each_node = c(1, 1, 1, #
1, 0.36502788215878, 0.227783575654047, 0.136167332530107), relative_probs_of_each_state_at_branch_top_AT_node_DOWNPASS = structure(c(0, #
0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 6.42693382782259e-14, 7.46190547654875e-14, #
3.13642570191625e-13, 1, 0, 1, 1, 0.757828232249181, 0.344749222130095, #
3.13642570191625e-13, 0, 0, 0, 0, 0.242171767750754, 0.65525077786983, #
0.999999999999373), dim = c(7L, 4L)), condlikes_of_each_state = structure(c(0, #
0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2.3460100439447e-14, 1.69969951064079e-14, #
4.27078721508805e-14, 1, 0, 1, 1, 0.276628434658051, 0.0785282105207443, #
4.27078721508805e-14, 0, 0, 0, 0, 0.0883994475007057, 0.149255365133286, #
0.136167332530022), dim = c(7L, 4L)), relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS = structure(c(0, #
0, 0, 0, NA, 0, 0, 5.22737626427221e-14, 0.999999999998895, 2.16444459101218e-13, #
5.04411011774348e-13, NA, 0.0576312779227834, 0.0806194459381856, #
0.999999999998895, 5.22737626427221e-14, 0.999999999997567, 0.999999999995991, #
NA, 0.342775485350427, 0.0806194459381856, 1.05227375864476e-12, #
1.05227375864476e-12, 2.21644445110031e-12, 3.5044109997644e-12, #
NA, 0.599593236726789, 0.838761108123629), dim = c(7L, 4L)), #
    relative_probs_of_each_state_at_branch_bottom_below_node_UPPASS = structure(c(0, #
    0, 0, 0, NA, 0, 0, 0.477617887308721, 0.0266167777965505, #
    0.308323346796742, 0.292600516988572, NA, 0.125000000000644, #
    0.046615618818038, 0.261191056346013, 0.946766444406928, #
    0.649573122214116, 0.616448394398207, NA, 0.749999999999466, #
    0.90676876236405, 0.261191056345266, 0.0266167777965214, #
    0.0421035309891421, 0.090951088613221, NA, 0.12499999999989, #
    0.0466156188179121), dim = c(7L, 4L)), relative_probs_of_each_state_at_branch_top_AT_node_UPPASS = structure(c(7.02704868858637e-13, #
    9.25815984473407e-13, 1.73460095194895e-12, 2.35254814927231e-12, #
    0.25, 8.32240548158005e-13, 9.06794445714384e-13, 0.431710549603533, #
    0.0240584452060588, 0.251901392427722, 0.216078384422621, #
    0.25, 0.112985338561828, 0.0421350517952136, 0.236086079443338, #
    0.855765818076806, 0.530703807120855, 0.455232186573681, #
    0.25, 0.67791203136619, 0.819612604898638, 0.332203370953129, #
    0.120175736717135, 0.217394800451423, 0.328689429003699, #
    0.25, 0.209102630071982, 0.138252343306148), dim = c(7L, #
    4L)), ML_marginal_prob_each_state_at_branch_bottom_below_node = structure(c(0, #
    0, 0, 0, NA, 0, 0, 9.55885872371469e-14, 0.999999999997088, #
    1.02736516865682e-13, 2.3942137600093e-13, NA, 0.0212357703981079, #
    0.0324086154040224, 0.999999999998852, 1.85939277741373e-12, #
    0.999999999999754, 0.999999999999244, NA, 0.757828224601766, #
    0.630413600097194, 1.05227375864171e-12, 1.05227375864171e-12, #
    1.43663791560109e-13, 5.17042461743951e-13, NA, 0.220936005000126, #
    0.337177784498784), dim = c(7L, 4L)), ML_marginal_prob_each_state_at_branch_top_AT_node = structure(c(0, #
    0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 6.42693382782259e-14, 2.27415872607374e-14, #
    9.55885855108166e-14, 1, 0, 1, 1, 0.757828232249181, 0.630413602214152, #
    1.85939274383416e-12, 0, 0, 0, 0, 0.242171767750754, 0.369586397785825, #
    0.999999999998045), dim = c(7L, 4L)), relative_probs_of_each_state_at_bottom_of_root_branch = c(0, #
    6.42693382782259e-14, 0.757828232249181, 0.242171767750754#
    ), total_loglikelihood = -4.48101163256014, inputs = list(#
        geogfn = "geog.data", trfn = "tree.newick", abbr = "default", #
        description = "defaults", BioGeoBEARS_model_object = new("BioGeoBEARS_model", #
            params_table = structure(list(type = c("free", "free", #
            "fixed", "fixed", "fixed", "fixed", "fixed", "fixed", #
            "fixed", "3-j", "ysv*2/3", "ysv*1/3", "ysv*1/3", #
            "ysv*1/3", "fixed", "mx01", "mx01", "mx01", "mx01", #
            "fixed", "fixed", "fixed", "fixed"), init = c(0.101055674351941, #
            1e-12, 0, 1, 0, 0, 1, 0, 0, 2.99999, 1.99999, 1, #
            1, 1, 1e-04, 1e-04, 1e-04, 1e-04, 1e-04, 0.5, 0.1, #
            1, 0), min = c(1e-12, 1e-12, 1e-12, 1e-12, -2.5, #
            -10, -10, -10, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, #
            1e-05, 1e-04, 1e-04, 1e-04, 1e-04, 1e-04, 1e-04, #
            0.005, 0.005, 0.005), max = c(4.999999999999, 4.999999999999, #
            4.999999999999, 0.999999999999, 2.5, 10, 10, 10, #
            2.99999, 3, 2, 1, 1, 1, 0.9999, 0.9999, 0.9999, 0.9999, #
            0.9999, 0.9999, 0.995, 0.995, 0.995), est = c(0.101055674351941, #
            1e-12, 0, 1, 0, 0, 1, 0, 0, 3, 2, 1, 1, 1, 1e-04, #
            1e-04, 1e-04, 1e-04, 1e-04, 0.5, 0.1, 1, 0), note = c("works", #
            "works", "works", "non-stratified only", "works", #
            "works", "works", "works", "works", "works", "works", #
            "works", "works", "works", "works", "works", "works", #
            "works", "works", "no", "yes", "yes", "yes"), desc = c("anagenesis: rate of 'dispersal' (range expansion)", #
            "anagenesis: rate of 'extinction' (range contraction)", #
            "anagenesis: rate of range-switching (i.e. for a standard char.)", #
            "anagenesis: exponent on branch lengths", "exponent on distance (modifies d, j, a)", #
            "exponent on environmental distance (modifies d, j, a)", #
            "exponent on manual dispersal multipliers (modifies d, j, a)", #
            "anagenesis: exponent on extinction risk with area (modifies e)", #
            "cladogenesis: relative per-event weight of jump dispersal", #
            "cladogenesis: y+s+v", "cladogenesis: y+s", "cladogenesis: relative per-event weight of sympatry (range-copying)", #
            "cladogenesis: relative per-event weight of subset speciation", #
            "cladogenesis: relative per-event weight of vicariant speciation", #
            "cladogenesis: controls range size of smaller daughter", #
            "cladogenesis: controls range size of smaller daughter", #
            "cladogenesis: controls range size of smaller daughter", #
            "cladogenesis: controls range size of smaller daughter", #
            "cladogenesis: controls range size of smaller daughter", #
            "root: controls range size probabilities of root", #
            "mean frequency of truly sampling OTU of interest", #
            "detection probability per true sample of OTU of interest", #
            "false detection of OTU probability per true taphonomic control sample"#
            )), row.names = c("d", "e", "a", "b", "x", "n", "w", #
            "u", "j", "ysv", "ys", "y", "s", "v", "mx01", "mx01j", #
            "mx01y", "mx01s", "mx01v", "mx01r", "mf", "dp", "fdp"#
            ), class = "data.frame")), timesfn = NA, distsfn = NA, #
        dispersal_multipliers_fn = NA, area_of_areas_fn = NA, #
        areas_allowed_fn = NA, areas_adjacency_fn = NA, detects_fn = NA, #
        controls_fn = NA, max_range_size = 2, force_sparse = FALSE, #
        use_detection_model = FALSE, print_optim = TRUE, printlevel = 0, #
        on_NaN_error = -1e+50, wd = "/GitHub/PhyBEARS.jl/test/apes_SSE", #
        num_cores_to_use = 1, cluster_already_open = FALSE, use_optimx = TRUE, #
        rescale_params = FALSE, return_condlikes_table = TRUE, #
        calc_TTL_loglike_from_condlikes_table = TRUE, calc_ancprobs = TRUE, #
        speedup = TRUE, include_null_range = TRUE, useAmbiguities = FALSE, #
        min_branchlength = 1e-06, allow_null_tips = FALSE, all_geog_states_list_usually_inferred_from_areas_maxareas = list(#
            NA, 0L, 1L, 0:1)), outputs = new("BioGeoBEARS_model", #
        params_table = structure(list(type = c("free", "free", #
        "fixed", "fixed", "fixed", "fixed", "fixed", "fixed", #
        "fixed", "3-j", "ysv*2/3", "ysv*1/3", "ysv*1/3", "ysv*1/3", #
        "fixed", "mx01", "mx01", "mx01", "mx01", "fixed", "fixed", #
        "fixed", "fixed"), init = c(0.101055674351941, 1e-12, #
        0, 1, 0, 0, 1, 0, 0, 2.99999, 1.99999, 1, 1, 1, 1e-04, #
        1e-04, 1e-04, 1e-04, 1e-04, 0.5, 0.1, 1, 0), min = c(1e-12, #
        1e-12, 1e-12, 1e-12, -2.5, -10, -10, -10, 1e-05, 1e-05, #
        1e-05, 1e-05, 1e-05, 1e-05, 1e-04, 1e-04, 1e-04, 1e-04, #
        1e-04, 1e-04, 0.005, 0.005, 0.005), max = c(4.999999999999, #
        4.999999999999, 4.999999999999, 0.999999999999, 2.5, #
        10, 10, 10, 2.99999, 3, 2, 1, 1, 1, 0.9999, 0.9999, 0.9999, #
        0.9999, 0.9999, 0.9999, 0.995, 0.995, 0.995), est = c(0.101055674351941, #
        1e-12, 0, 1, 0, 0, 1, 0, 0, 3, 2, 1, 1, 1, 1e-04, 1e-04, #
        1e-04, 1e-04, 1e-04, 0.5, 0.1, 1, 0), note = c("works", #
        "works", "works", "non-stratified only", "works", "works", #
        "works", "works", "works", "works", "works", "works", #
        "works", "works", "works", "works", "works", "works", #
        "works", "no", "yes", "yes", "yes"), desc = c("anagenesis: rate of 'dispersal' (range expansion)", #
        "anagenesis: rate of 'extinction' (range contraction)", #
        "anagenesis: rate of range-switching (i.e. for a standard char.)", #
        "anagenesis: exponent on branch lengths", "exponent on distance (modifies d, j, a)", #
        "exponent on environmental distance (modifies d, j, a)", #
        "exponent on manual dispersal multipliers (modifies d, j, a)", #
        "anagenesis: exponent on extinction risk with area (modifies e)", #
        "cladogenesis: relative per-event weight of jump dispersal", #
        "cladogenesis: y+s+v", "cladogenesis: y+s", "cladogenesis: relative per-event weight of sympatry (range-copying)", #
        "cladogenesis: relative per-event weight of subset speciation", #
        "cladogenesis: relative per-event weight of vicariant speciation", #
        "cladogenesis: controls range size of smaller daughter", #
        "cladogenesis: controls range size of smaller daughter", #
        "cladogenesis: controls range size of smaller daughter", #
        "cladogenesis: controls range size of smaller daughter", #
        "cladogenesis: controls range size of smaller daughter", #
        "root: controls range size probabilities of root", "mean frequency of truly sampling OTU of interest", #
        "detection probability per true sample of OTU of interest", #
        "false detection of OTU probability per true taphonomic control sample"#
        )), row.names = c("d", "e", "a", "b", "x", "n", "w", #
        "u", "j", "ysv", "ys", "y", "s", "v", "mx01", "mx01j", #
        "mx01y", "mx01s", "mx01v", "mx01r", "mf", "dp", "fdp"#
        ), class = "data.frame")), optim_result = structure(list(#
        p1 = 0.101055674351941, p2 = 1e-12, value = -4.48101163256014, #
        fevals = 39, gevals = NA_real_, niter = NA_real_, convcode = 0, #
        kkt1 = FALSE, kkt2 = TRUE, xtime = 0.354), row.names = "bobyqa", class = c("optimx", #
    "data.frame"), details = structure(list("bobyqa", c(0.0313402484276759, #
    0), structure(c(-65.7496196774338, 0, 0, 0), dim = c(2L, #
    2L)), c(-65.7496196774338, 0), "none"), dim = c(1L, 5L), dimnames = list(#
        "bobyqa", c("method", "ngatend", "nhatend", "hev", "message"#
        ))), maximize = TRUE, npar = 2L, follow.on = FALSE)), class = "calc_loglike_sp_results")#
#
trfn = "/GitHub/PhyBEARS.jl/test/apes_SSE/tree.newick"#
moref(trfn)#
#
tree_string = "(((chimp:1,human:1):1,gorilla:2):1,orang:3);"#
tr = read.tree(file="", text=tree_string)#
trtable = prt(tr, printflag=FALSE)#
#
numstates = 4#
tmpres = get_Qmat_COOmat_from_res(resDEC, numstates=numstates, include_null_range=TRUE, max_range_size=NULL, timeperiod_i=1)#
#
probs_ancstate = rep(0.25, numstates)#
COO_weights_columnar = tmpres$COO_weights_columnar#
include_null_range = TRUE#
left_branch_downpass_likes = rep(1, numstates)#
right_branch_downpass_likes = rep(1, numstates)#
Rsp_rowsums = tmpres$Rsp_rowsums#
clado_table = cbind(tmpres$COO_weights_columnar[[1]]+1, tmpres$COO_weights_columnar[[2]]+1, tmpres$COO_weights_columnar[[3]]+1, tmpres$COO_weights_columnar[[4]])#
#
probs = rep(0, nrow(clado_table))#
for (i in 1:length(probs))#
	probs[i] = clado_table[i,4] / Rsp_rowsums[clado_table[i,1]]#
end#
clado_table = cbind(clado_table, probs)#
clado_table_df = adf2(clado_table)#
names(clado_table_df) = c("i", "j", "k", "wt", "prob")#
clado_table_df#
#
# equal ancstate probs#
calc_uppass_probs_new2(probs_ancstate, COO_weights_columnar, numstates, include_null_range = include_null_range, #
    left_branch_downpass_likes = NULL, right_branch_downpass_likes = NULL, #
    Rsp_rowsums = NULL)
probs_ancstate
include_null_range
plus_val = 1 + include_null_range#
clado_table = cbind(tmpres$COO_weights_columnar[[1]]+plus_val, tmpres$COO_weights_columnar[[2]]+plus_val, tmpres$COO_weights_columnar[[3]]+plus_val, tmpres$COO_weights_columnar[[4]])
probs = rep(0, nrow(clado_table))#
for (i in 1:length(probs))#
	probs[i] = clado_table[i,4] / Rsp_rowsums[clado_table[i,1]]#
end#
clado_table = cbind(clado_table, probs)#
clado_table_df = adf2(clado_table)#
names(clado_table_df) = c("i", "j", "k", "wt", "prob")#
clado_table_df
clado_table = cbind(tmpres$COO_weights_columnar[[1]]+1, tmpres$COO_weights_columnar[[2]]+1, tmpres$COO_weights_columnar[[3]]+1, tmpres$COO_weights_columnar[[4]])#
#
probs = rep(0, nrow(clado_table))#
for (i in 1:length(probs))#
	probs[i] = clado_table[i,4] / Rsp_rowsums[clado_table[i,1]]#
end#
clado_table = cbind(clado_table, probs)#
clado_table_df = adf2(clado_table)#
names(clado_table_df) = c("i", "j", "k", "wt", "prob")#
clado_table_df
clado_table_df$i = clado_table_df$i + include_null_range # match to Julia#
clado_table_df$j = clado_table_df$j + include_null_range # match to Julia#
clado_table_df$k = clado_table_df$k + include_null_range # match to Julia#
clado_table_df
# Load the package (after installation, see above).#
library(optimx)   # optimx seems better than R's default optim()#
library(GenSA)    # GenSA seems better than optimx (but slower) on 5+ parameters, #
                  # seems to sometimes fail on simple problems (2-3 parameters)#
library(FD)       # for FD::maxent() (make sure this is up-to-date)#
library(snow)     # (if you want to use multicore functionality; some systems/R versions prefer library(parallel), try either)#
library(parallel)#
#
########################################################
# 2018-10-10 update: I have been putting the #
# updates on CRAN/GitHub#
# You should use:#
# rexpokit version 0.26.6 from CRAN#
# cladoRcpp version 0.15 from CRAN#
# BioGeoBEARS version 1.1 from GitHub, install with:#
# library(devtools)#
# devtools::install_github(repo="nmatzke/BioGeoBEARS")#
########################################################
library(rexpokit)#
library(cladoRcpp)#
library(BioGeoBEARS)#
#
########################################################
# CUT: The old instructions to source() online upgrade .R files have been deleted,#
#         all updates are now on the GitHub version of the package, version 1.1+#
########################################################
#
########################################################
# (This local-sourcing is mostly useful for Nick, while actively developing)#
# Local source()-ing method -- uses BioGeoBEARS sourceall() function #
# on a directory of .R files, so you don't have to type them out.#
# The directories here are on my machine, you would have to make a #
# directory, save the .R files there, and refer to them.#
##
# NOTE: it's best to source the "cladoRcpp.R" update first, to avoid warnings like this:#
###
## Note: possible error in 'rcpp_calc_anclikes_sp_COOweights_faster(Rcpp_leftprobs = tmpca_1, ': #
##         unused arguments (m = m, m_null_range = include_null_range, jts_matrix = jts_matrix) #
###
##
# TO USE: Delete or comment out the 'source("http://...")' commands above, and un-comment#
#              the below...#
#########################################################################
# Un-comment (and fix directory paths) to use:#
#library(BioGeoBEARS)#
#source("/drives/Dropbox/_njm/__packages/cladoRcpp_setup/cladoRcpp.R")#
#sourceall("/drives/Dropbox/_njm/__packages/BioGeoBEARS_setup/")#
#calc_loglike_sp = compiler::cmpfun(calc_loglike_sp_prebyte)    # crucial to fix bug in uppass calculations#
#calc_independent_likelihoods_on_each_branch = compiler::cmpfun(calc_independent_likelihoods_on_each_branch_prebyte)#
#########################################################################
#
########################################################
# SETUP: YOUR WORKING DIRECTORY#
########################################################
# You will need to set your working directory to match your local system#
#
# Note these very handy functions!#
# Command "setwd(x)" sets your working directory#
# Command "getwd()" gets your working directory and tells you what it is.#
# Command "list.files()" lists the files in your working directory#
# To get help on any command, use "?".  E.g., "?list.files"#
#
# Set your working directory for output files#
# default here is your home directory ("~")#
# Change this as you like#
wd = "/GitHub/PhyBEARS.jl/test/apes_SSE/"#
setwd(wd)#
#
# Double-check your working directory with getwd()#
getwd()#
#
########################################################
# SETUP: Extension data directory#
########################################################
# When R packages contain extra files, they are stored in the "extdata" directory #
# inside the installed package.#
##
# BioGeoBEARS contains various example files and scripts in its extdata directory.#
# #
# Each computer operating system might install BioGeoBEARS in a different place, #
# depending on your OS and settings. #
# #
# However, you can find the extdata directory like this:#
extdata_dir = np(system.file("extdata", package="BioGeoBEARS"))#
extdata_dir#
list.files(extdata_dir)#
#
# "system.file" looks in the directory of a specified package (in this case BioGeoBEARS)#
# The function "np" is just a shortcut for normalizePath(), which converts the #
# path to the format appropriate for your system (e.g., Mac/Linux use "/", but #
# Windows uses "\\", if memory serves).#
#
# Even when using your own data files, you should KEEP these commands in your #
# script, since the plot_BioGeoBEARS_results function needs a script from the #
# extdata directory to calculate the positions of "corners" on the plot. This cannot#
# be made into a straight up BioGeoBEARS function because it uses C routines #
# from the package APE which do not pass R CMD check for some reason.#
#
########################################################
# SETUP: YOUR TREE FILE AND GEOGRAPHY FILE#
########################################################
# Example files are given below. To run your own data,#
# make the below lines point to your own files, e.g.#
# trfn = "/mydata/frogs/frogBGB/tree.newick"#
# geogfn = "/mydata/frogs/frogBGB/geog.data"#
#
########################################################
# Phylogeny file#
# Notes: #
# 1. Must be binary/bifurcating: no polytomies#
# 2. No negative branchlengths (e.g. BEAST MCC consensus trees sometimes have negative branchlengths)#
# 3. Be careful of very short branches, as BioGeoBEARS will interpret ultrashort branches as direct ancestors#
# 4. You can use non-ultrametric trees, but BioGeoBEARS will interpret any tips significantly below the #
#    top of the tree as fossils!  This is only a good idea if you actually do have fossils in your tree,#
#    as in e.g. Wood, Matzke et al. (2013), Systematic Biology.#
# 5. The default settings of BioGeoBEARS make sense for trees where the branchlengths are in units of #
#    millions of years, and the tree is 1-1000 units tall. If you have a tree with a total height of#
#    e.g. 0.00001, you will need to adjust e.g. the max values of d and e, or (simpler) multiply all#
#    your branchlengths to get them into reasonable units.#
# 6. DON'T USE SPACES IN SPECIES NAMES, USE E.G. "_"#
########################################################
# This is the example Newick file for Hawaiian apes#
# (from Ree & Smith 2008)#
# "trfn" = "tree file name"#
trfn = "tree.newick"#
#
# Look at the raw Newick file:#
moref(trfn)#
#
# Look at your phylogeny (plots to a PDF, which avoids issues with multiple graphics in same window):#
pdffn = "tree.pdf"#
pdf(file=pdffn, width=9, height=12)#
#
tr = read.tree(trfn)#
tr#
plot(tr)#
title("Example apes phylogeny")#
axisPhylo() # plots timescale#
#
dev.off()#
cmdstr = paste0("open ", pdffn)#
system(cmdstr)#
#
########################################################
# Geography file#
# Notes:#
# 1. This is a PHYLIP-formatted file. This means that in the #
#    first line, #
#    - the 1st number equals the number of rows (species)#
#    - the 2nd number equals the number of columns (number of areas)#
#    - after a tab, put the areas in parentheses, with spaces: (A B C D)#
##
# 1.5. Example first line:#
#    10    4    (A B C D)#
# #
# 2. The second line, and subsequent lines:#
#    speciesA    0110#
#    speciesB    0111#
#    speciesC    0001#
#         ...#
# #
# 2.5a. This means a TAB between the species name and the area 0/1s#
# 2.5b. This also means NO SPACE AND NO TAB between the area 0/1s.#
# #
# 3. See example files at:#
#    http://phylo.wikidot.com/biogeobears#files#
# #
# 4. Make you understand what a PLAIN-TEXT EDITOR is:#
#    http://phylo.wikidot.com/biogeobears#texteditors#
##
# 3. The PHYLIP format is the same format used for C++ LAGRANGE geography files.#
##
# 4. All names in the geography file must match names in the phylogeny file.#
##
# 5. DON'T USE SPACES IN SPECIES NAMES, USE E.G. "_"#
##
# 6. Operational taxonomic units (OTUs) should ideally be phylogenetic lineages, #
#    i.e. genetically isolated populations.  These may or may not be identical #
#    with species.  You would NOT want to just use specimens, as each specimen #
#    automatically can only live in 1 area, which will typically favor DEC+J #
#    models.  This is fine if the species/lineages really do live in single areas,#
#    but you wouldn't want to assume this without thinking about it at least. #
#    In summary, you should collapse multiple specimens into species/lineages if #
#    data indicates they are the same genetic population.#
#######################################################
#
# This is the example geography file for Hawaiian apes#
# (from Ree & Smith 2008)#
geogfn = "geog.data"#
#
# Look at the raw geography text file:#
moref(geogfn)#
#
# Look at your geographic range data:#
tipranges = getranges_from_LagrangePHYLIP(lgdata_fn=geogfn)#
tipranges#
#
# Maximum range size observed:#
max(rowSums(dfnums_to_numeric(tipranges@df)))#
#
# Set the maximum number of areas any species may occupy; this cannot be larger #
# than the number of areas you set up, but it can be smaller.#
max_range_size = 2#
#
#####################################################
#####################################################
# KEY HINT: The number of states (= number of different possible geographic ranges)#
# depends on (a) the number of areas and (b) max_range_size.#
# If you have more than about 500-600 states, the calculations will get REALLY slow,#
# since the program has to exponentiate a matrix of e.g. 600x600.  Often the computer#
# will just sit there and crunch, and never get through the calculation of the first#
# likelihood.#
# #
# (this is also what is usually happening when LAGRANGE hangs: you have too many states!)#
##
# To check the number of states for a given number of ranges, try:#
numstates_from_numareas(numareas=4, maxareas=4, include_null_range=TRUE)#
numstates_from_numareas(numareas=4, maxareas=4, include_null_range=FALSE)#
numstates_from_numareas(numareas=4, maxareas=3, include_null_range=TRUE)#
numstates_from_numareas(numareas=4, maxareas=2, include_null_range=TRUE)#
#
# Large numbers of areas have problems:#
numstates_from_numareas(numareas=10, maxareas=10, include_null_range=TRUE)#
#
# ...unless you limit the max_range_size:#
numstates_from_numareas(numareas=10, maxareas=2, include_null_range=TRUE)#
#####################################################
#####################################################
#
########################################################
########################################################
# DEC AND DEC+J ANALYSIS#
########################################################
########################################################
# NOTE: The BioGeoBEARS "DEC" model is identical with #
# the Lagrange DEC model, and should return identical#
# ML estimates of parameters, and the same #
# log-likelihoods, for the same datasets.#
##
# Ancestral state probabilities at nodes will be slightly #
# different, since BioGeoBEARS is reporting the #
# ancestral state probabilities under the global ML#
# model, and Lagrange is reporting ancestral state#
# probabilities after re-optimizing the likelihood#
# after fixing the state at each node. These will #
# be similar, but not identical. See Matzke (2014),#
# Systematic Biology, for discussion.#
##
# Also see Matzke (2014) for presentation of the #
# DEC+J model.#
########################################################
########################################################
#
########################################################
########################################################
#
########################################################
# Run DEC#
########################################################
#
# Intitialize a default model (DEC model)#
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
#
# Give BioGeoBEARS the location of the phylogeny Newick file#
BioGeoBEARS_run_object$trfn = trfn#
#
# Give BioGeoBEARS the location of the geography text file#
BioGeoBEARS_run_object$geogfn = geogfn#
#
# Input the maximum range size#
BioGeoBEARS_run_object$max_range_size = max_range_size#
#
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)#
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.#
# (For DEC* and other "*" models, please cite: Massana, Kathryn A.; Beaulieu, #
#  Jeremy M.; Matzke, Nicholas J.; O’Meara, Brian C. (2015). Non-null Effects of #
#  the Null Range in Biogeographic Models: Exploring Parameter Estimation in the #
#  DEC Model. bioRxiv,  http://biorxiv.org/content/early/2015/09/16/026914 )#
# Also: search script on "include_null_range" for other places to change#
#
# Set up a time-stratified analysis:#
# 1. Here, un-comment ONLY the files you want to use.#
# 2. Also un-comment "BioGeoBEARS_run_object = section_the_tree(...", below.#
# 3. For example files see (a) extdata_dir, #
#  or (b) http://phylo.wikidot.com/biogeobears#files#
#  and BioGeoBEARS Google Group posts for further hints)#
##
# Uncomment files you wish to use in time-stratified analyses:#
#BioGeoBEARS_run_object$timesfn = "timeperiods.txt"#
#BioGeoBEARS_run_object$dispersal_multipliers_fn = "manual_dispersal_multipliers.txt"#
#BioGeoBEARS_run_object$areas_allowed_fn = "areas_allowed.txt"#
#BioGeoBEARS_run_object$areas_adjacency_fn = "areas_adjacency.txt"#
#BioGeoBEARS_run_object$distsfn = "distances_matrix.txt"#
# See notes on the distances model on PhyloWiki's BioGeoBEARS updates page.#
#
# Speed options and multicore processing if desired#
BioGeoBEARS_run_object$on_NaN_error = -1e50    # returns very low lnL if parameters produce NaN error (underflow check)#
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$use_optimx = TRUE    # if FALSE, use optim() instead of optimx();#
# if "GenSA", use Generalized Simulated Annealing, which seems better on high-dimensional#
# problems (5+ parameters), but seems to sometimes fail to optimize on simple problems#
BioGeoBEARS_run_object$num_cores_to_use = 1#
# (use more cores to speed it up; this requires#
# library(parallel) and/or library(snow). The package "parallel" #
# is now default on Macs in R 3.0+, but apparently still #
# has to be typed on some Windows machines. Note: apparently #
# parallel works on Mac command-line R, but not R.app.#
# BioGeoBEARS checks for this and resets to 1#
# core with R.app)#
#
# Sparse matrix exponentiation is an option for huge numbers of ranges/states (600+)#
# I have experimented with sparse matrix exponentiation in EXPOKIT/rexpokit,#
# but the results are imprecise and so I haven't explored it further.#
# In a Bayesian analysis, it might work OK, but the ML point estimates are#
# not identical.#
# Also, I have not implemented all functions to work with force_sparse=TRUE.#
# Volunteers are welcome to work on it!!#
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Divide the tree up by timeperiods/strata (uncomment this for stratified analysis)#
#BioGeoBEARS_run_object = section_the_tree(inputs=BioGeoBEARS_run_object, make_master_table=TRUE, plot_pieces=FALSE)#
# The stratified tree is described in this table:#
#BioGeoBEARS_run_object$master_table#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run#
#
# Set up DEC model#
# (nothing to do; defaults)#
#
# Look at the BioGeoBEARS_run_object; it's just a list of settings etc.#
BioGeoBEARS_run_object#
#
# This contains the model object#
BioGeoBEARS_run_object$BioGeoBEARS_model_object#
#
# This table contains the parameters of the model #
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table#
#
# Run this to check inputs. Read the error messages if you get them!#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# For a slow analysis, run once, then set runslow=FALSE to just #
# load the saved result.#
runslow = TRUE#
resfn = "apes_DEC_M0_unconstrained_v1.Rdata"#
if (runslow)#
    {#
    res = bears_optim_run(BioGeoBEARS_run_object)#
    res    #
#
    save(res, file=resfn)#
    resDEC = res#
    } else {#
    # Loads to "res"#
    load(resfn)#
    resDEC = res#
    }#
########################################################
# For comparison to PhyBEARS#
########################################################
res = resDEC#
names(res)#
#
res$relative_probs_of_each_state_at_branch_top_AT_node_UPPASS#
res$ML_marginal_prob_each_state_at_branch_top_AT_node#
res$relative_probs_of_each_state_at_branch_bottom_below_node_UPPASS#
#
mats = get_Qmat_COOmat_from_res(res)#
Qmat = mats$Qmat#
#
u0 = res$relative_probs_of_each_state_at_branch_bottom_below_node_UPPASS[6,]#
result = u0 %*% expm(Qmat)#
#
result == res$relative_probs_of_each_state_at_branch_top_AT_node_UPPASS[6,]#
#
res$ML_marginal_prob_each_state_at_branch_top_AT_node#
#
cft(res$ML_marginal_prob_each_state_at_branch_top_AT_node)#
########################################################
# Run DEC+J#
########################################################
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
BioGeoBEARS_run_object$trfn = trfn#
BioGeoBEARS_run_object$geogfn = geogfn#
BioGeoBEARS_run_object$max_range_size = max_range_size#
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)#
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.#
# (For DEC* and other "*" models, please cite: Massana, Kathryn A.; Beaulieu, #
#  Jeremy M.; Matzke, Nicholas J.; O’Meara, Brian C. (2015). Non-null Effects of #
#  the Null Range in Biogeographic Models: Exploring Parameter Estimation in the #
#  DEC Model. bioRxiv,  http://biorxiv.org/content/early/2015/09/16/026914 )#
# Also: search script on "include_null_range" for other places to change#
#
# Set up a time-stratified analysis:#
#BioGeoBEARS_run_object$timesfn = "timeperiods.txt"#
#BioGeoBEARS_run_object$dispersal_multipliers_fn = "manual_dispersal_multipliers.txt"#
#BioGeoBEARS_run_object$areas_allowed_fn = "areas_allowed.txt"#
#BioGeoBEARS_run_object$areas_adjacency_fn = "areas_adjacency.txt"#
#BioGeoBEARS_run_object$distsfn = "distances_matrix.txt"#
# See notes on the distances model on PhyloWiki's BioGeoBEARS updates page.#
#
# Speed options and multicore processing if desired#
BioGeoBEARS_run_object$on_NaN_error = -1e50    # returns very low lnL if parameters produce NaN error (underflow check)#
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$use_optimx = TRUE    # if FALSE, use optim() instead of optimx();#
# if "GenSA", use Generalized Simulated Annealing, which seems better on high-dimensional#
# problems (5+ parameters), but seems to sometimes fail to optimize on simple problems#
BioGeoBEARS_run_object$num_cores_to_use = 1#
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Divide the tree up by timeperiods/strata (uncomment this for stratified analysis)#
#BioGeoBEARS_run_object = section_the_tree(inputs=BioGeoBEARS_run_object, make_master_table=TRUE, plot_pieces=FALSE)#
# The stratified tree is described in this table:#
#BioGeoBEARS_run_object$master_table#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run#
#
# Set up DEC+J model#
# Get the ML parameter values from the 2-parameter nested model#
# (this will ensure that the 3-parameter model always does at least as good)#
dstart = resDEC$outputs@params_table["d","est"]#
estart = resDEC$outputs@params_table["e","est"]#
jstart = 0.0001#
#
# Input starting values for d, e#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","init"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","est"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","init"] = estart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","est"] = estart#
#
# Add j as a free parameter#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","type"] = "free"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","init"] = jstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","est"] = jstart#
#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
resfn = "apes_DEC+J_M0_unconstrained_v1.Rdata"#
runslow = TRUE#
if (runslow)#
    {#
    #sourceall("/Dropbox/_njm/__packages/BioGeoBEARS_setup/")#
#
    res = bears_optim_run(BioGeoBEARS_run_object)#
    res    #
#
    save(res, file=resfn)#
#
    resDECj = res#
    } else {#
    # Loads to "res"#
    load(resfn)#
    resDECj = res#
    }
dput(res)
resDECj = structure(list(computed_likelihoods_at_each_node = c(1, 1, 1, #
1, 0.507575467228889, 0.523809470236301, 1.16666613519192), relative_probs_of_each_state_at_branch_top_AT_node_DOWNPASS = structure(c(0, #
0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0.402984832755885, 0.409090670518368, #
0.428571393903405, 1, 0, 1, 1, 0.402985273118811, 0.409091125681156, #
0.428571393903405, 0, 0, 0, 0, 0.194029894125303, 0.181818203800476, #
0.14285721219319), dim = c(7L, 4L)), condlikes_of_each_state = structure(c(0, #
0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0.204545214772224, 0.21428556740284, #
0.499999731779099, 1, 0, 1, 1, 0.204545438289642, 0.214285805821419, #
0.499999731779099, 0, 0, 0, 0, 0.0984848141670227, 0.095238097012043, #
0.16666667163372), dim = c(7L, 4L)), relative_probs_of_each_state_at_branch_bottom_below_node_DOWNPASS = structure(c(0, #
0, 0, 0, NA, 0, 0, 4.99999996003697e-25, 0.999999999999, 1.99999998401279e-24, #
4.49999996402427e-24, NA, 0.409090670518066, 0.428571393903058, #
0.999999999999, 4.99999996003697e-25, 0.999999999998, 0.999999999997, #
NA, 0.409091125680855, 0.428571393903058, 9.99999996003197e-13, #
9.99999996003197e-13, 1.99999999200439e-12, 2.99999998800359e-12, #
NA, 0.181818203801079, 0.142857212193884), dim = c(7L, 4L)), #
    relative_probs_of_each_state_at_branch_bottom_below_node_UPPASS = structure(c(0, #
    0, 0, 0, NA, 0, 0, 1.08061343334044e-06, 0.985294102116435, #
    0.478571679250394, 0.440789704720395, NA, 0.874999582489757, #
    0.956521717030822, 0.985293037394407, 1.47065931591761e-14, #
    0.478571178238921, 0.440789243569054, NA, 4.17510337035861e-07, #
    5.72006626818978e-13, 0.0147058819921599, 0.0147058978835505, #
    0.042857142510685, 0.11842105171055, NA, 0.124999999999906, #
    0.0434782829686063), dim = c(7L, 4L)), relative_probs_of_each_state_at_branch_top_AT_node_UPPASS = structure(c(9.85294114069829e-13, #
    9.85294098178438e-13, 1.91428570732586e-12, 2.64473683429363e-12, #
    0.25, 8.74999996503016e-13, 9.56521713208408e-13, 1.08061344804416e-06, #
    0.985294102114479, 0.478571679248565, 0.440789704718106, #
    0.25, 0.874999582488132, 0.956521717028952, 0.985293037392451, #
    2.94124909843985e-14, 0.478571178237093, 0.440789243566765, #
    0.25, 4.17510462035026e-07, 6.154849096131e-13, 0.0147058819931158, #
    0.0147058978845063, 0.0428571425124279, 0.118421051712485, #
    0.25, 0.125000000000531, 0.0434782829694758), dim = c(7L, #
    4L)), ML_marginal_prob_each_state_at_branch_bottom_below_node = structure(c(0, #
    0, 0, 0, NA, 0, 0, 5.48371592862491e-31, 0.999999999999985, #
    2.0000020777968e-24, 4.50000467190996e-24, NA, 0.940298019269117, #
    0.985074610727033, 0.999999999999985, 7.46304733279965e-39, #
    0.999999999999821, 0.999999999999194, NA, 4.4866830521154e-07, #
    5.89081455459344e-13, 1.4925389072359e-14, 1.4925389072359e-14, #
    1.79104569134887e-13, 8.05970560522871e-13, NA, 0.059701532062578, #
    0.0149253892723778), dim = c(7L, 4L)), ML_marginal_prob_each_state_at_branch_top_AT_node = structure(c(0, #
    0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0.402984832755885, 0.940298019268833, #
    0.98507461072675, 1, 0, 1, 1, 0.402985273118811, 4.48668439539842e-07, #
    6.33857597743347e-13, 0, 0, 0, 0, 0.194029894125303, 0.0597015320627273, #
    0.0149253892726166), dim = c(7L, 4L)), relative_probs_of_each_state_at_bottom_of_root_branch = c(0, #
    0.402984832755885, 0.402985273118811, 0.194029894125303), #
    total_loglikelihood = -1.17058691814607, inputs = list(geogfn = "geog.data", #
        trfn = "tree.newick", abbr = "default", description = "defaults", #
        BioGeoBEARS_model_object = new("BioGeoBEARS_model", params_table = structure(list(#
            type = c("free", "free", "fixed", "fixed", "fixed", #
            "fixed", "fixed", "fixed", "free", "3-j", "ysv*2/3", #
            "ysv*1/3", "ysv*1/3", "ysv*1/3", "fixed", "mx01", #
            "mx01", "mx01", "mx01", "fixed", "fixed", "fixed", #
            "fixed"), init = c(1e-12, 1e-12, 0, 1, 0, 0, 1, 0, #
            2.99998997978887, 2.99999, 1.99999, 1, 1, 1, 1e-04, #
            1e-04, 1e-04, 1e-04, 1e-04, 0.5, 0.1, 1, 0), min = c(1e-12, #
            1e-12, 1e-12, 1e-12, -2.5, -10, -10, -10, 1e-05, #
            1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-04, 1e-04, #
            1e-04, 1e-04, 1e-04, 1e-04, 0.005, 0.005, 0.005), #
            max = c(4.999999999999, 4.999999999999, 4.999999999999, #
            0.999999999999, 2.5, 10, 10, 10, 2.99999, 3, 2, 1, #
            1, 1, 0.9999, 0.9999, 0.9999, 0.9999, 0.9999, 0.9999, #
            0.995, 0.995, 0.995), est = c(1e-12, 1e-12, 0, 1, #
            0, 0, 1, 0, 2.99998997978887, 1.00202111301684e-05, #
            6.6801407534456e-06, 3.3400703767228e-06, 3.3400703767228e-06, #
            3.3400703767228e-06, 1e-04, 1e-04, 1e-04, 1e-04, #
            1e-04, 0.5, 0.1, 1, 0), note = c("works", "works", #
            "works", "non-stratified only", "works", "works", #
            "works", "works", "works", "works", "works", "works", #
            "works", "works", "works", "works", "works", "works", #
            "works", "no", "yes", "yes", "yes"), desc = c("anagenesis: rate of 'dispersal' (range expansion)", #
            "anagenesis: rate of 'extinction' (range contraction)", #
            "anagenesis: rate of range-switching (i.e. for a standard char.)", #
            "anagenesis: exponent on branch lengths", "exponent on distance (modifies d, j, a)", #
            "exponent on environmental distance (modifies d, j, a)", #
            "exponent on manual dispersal multipliers (modifies d, j, a)", #
            "anagenesis: exponent on extinction risk with area (modifies e)", #
            "cladogenesis: relative per-event weight of jump dispersal", #
            "cladogenesis: y+s+v", "cladogenesis: y+s", "cladogenesis: relative per-event weight of sympatry (range-copying)", #
            "cladogenesis: relative per-event weight of subset speciation", #
            "cladogenesis: relative per-event weight of vicariant speciation", #
            "cladogenesis: controls range size of smaller daughter", #
            "cladogenesis: controls range size of smaller daughter", #
            "cladogenesis: controls range size of smaller daughter", #
            "cladogenesis: controls range size of smaller daughter", #
            "cladogenesis: controls range size of smaller daughter", #
            "root: controls range size probabilities of root", #
            "mean frequency of truly sampling OTU of interest", #
            "detection probability per true sample of OTU of interest", #
            "false detection of OTU probability per true taphonomic control sample"#
            )), row.names = c("d", "e", "a", "b", "x", "n", "w", #
        "u", "j", "ysv", "ys", "y", "s", "v", "mx01", "mx01j", #
        "mx01y", "mx01s", "mx01v", "mx01r", "mf", "dp", "fdp"#
        ), class = "data.frame")), timesfn = NA, distsfn = NA, #
        dispersal_multipliers_fn = NA, area_of_areas_fn = NA, #
        areas_allowed_fn = NA, areas_adjacency_fn = NA, detects_fn = NA, #
        controls_fn = NA, max_range_size = 2, force_sparse = FALSE, #
        use_detection_model = FALSE, print_optim = TRUE, printlevel = 0, #
        on_NaN_error = -1e+50, wd = "/GitHub/PhyBEARS.jl/test/apes_SSE", #
        num_cores_to_use = 1, cluster_already_open = FALSE, use_optimx = TRUE, #
        rescale_params = FALSE, return_condlikes_table = TRUE, #
        calc_TTL_loglike_from_condlikes_table = TRUE, calc_ancprobs = TRUE, #
        speedup = TRUE, include_null_range = TRUE, useAmbiguities = FALSE, #
        min_branchlength = 1e-06, allow_null_tips = FALSE, all_geog_states_list_usually_inferred_from_areas_maxareas = list(#
            NA, 0L, 1L, 0:1)), outputs = new("BioGeoBEARS_model", #
        params_table = structure(list(type = c("free", "free", #
        "fixed", "fixed", "fixed", "fixed", "fixed", "fixed", #
        "free", "3-j", "ysv*2/3", "ysv*1/3", "ysv*1/3", "ysv*1/3", #
        "fixed", "mx01", "mx01", "mx01", "mx01", "fixed", "fixed", #
        "fixed", "fixed"), init = c(1e-12, 1e-12, 0, 1, 0, 0, #
        1, 0, 2.99998997978887, 2.99999, 1.99999, 1, 1, 1, 1e-04, #
        1e-04, 1e-04, 1e-04, 1e-04, 0.5, 0.1, 1, 0), min = c(1e-12, #
        1e-12, 1e-12, 1e-12, -2.5, -10, -10, -10, 1e-05, 1e-05, #
        1e-05, 1e-05, 1e-05, 1e-05, 1e-04, 1e-04, 1e-04, 1e-04, #
        1e-04, 1e-04, 0.005, 0.005, 0.005), max = c(4.999999999999, #
        4.999999999999, 4.999999999999, 0.999999999999, 2.5, #
        10, 10, 10, 2.99999, 3, 2, 1, 1, 1, 0.9999, 0.9999, 0.9999, #
        0.9999, 0.9999, 0.9999, 0.995, 0.995, 0.995), est = c(1e-12, #
        1e-12, 0, 1, 0, 0, 1, 0, 2.99998997978887, 1.00202111301684e-05, #
        6.6801407534456e-06, 3.3400703767228e-06, 3.3400703767228e-06, #
        3.3400703767228e-06, 1e-04, 1e-04, 1e-04, 1e-04, 1e-04, #
        0.5, 0.1, 1, 0), note = c("works", "works", "works", #
        "non-stratified only", "works", "works", "works", "works", #
        "works", "works", "works", "works", "works", "works", #
        "works", "works", "works", "works", "works", "no", "yes", #
        "yes", "yes"), desc = c("anagenesis: rate of 'dispersal' (range expansion)", #
        "anagenesis: rate of 'extinction' (range contraction)", #
        "anagenesis: rate of range-switching (i.e. for a standard char.)", #
        "anagenesis: exponent on branch lengths", "exponent on distance (modifies d, j, a)", #
        "exponent on environmental distance (modifies d, j, a)", #
        "exponent on manual dispersal multipliers (modifies d, j, a)", #
        "anagenesis: exponent on extinction risk with area (modifies e)", #
        "cladogenesis: relative per-event weight of jump dispersal", #
        "cladogenesis: y+s+v", "cladogenesis: y+s", "cladogenesis: relative per-event weight of sympatry (range-copying)", #
        "cladogenesis: relative per-event weight of subset speciation", #
        "cladogenesis: relative per-event weight of vicariant speciation", #
        "cladogenesis: controls range size of smaller daughter", #
        "cladogenesis: controls range size of smaller daughter", #
        "cladogenesis: controls range size of smaller daughter", #
        "cladogenesis: controls range size of smaller daughter", #
        "cladogenesis: controls range size of smaller daughter", #
        "root: controls range size probabilities of root", "mean frequency of truly sampling OTU of interest", #
        "detection probability per true sample of OTU of interest", #
        "false detection of OTU probability per true taphonomic control sample"#
        )), row.names = c("d", "e", "a", "b", "x", "n", "w", #
        "u", "j", "ysv", "ys", "y", "s", "v", "mx01", "mx01j", #
        "mx01y", "mx01s", "mx01v", "mx01r", "mf", "dp", "fdp"#
        ), class = "data.frame")), optim_result = structure(list(#
        p1 = 1e-12, p2 = 1e-12, p3 = 2.99998997978887, value = -1.17058691814607, #
        fevals = 58, gevals = NA_real_, niter = NA_real_, convcode = 0, #
        kkt1 = FALSE, kkt2 = TRUE, xtime = 0.401), row.names = "bobyqa", class = c("optimx", #
    "data.frame"), details = structure(list("bobyqa", c(0, 0, #
    0.107063822542346), structure(c(0, 0, 0, 0, 0, 0, 0, 0, -0.0550331748526196#
    ), dim = c(3L, 3L)), c(-0.0550331748526196, 0, 0), "none"), dim = c(1L, #
    5L), dimnames = list("bobyqa", c("method", "ngatend", "nhatend", #
    "hev", "message"))), maximize = TRUE, npar = 3L, follow.on = FALSE)), class = "calc_loglike_sp_results")#
#
trfn = "/GitHub/PhyBEARS.jl/test/apes_SSE/tree.newick"#
moref(trfn)#
#
tree_string = "(((chimp:1,human:1):1,gorilla:2):1,orang:3);"#
tr = read.tree(file="", text=tree_string)#
trtable = prt(tr, printflag=FALSE)#
#
numstates = 4#
tmpres = get_Qmat_COOmat_from_res(resDEC, numstates=numstates, include_null_range=TRUE, max_range_size=NULL, timeperiod_i=1)
probs_ancstate = rep(0.25, numstates)#
COO_weights_columnar = tmpres$COO_weights_columnar#
include_null_range = TRUE#
left_branch_downpass_likes = rep(1, numstates)#
right_branch_downpass_likes = rep(1, numstates)#
Rsp_rowsums = tmpres$Rsp_rowsums#
clado_table = cbind(tmpres$COO_weights_columnar[[1]]+1, tmpres$COO_weights_columnar[[2]]+1, tmpres$COO_weights_columnar[[3]]+1, tmpres$COO_weights_columnar[[4]])#
#
probs = rep(0, nrow(clado_table))#
for (i in 1:length(probs))#
	probs[i] = clado_table[i,4] / Rsp_rowsums[clado_table[i,1]]#
end#
clado_table = cbind(clado_table, probs)#
clado_table_df = adf2(clado_table)#
names(clado_table_df) = c("i", "j", "k", "wt", "prob")#
#
clado_table_df$i = clado_table_df$i + include_null_range # match to Julia#
clado_table_df$j = clado_table_df$j + include_null_range # match to Julia#
clado_table_df$k = clado_table_df$k + include_null_range # match to Julia#
clado_table_df#
#
# equal ancstate probs#
calc_uppass_probs_new2(probs_ancstate, COO_weights_columnar, numstates, include_null_range = include_null_range, #
    left_branch_downpass_likes = NULL, right_branch_downpass_likes = NULL, #
    Rsp_rowsums = NULL)
trfn = "/GitHub/PhyBEARS.jl/test/apes_SSE/tree.newick"#
moref(trfn)#
#
tree_string = "(((chimp:1,human:1):1,gorilla:2):1,orang:3);"#
tr = read.tree(file="", text=tree_string)#
trtable = prt(tr, printflag=FALSE)#
#
numstates = 4#
tmpres = get_Qmat_COOmat_from_res(resDECj, numstates=numstates, include_null_range=TRUE, max_range_size=NULL, timeperiod_i=1)#
#
probs_ancstate = rep(0.25, numstates)#
COO_weights_columnar = tmpres$COO_weights_columnar#
include_null_range = TRUE#
left_branch_downpass_likes = rep(1, numstates)#
right_branch_downpass_likes = rep(1, numstates)#
Rsp_rowsums = tmpres$Rsp_rowsums#
clado_table = cbind(tmpres$COO_weights_columnar[[1]]+1, tmpres$COO_weights_columnar[[2]]+1, tmpres$COO_weights_columnar[[3]]+1, tmpres$COO_weights_columnar[[4]])
probs = rep(0, nrow(clado_table))#
for (i in 1:length(probs))#
	probs[i] = clado_table[i,4] / Rsp_rowsums[clado_table[i,1]]#
end#
clado_table = cbind(clado_table, probs)#
clado_table_df = adf2(clado_table)#
names(clado_table_df) = c("i", "j", "k", "wt", "prob")#
#
clado_table_df$i = clado_table_df$i + include_null_range # match to Julia#
clado_table_df$j = clado_table_df$j + include_null_range # match to Julia#
clado_table_df$k = clado_table_df$k + include_null_range # match to Julia#
clado_table_df
cft(clado_table_df)
calc_uppass_probs_new2(probs_ancstate, COO_weights_columnar, numstates, include_null_range = include_null_range, #
    left_branch_downpass_likes = NULL, right_branch_downpass_likes = NULL, #
    Rsp_rowsums = NULL)
probs_ancstate
resDECj$output
cft(clado_table_df, numdigits_inbetween_have_fixed_digits=3)
cellval = -42.235235
conditional_format_cell(cellval)
conditional_format_cell(cellval, numdigits_inbetween_have_fixed_digits=3)
conditional_format_cell(cellval, numdigits_inbetween_have_fixed_digits=6)
conditional_format_cell(cellval, numdigits_inbetween_have_fixed_digits=5)
cft(clado_table_df, numdigits_inbetween_have_fixed_digits=5)
cft(clado_table_df, numdigits_inbetween_have_fixed_digits=6)
