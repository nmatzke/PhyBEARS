time_grid
c(read.table(outfns[1], header=FALSE))
c(read.table(outfns[1], header=FALSE))[[1]]
time_grid = c(read.table(outfns[1], header=FALSE))[[1]]#
# Change from time reading backwards to time reading forwards#
colnums = rev(1:length(time_grid))#
time_grid = max(time_grid) - time_grid#
time_grid
time_grid = c(read.table(outfns[1], header=FALSE))[[1]]#
# Change from time reading backwards to time reading forwards#
colnums = rev(1:length(time_grid))#
time_grid = -1*(max(time_grid) - time_grid) + min(-1*(max(time_grid) - time_grid))#
time_grid
-1*(max(time_grid) - time_grid)
-1*(max(time_grid) - time_grid) - min(-1*(max(time_grid) - time_grid))
as.matrix(read.table(outfns[2], header=FALSE))
Qarray
time_grid = c(read.table(outfns[1], header=FALSE))[[1]]#
# Change from time reading backwards to time reading forwards#
colnums = rev(1:length(time_grid))#
time_grid = -1*(max(time_grid) - time_grid) - min(-1*(max(time_grid) - time_grid))#
time_grid#
mu_vals_by_t = as.matrix(read.table(outfns[2], header=FALSE))[,colnums]#
Qvals_by_t = as.matrix(read.table(outfns[3], header=FALSE))[,colnums]#
Crates_by_t = as.matrix(read.table(outfns[4], header=FALSE))[,colnums]#
Qarray = read.table(outfns[5], header=FALSE)#
Carray = read.table(outfns[6], header=FALSE)#
#
# Add the final time at end of forward simulation, if needed#
if (is.null(max_simulation_time) == FALSE)#
	{#
	time_grid = c(time_grid, max_simulation_time)#
	mu_vals_by_t = cbind(mu_vals_by_t, mu_vals_by_t[,ncol(mu_vals_by_t)])#
	Qvals_by_t = cbind(Qvals_by_t, Qvals_by_t[,ncol(Qvals_by_t)])#
	Crates_by_t = cbind(Crates_by_t, Crates_by_t[,ncol(Crates_by_t)])#
	}
max_simulation_time = NULL#
max_simulation_time = 100.0#
# Read timepoints#
# Read in Q/A matrix, populate one and array#
# Read in C matrix, populate one and array#
#
# Load the files#
#time_grid = seq(0,10,0.1) # About halfway through#
time_grid = c(read.table(outfns[1], header=FALSE))[[1]]#
# Change from time reading backwards to time reading forwards#
colnums = rev(1:length(time_grid))#
time_grid = -1*(max(time_grid) - time_grid) - min(-1*(max(time_grid) - time_grid))#
time_grid#
mu_vals_by_t = as.matrix(read.table(outfns[2], header=FALSE))[,colnums]#
Qvals_by_t = as.matrix(read.table(outfns[3], header=FALSE))[,colnums]#
Crates_by_t = as.matrix(read.table(outfns[4], header=FALSE))[,colnums]#
Qarray = read.table(outfns[5], header=FALSE)#
Carray = read.table(outfns[6], header=FALSE)#
#
# Add the final time at end of forward simulation, if needed#
if (is.null(max_simulation_time) == FALSE)#
	{#
	time_grid = c(time_grid, max_simulation_time)#
	mu_vals_by_t = cbind(mu_vals_by_t, mu_vals_by_t[,ncol(mu_vals_by_t)])#
	Qvals_by_t = cbind(Qvals_by_t, Qvals_by_t[,ncol(Qvals_by_t)])#
	Crates_by_t = cbind(Crates_by_t, Crates_by_t[,ncol(Crates_by_t)])#
	}
Crates_by_t
time_grid
array
array(data=0.0, dim=c(numstates,numstates))
Qarray
Qarray = read.table(outfns[5], header=TRUE)#
Carray = read.table(outfns[6], header=TRUE)
Qarray
Qarray$i
max_simulation_time = NULL#
max_simulation_time = 100.0#
# Read timepoints#
# Read in Q/A matrix, populate one and array#
# Read in C matrix, populate one and array#
#
# Load the files#
#time_grid = seq(0,10,0.1) # About halfway through#
time_grid = c(read.table(outfns[1], header=FALSE))[[1]]#
# Change from time reading backwards to time reading forwards#
colnums = rev(1:length(time_grid))#
time_grid = -1*(max(time_grid) - time_grid) - min(-1*(max(time_grid) - time_grid))#
time_grid#
mu_vals_by_t = as.matrix(read.table(outfns[2], header=FALSE))[,colnums]#
Qvals_by_t = as.matrix(read.table(outfns[3], header=FALSE))[,colnums]#
Crates_by_t = as.matrix(read.table(outfns[4], header=FALSE))[,colnums]#
Qarray = read.table(outfns[5], header=TRUE)#
Carray = read.table(outfns[6], header=TRUE)#
#
# Add the final time at end of forward simulation, if needed#
if (is.null(max_simulation_time) == FALSE)#
	{#
	time_grid = c(time_grid, max_simulation_time)#
	mu_vals_by_t = cbind(mu_vals_by_t, mu_vals_by_t[,ncol(mu_vals_by_t)])#
	Qvals_by_t = cbind(Qvals_by_t, Qvals_by_t[,ncol(Qvals_by_t)])#
	Crates_by_t = cbind(Crates_by_t, Crates_by_t[,ncol(Crates_by_t)])#
	}#
# Produce the A transition matrix / array#
A = array(data=0.0, dim=c(numstates,numstates,length(timepoints)))#
for i in 1:length(timepoints)#
	{#
	for j in 1:nrow(Qarray)#
		{#
		A[Qarray$i[j],Qarray$j[j],i] = Qvals_by_t[j,i]#
		}#
	}
max_simulation_time = NULL#
max_simulation_time = 100.0#
# Read timepoints#
# Read in Q/A matrix, populate one and array#
# Read in C matrix, populate one and array#
#
# Load the files#
#time_grid = seq(0,10,0.1) # About halfway through#
time_grid = c(read.table(outfns[1], header=FALSE))[[1]]#
# Change from time reading backwards to time reading forwards#
colnums = rev(1:length(time_grid))#
time_grid = -1*(max(time_grid) - time_grid) - min(-1*(max(time_grid) - time_grid))#
time_grid#
mu_vals_by_t = as.matrix(read.table(outfns[2], header=FALSE))[,colnums]#
Qvals_by_t = as.matrix(read.table(outfns[3], header=FALSE))[,colnums]#
Crates_by_t = as.matrix(read.table(outfns[4], header=FALSE))[,colnums]#
Qarray = read.table(outfns[5], header=TRUE)#
Carray = read.table(outfns[6], header=TRUE)#
#
# Add the final time at end of forward simulation, if needed#
if (is.null(max_simulation_time) == FALSE)#
	{#
	time_grid = c(time_grid, max_simulation_time)#
	mu_vals_by_t = cbind(mu_vals_by_t, mu_vals_by_t[,ncol(mu_vals_by_t)])#
	Qvals_by_t = cbind(Qvals_by_t, Qvals_by_t[,ncol(Qvals_by_t)])#
	Crates_by_t = cbind(Crates_by_t, Crates_by_t[,ncol(Crates_by_t)])#
	}#
# Produce the A transition matrix / array#
A = array(data=0.0, dim=c(numstates,numstates,length(timepoints)))#
for i in 1:length(time_grid)#
	{#
	for j in 1:nrow(Qarray)#
		{#
		A[Qarray$i[j],Qarray$j[j],i] = Qvals_by_t[j,i]#
		}#
	}
A = array(data=0.0, dim=c(numstates,numstates,length(timepoints)))#
for (i in 1:length(time_grid))#
	{#
	for (j in 1:nrow(Qarray))#
		{#
		A[Qarray$i[j],Qarray$j[j],i] = Qvals_by_t[j,i]#
		}#
	}
A = array(data=0.0, dim=c(numstates,numstates,length(timepoints)))
A = array(data=0.0, dim=c(numstates,numstates,length(time_grid)))#
for (i in 1:length(time_grid))#
	{#
	for (j in 1:nrow(Qarray))#
		{#
		A[Qarray$i[j],Qarray$j[j],i] = Qvals_by_t[j,i]#
		}#
	}
A
A = array(data=0.0, dim=c(numstates,numstates,length(time_grid)))#
for (i in 1:length(time_grid))#
	{#
	for (j in 1:nrow(Qarray))#
		{#
		A[Qarray$i[j],Qarray$j[j],i] = Qvals_by_t[j,i]#
		}#
	# Set the diagonal#
	diag(A[,,i]) = 0.0#
	diag(A[,,i]) = -rowSums(A[,,i])#
	}
A
A[,,8]
apply(apply(X=A, MARGIN=3, rowSums)
apply(X=A, MARGIN=3, rowSums)
dims(A)
dim(A)
round(apply(X=A, MARGIN=3, rowSums), digits=10)
transition_matrix_C = get_random_mk_transition_matrix(Nstates=4, rate_model="ER", max_rate=0.1)
transition_matrix_C
Crates_by_t
transition_table_probs_C_matrix = array(data=0.0, dim=c(nrow(Crates_by_t), 4, length(time_grid)))
i=1
tmprates = cbind(Carray, Crates_by_t[i])
tmprates
tmprates = cbind(Carray$i, Carray$j, Carray$k, Crates_by_t[i])#
	names(tmprates) = c("i", "j", "k", "rates_t")
tmprates
cbind(Carray$i, Carray$j, Carray$k, Crates_by_t[i])
tmprates = as.data.frame(cbind(Carray$i, Carray$j, Carray$k, Crates_by_t[i]), stringsAsFactors=FALSE)#
	names(tmprates) = c("i", "j", "k", "rates_t")
tmprates
Crates_by_t
tmprates = as.data.frame(cbind(Carray$i, Carray$j, Carray$k, Crates_by_t[,i]), stringsAsFactors=FALSE)#
	names(tmprates) = c("i", "j", "k", "rates_t")
tmprates
aggregate(tmprates$rates_t, by=tmprates$i, FUN=sum)
aggregate(tmprates$rates_t, by=list(tmprates$i), FUN=sum)
rates_sums = aggregate(tmprates$rates_t, by=list(tmprates$i), FUN=sum)#
	tmporder = order(rates_sums[,1])#
	tmporder
rates_sums = aggregate(tmprates$rates_t, by=list(tmprates$i), FUN=sum)
class(rates_sums)
tmprates
rates_sums
names(rates_sums) = c("i", "rates_sum")#
	tmporder = order(rates_sums$i)#
	rates_sums = rates_sums[tmporder,]
rates_sums
transition_table_C = NULL#
transrates_table_C = NULL#
transition_table_probs_C_matrix = array(data=0.0, dim=c(nrow(Crates_by_t), 4, length(time_grid)))#
transition_table_rates_C_matrix = array(data=0.0, dim=c(nrow(Crates_by_t), 4, length(time_grid)))#
#
for (i in 1:length(time_grid))#
	{#
	tmprates = as.data.frame(cbind(Carray$i, Carray$j, Carray$k, Crates_by_t[,i]), stringsAsFactors=FALSE)#
	names(tmprates) = c("i", "j", "k", "rates_t")#
	# Convert rates to probabilities#
	rates_sums = aggregate(tmprates$rates_t, by=list(tmprates$i), FUN=sum)#
	# Column names#
	names(rates_sums) = c("i", "rates_sum")#
	# Make sure rates_sums are ordered by 'i' (ancestral state index)#
	tmporder = order(rates_sums$i)#
	rates_sums = rates_sums[tmporder,]#
	# Convert rates to probabilities#
	tmpprobs = tmprates#
	names(tmpprobs) = c("i", "j", "k", "probs_t")#
	for (q in 1:nrow(rates_sums))#
		{#
		tmpi = rates_sums$i[q]#
		TF = tmprates$i == tmpi#
#
		tmpprobs$probs_t[TF] = tmpprobs$rates_t[TF] / rates_sums$rates_sum[q]#
		}#
	transition_table_probs_C_matrix[,,i] = tmprates#
	transition_table_probs_C_matrix[,,i] = tmpprobs#
	}
i
q
tmprates = as.data.frame(cbind(Carray$i, Carray$j, Carray$k, Crates_by_t[,i]), stringsAsFactors=FALSE)#
	names(tmprates) = c("i", "j", "k", "rates_t")#
	# Convert rates to probabilities#
	rates_sums = aggregate(tmprates$rates_t, by=list(tmprates$i), FUN=sum)#
	# Column names#
	names(rates_sums) = c("i", "rates_sum")#
	# Make sure rates_sums are ordered by 'i' (ancestral state index)#
	tmporder = order(rates_sums$i)#
	rates_sums = rates_sums[tmporder,]#
	# Convert rates to probabilities#
	tmpprobs = tmprates#
	names(tmpprobs) = c("i", "j", "k", "probs_t")
tmpprobs
tmpi = rates_sums$i[q]#
		TF = tmprates$i == tmpi
TF
tmpprobs$probs_t[TF]
tmpprobs$rates_t[TF]
transition_table_C = NULL#
transrates_table_C = NULL#
transition_table_probs_C_matrix = array(data=0.0, dim=c(nrow(Crates_by_t), 4, length(time_grid)))#
transition_table_rates_C_matrix = array(data=0.0, dim=c(nrow(Crates_by_t), 4, length(time_grid)))#
#
for (i in 1:length(time_grid))#
	{#
	tmprates = as.data.frame(cbind(Carray$i, Carray$j, Carray$k, Crates_by_t[,i]), stringsAsFactors=FALSE)#
	names(tmprates) = c("i", "j", "k", "rates_t")#
	# Convert rates to probabilities#
	rates_sums = aggregate(tmprates$rates_t, by=list(tmprates$i), FUN=sum)#
	# Column names#
	names(rates_sums) = c("i", "rates_sum")#
	# Make sure rates_sums are ordered by 'i' (ancestral state index)#
	tmporder = order(rates_sums$i)#
	rates_sums = rates_sums[tmporder,]#
	# Convert rates to probabilities#
	tmpprobs = tmprates#
	names(tmpprobs) = c("i", "j", "k", "probs_t")#
	for (q in 1:nrow(rates_sums))#
		{#
		tmpi = rates_sums$i[q]#
		TF = tmprates$i == tmpi#
#
		tmpprobs$probs_t[TF] = tmprates$rates_t[TF] / rates_sums$rates_sum[q]#
		}#
	transition_table_probs_C_matrix[,,i] = tmprates#
	transition_table_probs_C_matrix[,,i] = tmpprobs#
	}
transition_table_probs_C_matrix
transition_table_C = NULL#
transrates_table_C = NULL#
transition_table_probs_C_matrix = array(data=0.0, dim=c(nrow(Crates_by_t), 4, length(time_grid)))#
transition_table_rates_C_matrix = array(data=0.0, dim=c(nrow(Crates_by_t), 4, length(time_grid)))
dim(transition_table_probs_C_matrix)
transition_table_C = NULL#
transrates_table_C = NULL#
transition_table_probs_C_matrix = array(data=0.0, dim=c(nrow(Crates_by_t), 4, length(time_grid)))#
transition_table_rates_C_matrix = array(data=0.0, dim=c(nrow(Crates_by_t), 4, length(time_grid)))#
dim(transition_table_probs_C_matrix)#
dim(transition_table_rates_C_matrix)
tmprates = as.data.frame(cbind(Carray$i, Carray$j, Carray$k, Crates_by_t[,i]), stringsAsFactors=FALSE)#
	names(tmprates) = c("i", "j", "k", "rates_t")#
	# Convert rates to probabilities#
	rates_sums = aggregate(tmprates$rates_t, by=list(tmprates$i), FUN=sum)#
	# Column names#
	names(rates_sums) = c("i", "rates_sum")#
	# Make sure rates_sums are ordered by 'i' (ancestral state index)#
	tmporder = order(rates_sums$i)#
	rates_sums = rates_sums[tmporder,]#
	# Convert rates to probabilities#
	tmpprobs = tmprates#
	names(tmpprobs) = c("i", "j", "k", "probs_t")
tmpprobs
rates_sums
tmpi = rates_sums$i[q]#
		TF = tmprates$i == tmpi
q
TF
tmpprobs$probs_t[TF]
tmprates$rates_t[TF]
rates_sums$rates_sum[q]
rates_sums$rates_sum[q]
tmpprobs$probs_t[TF] = tmprates$rates_t[TF] / rates_sums$rates_sum[q]
tmpprobs$probs_t
round(tmpprobs$probs_t, 3)
transition_table_C = NULL#
transrates_table_C = NULL#
transition_table_probs_C_matrix = array(data=0.0, dim=c(nrow(Crates_by_t), 4, length(time_grid)))#
transition_table_rates_C_matrix = array(data=0.0, dim=c(nrow(Crates_by_t), 4, length(time_grid)))#
dim(transition_table_probs_C_matrix)#
dim(transition_table_rates_C_matrix)#
#
for (i in 1:length(time_grid))#
	{#
	tmprates = as.data.frame(cbind(Carray$i, Carray$j, Carray$k, Crates_by_t[,i]), stringsAsFactors=FALSE)#
	names(tmprates) = c("i", "j", "k", "rates_t")#
	# Convert rates to probabilities#
	rates_sums = aggregate(tmprates$rates_t, by=list(tmprates$i), FUN=sum)#
	# Column names#
	names(rates_sums) = c("i", "rates_sum")#
	# Make sure rates_sums are ordered by 'i' (ancestral state index)#
	tmporder = order(rates_sums$i)#
	rates_sums = rates_sums[tmporder,]#
	# Convert rates to probabilities#
	tmpprobs = tmprates#
	names(tmpprobs) = c("i", "j", "k", "probs_t")#
	for (q in 1:nrow(rates_sums))#
		{#
		tmpi = rates_sums$i[q]#
		TF = tmprates$i == tmpi#
#
		tmpprobs$probs_t[TF] = tmprates$rates_t[TF] / rates_sums$rates_sum[q]#
		}#
	transition_table_probs_C_matrix[,,i] = tmprates$probs_t#
	transition_table_probs_C_matrix[,,i] = tmpprobs$probs_t#
	}
transition_table_C = NULL#
transrates_table_C = NULL#
transition_table_probs_C_matrix = array(data=0.0, dim=c(nrow(Crates_by_t), 4, length(time_grid)))#
transition_table_rates_C_matrix = array(data=0.0, dim=c(nrow(Crates_by_t), 4, length(time_grid)))#
dim(transition_table_probs_C_matrix)#
dim(transition_table_rates_C_matrix)#
#
for (i in 1:length(time_grid))#
	{#
	tmprates = as.data.frame(cbind(Carray$i, Carray$j, Carray$k, Crates_by_t[,i]), stringsAsFactors=FALSE)#
	names(tmprates) = c("i", "j", "k", "rates_t")#
	# Convert rates to probabilities#
	rates_sums = aggregate(tmprates$rates_t, by=list(tmprates$i), FUN=sum)#
	# Column names#
	names(rates_sums) = c("i", "rates_sum")#
	# Make sure rates_sums are ordered by 'i' (ancestral state index)#
	tmporder = order(rates_sums$i)#
	rates_sums = rates_sums[tmporder,]#
	# Convert rates to probabilities#
	tmpprobs = tmprates#
	names(tmpprobs) = c("i", "j", "k", "probs_t")#
	for (q in 1:nrow(rates_sums))#
		{#
		tmpi = rates_sums$i[q]#
		TF = tmprates$i == tmpi#
#
		tmpprobs$probs_t[TF] = tmprates$rates_t[TF] / rates_sums$rates_sum[q]#
		}#
	transition_table_probs_C_matrix[,,i] = tmprates$rates_t#
	transition_table_probs_C_matrix[,,i] = tmpprobs$probs_t#
	}
# transrates_table_C: columns are i, j, k, rate # (later, we will add up these rates to get the total lambda by state)#
transition_table_C = NULL#
transrates_table_C = NULL#
transition_table_probs_C_matrix = array(data=0.0, dim=c(nrow(Crates_by_t), 4, length(time_grid)))#
transition_table_rates_C_matrix = array(data=0.0, dim=c(nrow(Crates_by_t), 4, length(time_grid)))#
dim(transition_table_probs_C_matrix)#
dim(transition_table_rates_C_matrix)#
#
for (i in 1:length(time_grid))#
	{#
	tmprates = as.data.frame(cbind(Carray$i, Carray$j, Carray$k, Crates_by_t[,i]), stringsAsFactors=FALSE)#
	names(tmprates) = c("i", "j", "k", "rates_t")#
	# Convert rates to probabilities#
	rates_sums = aggregate(tmprates$rates_t, by=list(tmprates$i), FUN=sum)#
	# Column names#
	names(rates_sums) = c("i", "rates_sum")#
	# Make sure rates_sums are ordered by 'i' (ancestral state index)#
	tmporder = order(rates_sums$i)#
	rates_sums = rates_sums[tmporder,]#
	# Convert rates to probabilities#
	tmpprobs = tmprates#
	names(tmpprobs) = c("i", "j", "k", "probs_t")#
	for (q in 1:nrow(rates_sums))#
		{#
		tmpi = rates_sums$i[q]#
		TF = tmprates$i == tmpi#
#
		tmpprobs$probs_t[TF] = tmprates$rates_t[TF] / rates_sums$rates_sum[q]#
		}#
	transition_table_rates_C_matrix[,,i] = tmprates$rates_t#
	transition_table_probs_C_matrix[,,i] = tmpprobs$probs_t#
	}
transition_table_probs_C_matrix
tmpprobs
for (i in 1:length(time_grid))#
	{#
	tmpprobs = transition_table_probs_C_matrix[,,i]#
	x = aggregate(tmpprobs, by=list(tmpprobs$i), FUN=sum)#
	print(x)#
	}
for (i in 1:length(time_grid))#
	{#
	tmpprobs = transition_table_probs_C_matrix[,,i]#
	x = aggregate(tmpprobs[,"probs_t"], by=list(tmpprobs[,"i"]), FUN=sum)#
	print(x)#
	}
tmpprobs
tmpprobs[,1]
tmpprobs
transition_table_probs_C_matrix[,,i]
transition_table_C = NULL#
transrates_table_C = NULL#
transition_table_probs_C_matrix = array(data=0.0, dim=c(nrow(Crates_by_t), 4, length(time_grid)))#
transition_table_rates_C_matrix = array(data=0.0, dim=c(nrow(Crates_by_t), 4, length(time_grid)))#
dim(transition_table_probs_C_matrix)#
dim(transition_table_rates_C_matrix)#
#
for (i in 1:length(time_grid))#
	{#
	tmprates = as.data.frame(cbind(Carray$i, Carray$j, Carray$k, Crates_by_t[,i]), stringsAsFactors=FALSE)#
	names(tmprates) = c("i", "j", "k", "rates_t")#
	# Convert rates to probabilities#
	rates_sums = aggregate(tmprates$rates_t, by=list(tmprates$i), FUN=sum)#
	# Column names#
	names(rates_sums) = c("i", "rates_sum")#
	# Make sure rates_sums are ordered by 'i' (ancestral state index)#
	tmporder = order(rates_sums$i)#
	rates_sums = rates_sums[tmporder,]#
	# Convert rates to probabilities#
	tmpprobs = tmprates#
	names(tmpprobs) = c("i", "j", "k", "probs_t")#
	for (q in 1:nrow(rates_sums))#
		{#
		tmpi = rates_sums$i[q]#
		TF = tmprates$i == tmpi#
#
		tmpprobs$probs_t[TF] = tmprates$rates_t[TF] / rates_sums$rates_sum[q]#
		}#
	transition_table_rates_C_matrix[,,i] = tmprates#
	transition_table_probs_C_matrix[,,i] = tmpprobs#
	}#
#
# Check probs#
for (i in 1:length(time_grid))#
	{#
	tmpprobs = transition_table_probs_C_matrix[,,i]#
	x = aggregate(tmpprobs[,4], by=list(tmpprobs[,1]), FUN=sum)#
	print(x)#
	}
tmprates
dim(transition_table_rates_C_matrix[,,i])
dim(transition_table_rates_C_matrix[,,1])
dim(transition_table_rates_C_matrix)
transition_table_C = NULL#
transrates_table_C = NULL#
transition_table_probs_C_matrix = array(data=0.0, dim=c(nrow(Crates_by_t), 4, length(time_grid)))#
transition_table_rates_C_matrix = array(data=0.0, dim=c(nrow(Crates_by_t), 4, length(time_grid)))#
dim(transition_table_probs_C_matrix)#
dim(transition_table_rates_C_matrix)
i=1
tmprates = as.data.frame(cbind(Carray$i, Carray$j, Carray$k, Crates_by_t[,i]), stringsAsFactors=FALSE)#
	names(tmprates) = c("i", "j", "k", "rates_t")#
	# Convert rates to probabilities#
	rates_sums = aggregate(tmprates$rates_t, by=list(tmprates$i), FUN=sum)#
	# Column names#
	names(rates_sums) = c("i", "rates_sum")#
	# Make sure rates_sums are ordered by 'i' (ancestral state index)#
	tmporder = order(rates_sums$i)#
	rates_sums = rates_sums[tmporder,]#
	# Convert rates to probabilities#
	tmpprobs = tmprates#
	names(tmpprobs) = c("i", "j", "k", "probs_t")#
	for (q in 1:nrow(rates_sums))#
		{#
		tmpi = rates_sums$i[q]#
		TF = tmprates$i == tmpi#
#
		tmpprobs$probs_t[TF] = tmprates$rates_t[TF] / rates_sums$rates_sum[q]#
		}
tmprates
tmpprobs
transition_table_rates_C_matrix[,,i]
transition_table_rates_C_matrix[,,i] = tmprates
transition_table_rates_C_matrix
transition_table_C = NULL#
transrates_table_C = NULL#
transition_table_probs_C_matrix = array(data=0.0, dim=c(nrow(Crates_by_t), 4, length(time_grid)))#
transition_table_rates_C_matrix = array(data=0.0, dim=c(nrow(Crates_by_t), 4, length(time_grid)))#
dim(transition_table_probs_C_matrix)#
dim(transition_table_rates_C_matrix)#
#
for (i in 1:length(time_grid))#
	{#
	tmprates = as.data.frame(cbind(Carray$i, Carray$j, Carray$k, Crates_by_t[,i]), stringsAsFactors=FALSE)#
	names(tmprates) = c("i", "j", "k", "rates_t")#
	# Convert rates to probabilities#
	rates_sums = aggregate(tmprates$rates_t, by=list(tmprates$i), FUN=sum)#
	# Column names#
	names(rates_sums) = c("i", "rates_sum")#
	# Make sure rates_sums are ordered by 'i' (ancestral state index)#
	tmporder = order(rates_sums$i)#
	rates_sums = rates_sums[tmporder,]#
	# Convert rates to probabilities#
	tmpprobs = tmprates#
	names(tmpprobs) = c("i", "j", "k", "probs_t")#
	for (q in 1:nrow(rates_sums))#
		{#
		tmpi = rates_sums$i[q]#
		TF = tmprates$i == tmpi#
#
		tmpprobs$probs_t[TF] = tmprates$rates_t[TF] / rates_sums$rates_sum[q]#
		}#
	transition_table_rates_C_matrix[,,i] = as.matrix(tmprates)#
	transition_table_probs_C_matrix[,,i] = as.matrix(tmpprobs)#
	}
transition_table_probs_C_matrix
for (i in 1:length(time_grid))#
	{#
	tmpprobs = transition_table_probs_C_matrix[,,i]#
	x = aggregate(tmpprobs[,4], by=list(tmpprobs[,1]), FUN=sum)#
	print(x)#
	}
for (i in 1:length(time_grid))#
	{#
	tmpprobs = transition_table_probs_C_matrix[,,i]#
	probs_sum = aggregate(tmpprobs[,4], by=list(tmpprobs[,1]), FUN=sum)#
	print(probs_sum)#
	tmprates = transition_table_probs_C_matrix[,,i]#
	rates_sum = aggregate(tmprates[,4], by=list(tmprates[,1]), FUN=sum)#
	print(rates_sum)#
	}
for (i in 1:length(time_grid))#
	{#
	tmpprobs = transition_table_probs_C_matrix[,,i]#
	probs_sum = aggregate(tmpprobs[,4], by=list(tmpprobs[,1]), FUN=sum)#
	tmprates = transition_table_rates_C_matrix[,,i]#
	rates_sum = aggregate(tmprates[,4], by=list(tmprates[,1]), FUN=sum)#
	sums_by_i = cbind(rates_sum, probs_sum[,2])#
	print(sums_by_i)#
	}
for (i in 1:length(time_grid))#
	{#
	tmpprobs = transition_table_probs_C_matrix[,,i]#
	probs_sum = aggregate(tmpprobs[,4], by=list(tmpprobs[,1]), FUN=sum)#
	tmprates = transition_table_rates_C_matrix[,,i]#
	rates_sum = aggregate(tmprates[,4], by=list(tmprates[,1]), FUN=sum)#
	sums_by_i = cbind(rates_sum, probs_sum[,2])#
	names(sums_by_i) = c("i", "rates_sum", "probs_sum")#
	print(sums_by_i)#
	}
transition_table_probs_C_matrix
# Check for null range#
	if (rates_sums$i[1] == 2)#
		{#
		tmprow = c(1,1,1,0.0)#
		rates_sums = rbind(tmprow, rates_sums)#
		}
matrix
if (rates_sums$i[1] == 2)#
		{#
		tmprow = matrix(data=c(1,1,1,0.0), nrow=1)#
		rates_sums = rbind(tmprow, rates_sums)#
		}
rates_sums
rates_sums
matrix(data=c(1,1,1,0.0), nrow=1)
tmprates = as.data.frame(cbind(Carray$i, Carray$j, Carray$k, Crates_by_t[,i]), stringsAsFactors=FALSE)#
	names(tmprates) = c("i", "j", "k", "rates_t")#
	# Convert rates to probabilities#
	rates_sums = aggregate(tmprates$rates_t, by=list(tmprates$i), FUN=sum)#
	# Column names#
	names(rates_sums) = c("i", "rates_sum")
rates_sums
tmprow = matrix(data=c(1,0.0), nrow=1)#
		rates_sums = rbind(tmprow, rates_sums)
data.frame(	tmprates = as.data.frame(cbind(Carray$i, Carray$j, Carray$k, Crates_by_t[,i]), stringsAsFactors=FALSE)#
	names(tmprates) = c("i", "j", "k", "rates_t")#
	# Convert rates to probabilities#
	rates_sums = aggregate(tmprates$rates_t, by=list(tmprates$i), FUN=sum)#
	# Column names#
	names(rates_sums) = c("i", "rates_sum")#
	# Check for null range#
	if (rates_sums$i[1] == 2)#
		{#
		tmprow = as.data.frame(matrix(data=c(1,0.0), nrow=1), col.names= c("i", "rates_sum"))#
		rates_sums = rbind(tmprow, rates_sums)#
		}
tmprates = as.data.frame(cbind(Carray$i, Carray$j, Carray$k, Crates_by_t[,i]), stringsAsFactors=FALSE)#
	names(tmprates) = c("i", "j", "k", "rates_t")#
	# Convert rates to probabilities#
	rates_sums = aggregate(tmprates$rates_t, by=list(tmprates$i), FUN=sum)#
	# Column names#
	names(rates_sums) = c("i", "rates_sum")#
	# Check for null range#
	if (rates_sums$i[1] == 2)#
		{#
		tmprow = as.data.frame(matrix(data=c(1,0.0), nrow=1), col.names= c("i", "rates_sum"))#
		rates_sums = rbind(tmprow, rates_sums)#
		}
tmprow = as.data.frame(matrix(data=c(1,0.0), nrow=1), col.names= c("i", "rates_sum"))
tmprow
tmprow = as.data.frame(matrix(data=c(1,0.0), nrow=1), stringsAsFactors=FALSE)#
		name(tmprow) = c("i", "rates_sum")#
		rates_sums = rbind(tmprow, rates_sums)
tmprow = as.data.frame(matrix(data=c(1,0.0), nrow=1), stringsAsFactors=FALSE)#
		names(tmprow) = c("i", "rates_sum")#
		rates_sums = rbind(tmprow, rates_sums)
rates_sums
transition_table_C = NULL#
transrates_table_C = NULL#
transition_table_probs_C_matrix = array(data=0.0, dim=c(nrow(Crates_by_t), 4, length(time_grid)))#
transition_table_rates_C_matrix = array(data=0.0, dim=c(nrow(Crates_by_t), 4, length(time_grid)))#
dim(transition_table_probs_C_matrix)#
dim(transition_table_rates_C_matrix)#
#
rates_sums_by_t = NULL#
for (i in 1:length(time_grid))#
	{#
	tmprates = as.data.frame(cbind(Carray$i, Carray$j, Carray$k, Crates_by_t[,i]), stringsAsFactors=FALSE)#
	names(tmprates) = c("i", "j", "k", "rates_t")#
	# Convert rates to probabilities#
	rates_sums = aggregate(tmprates$rates_t, by=list(tmprates$i), FUN=sum)#
	# Column names#
	names(rates_sums) = c("i", "rates_sum")#
	# Make sure rates_sums are ordered by 'i' (ancestral state index)#
	tmporder = order(rates_sums$i)#
	rates_sums = rates_sums[tmporder,]#
	# Check for null range; add row for "i" if needed#
	if (rates_sums$i[1] == 2)#
		{#
		tmprow = as.data.frame(matrix(data=c(1,0.0), nrow=1), stringsAsFactors=FALSE)#
		names(tmprow) = c("i", "rates_sum")#
		rates_sums = rbind(tmprow, rates_sums)#
		}#
	rates_sums_by_t	= cbind(rates_sums_by_t, rates_sums$rates_sum)#
#
	# Convert rates to probabilities#
	tmpprobs = tmprates#
	names(tmpprobs) = c("i", "j", "k", "probs_t")#
	for (q in 1:nrow(rates_sums))#
		{#
		tmpi = rates_sums$i[q]#
		TF = tmprates$i == tmpi#
#
		tmpprobs$probs_t[TF] = tmprates$rates_t[TF] / rates_sums$rates_sum[q]#
		}#
	transition_table_rates_C_matrix[,,i] = as.matrix(tmprates)#
	transition_table_probs_C_matrix[,,i] = as.matrix(tmpprobs)#
	}#
#
rates_sums_by_t
time_grid = c(read.table(outfns[1], header=FALSE))[[1]]
time_grid
Crates_by_t = as.matrix(read.table(outfns[4], header=FALSE))
Crates_by_t
colnums
colnums = rev(1:length(time_grid))#
time_grid = -1*(max(time_grid) - time_grid) - min(-1*(max(time_grid) - time_grid))#
time_grid#
mu_vals_by_t = as.matrix(read.table(outfns[2], header=FALSE))[,colnums]#
Qvals_by_t = as.matrix(read.table(outfns[3], header=FALSE))[,colnums]#
Crates_by_t = as.matrix(read.table(outfns[4], header=FALSE))[,colnums]#
Qarray = read.table(outfns[5], header=TRUE)#
Carray = read.table(outfns[6], header=TRUE)
Crates_by_t
if (is.null(max_simulation_time) == FALSE)#
	{#
	time_grid = c(time_grid, max_simulation_time)#
	mu_vals_by_t = cbind(mu_vals_by_t, mu_vals_by_t[,ncol(mu_vals_by_t)])#
	Qvals_by_t = cbind(Qvals_by_t, Qvals_by_t[,ncol(Qvals_by_t)])#
	Crates_by_t = cbind(Crates_by_t, Crates_by_t[,ncol(Crates_by_t)])#
	}
Crates_by_t
rates_sums_by_t
transition_table_C
transition_table_indices_C = transition_table_rates_C_matrix[,1:3] - 1
transition_table_indices_C
transition_table_rates_C_matrix[,1:3]
transition_table_rates_C_matrix
transition_table_indices_C = transition_table_rates_C_matrix[,1:3,1] - 1
transition_table_indices_C = transition_table_rates_C_matrix[,1:3,1] - 1#
# transition_table_probs_C1 = transition_table_C[,4]#
transition_table_probs_C1 = transition_table_probs_C_matrix[,4,1]
transition_table_indices_C
transition_table_indices_C
transition_table_C
transition_table_probs_C_matrix
transition_matrix_A
A
A
transition_table_probs_C_matrix = array(data=0.0, dim=c(nrow(transition_table_indices_C), 2, length(time_grid)))#
#
# Fill in the transition_matrix_C and transition_table_probs#
for (i in 1:length(time_grid))#
	{#
	transition_matrix_C_array[,,i] = transition_table_indices_C#
	transition_table_probs_C_matrix[,1,i] = transition_table_probs_C_matrix[,4,i]#
	transition_table_probs_C_matrix[,2,i] = transition_table_probs_C_matrix[,4,i]#
	}
transition_matrix_C_array = array(data=0.0, dim=c(nrow(transition_table_indices_C), ncol(transition_table_indices_C), length(time_grid)))#
#
# Probs encoded in a num_clado_events * 2 * num_times array#
# the "2" just duplicates, ensures we have a 3D array#
transition_table_probs_C_matrix = array(data=0.0, dim=c(nrow(transition_table_indices_C), 2, length(time_grid)))#
#
# Fill in the transition_matrix_C and transition_table_probs#
for (i in 1:length(time_grid))#
	{#
	transition_matrix_C_array[,,i] = transition_table_indices_C#
	transition_table_probs_C_matrix[,1,i] = transition_table_probs_C_matrix[,4,i]#
	transition_table_probs_C_matrix[,2,i] = transition_table_probs_C_matrix[,4,i]#
	}
transition_table_probs_C_matrix
transition_table_probs_C_matrix
dim(transition_table_probs_C_matrix)
transition_matrix_C_array = array(data=0.0, dim=c(nrow(transition_table_indices_C), ncol(transition_table_indices_C), length(time_grid)))#
#
# Probs encoded in a num_clado_events * 2 * num_times array#
# the "2" just duplicates, ensures we have a 3D array#
transition_table_probs_C = array(data=0.0, dim=c(nrow(transition_table_indices_C), 2, length(time_grid)))#
#
# Fill in the transition_matrix_C and transition_table_probs#
for (i in 1:length(time_grid))#
	{#
	transition_matrix_C_array[,,i] = transition_table_indices_C#
	transition_table_probs_C[,1,i] = transition_table_probs_C_matrix[,4,i]#
	transition_table_probs_C[,2,i] = transition_table_probs_C_matrix[,4,i]#
	}
transition_table_probs_C_matrix
dim9transition_table_probs_C_matrix)# transition_table_C: columns are i, j, k, prob#
# transrates_table_C: columns are i, j, k, rate # (later, we will add up these rates to get the total lambda by state)#
transition_table_C = NULL#
transrates_table_C = NULL#
transition_table_probs_C_matrix = array(data=0.0, dim=c(nrow(Crates_by_t), 4, length(time_grid)))#
transition_table_rates_C_matrix = array(data=0.0, dim=c(nrow(Crates_by_t), 4, length(time_grid)))#
dim(transition_table_probs_C_matrix)#
dim(transition_table_rates_C_matrix)#
#
rates_sums_by_t = NULL#
for (i in 1:length(time_grid))#
	{#
	tmprates = as.data.frame(cbind(Carray$i, Carray$j, Carray$k, Crates_by_t[,i]), stringsAsFactors=FALSE)#
	names(tmprates) = c("i", "j", "k", "rates_t")#
	# Convert rates to probabilities#
	rates_sums = aggregate(tmprates$rates_t, by=list(tmprates$i), FUN=sum)#
	# Column names#
	names(rates_sums) = c("i", "rates_sum")#
	# Make sure rates_sums are ordered by 'i' (ancestral state index)#
	tmporder = order(rates_sums$i)#
	rates_sums = rates_sums[tmporder,]#
	# Check for null range; add row for "i" if needed#
	if (rates_sums$i[1] == 2)#
		{#
		tmprow = as.data.frame(matrix(data=c(1,0.0), nrow=1), stringsAsFactors=FALSE)#
		names(tmprow) = c("i", "rates_sum")#
		rates_sums = rbind(tmprow, rates_sums)#
		}#
	rates_sums_by_t	= cbind(rates_sums_by_t, rates_sums$rates_sum)#
#
	# Convert rates to probabilities#
	tmpprobs = tmprates#
	names(tmpprobs) = c("i", "j", "k", "probs_t")#
	for (q in 1:nrow(rates_sums))#
		{#
		tmpi = rates_sums$i[q]#
		TF = tmprates$i == tmpi#
#
		tmpprobs$probs_t[TF] = tmprates$rates_t[TF] / rates_sums$rates_sum[q]#
		}#
	transition_table_rates_C_matrix[,,i] = as.matrix(tmprates)#
	transition_table_probs_C_matrix[,,i] = as.matrix(tmpprobs)#
	}#
# Check probs#
for (i in 1:length(time_grid))#
	{#
	tmpprobs = transition_table_probs_C_matrix[,,i]#
	probs_sum = aggregate(tmpprobs[,4], by=list(tmpprobs[,1]), FUN=sum)#
	tmprates = transition_table_rates_C_matrix[,,i]#
	rates_sum = aggregate(tmprates[,4], by=list(tmprates[,1]), FUN=sum)#
	sums_by_i = cbind(rates_sum, probs_sum[,2])#
	names(sums_by_i) = c("i", "rates_sum", "probs_sum")#
	print(sums_by_i)#
	}#
# convert from 1-based to 0-based indices (turns out this is NOT needed for the C++ code)#
# transition_table_indices_C = transition_table_C[,1:3] - 1#
transition_table_indices_C = transition_table_rates_C_matrix[,1:3,1] - 1#
# transition_table_probs_C1 = transition_table_C[,4]#
transition_table_probs_C1 = transition_table_probs_C_matrix[,4,1]#
# Make the arrays for the parameters#
transition_matrix_C_array = array(data=0.0, dim=c(nrow(transition_table_indices_C), ncol(transition_table_indices_C), length(time_grid)))#
#
# Probs encoded in a num_clado_events * 2 * num_times array#
# the "2" just duplicates, ensures we have a 3D array#
transition_table_probs_C = array(data=0.0, dim=c(nrow(transition_table_indices_C), 2, length(time_grid)))#
#
# Fill in the transition_matrix_C and transition_table_probs#
for (i in 1:length(time_grid))#
	{#
	transition_matrix_C_array[,,i] = transition_table_indices_C#
	transition_table_probs_C[,1,i] = transition_table_probs_C_matrix[,4,i]#
	transition_table_probs_C[,2,i] = transition_table_probs_C_matrix[,4,i]#
	}
transition_table_probs_C
parameters = list(birth_rates         = 0.3,#
                  death_rates         = 0.0,#
                  transition_matrix_A = A,#
                  transition_matrix_C = transition_matrix_C_array,#
                  transition_table_indices_C = transition_table_indices_C,#
                  transition_table_probs_C = transition_table_probs_C_matrix )
transition_matrix_C_array
transition_table_indices_C
transition_matrix_C_array
transition_matrix_C = get_random_mk_transition_matrix(Nstates=4, rate_model="ER", max_rate=0.1)
transition_matrix_C
Carray
transition_matrix_C = array(data=0.0, dim=c(numstates,numstates,1))#
transition_matrix_C_array = array(data=0.0, dim=c(numstates,numstates,length(timegrid)))#
for (i in 1:length(time_grid))#
	{#
	for (j in 1:nrow(Carray))#
		{#
		transition_matrix_C_array[Carray$i[j],Carray$j[j],i] += Crates_by_t[j,i]#
		transition_matrix_C_array[Carray$i[j],Carray$k[j],i] += Crates_by_t[j,i]#
		# Ignore, rates are already doubled if needed#
		# if (Carray$i[j] != Carray$j[j])#
		}#
	# Set the diagonal#
	diag(transition_matrix_C_array[,,i]) = 0.0#
	diag(transition_matrix_C_array[,,i]) = -rowSums(transition_matrix_C_array[,,i])#
	}#
transition_matrix_C = transition_matrix_C_array[,,dim(transition_matrix_C_array)[3]]
transition_matrix_C = array(data=0.0, dim=c(numstates,numstates,1))#
transition_matrix_C_array = array(data=0.0, dim=c(numstates,numstates,length(timegrid)))
transition_matrix_C = array(data=0.0, dim=c(numstates,numstates,1))#
transition_matrix_C_array = array(data=0.0, dim=c(numstates,numstates,length(time_grid)))#
for (i in 1:length(time_grid))#
	{#
	for (j in 1:nrow(Carray))#
		{#
		transition_matrix_C_array[Carray$i[j],Carray$j[j],i] += Crates_by_t[j,i]#
		transition_matrix_C_array[Carray$i[j],Carray$k[j],i] += Crates_by_t[j,i]#
		# Ignore, rates are already doubled if needed#
		# if (Carray$i[j] != Carray$j[j])#
		}#
	# Set the diagonal#
	diag(transition_matrix_C_array[,,i]) = 0.0#
	diag(transition_matrix_C_array[,,i]) = -rowSums(transition_matrix_C_array[,,i])#
	}#
transition_matrix_C = transition_matrix_C_array[,,dim(transition_matrix_C_array)[3]]
transition_matrix_C = array(data=0.0, dim=c(numstates,numstates,1))#
transition_matrix_C_array = array(data=0.0, dim=c(numstates,numstates,length(time_grid)))
i=1
transition_matrix_C_array[Carray$i[j],Carray$j[j],i] += Crates_by_t[j,i]#
		transition_matrix_C_array[Carray$i[j],Carray$k[j],i] += Crates_by_t[j,i]
transition_matrix_C_array[Carray$i[j],Carray$j[j],i]
transition_matrix_C_array[Carray$i[j],Carray$j[j],i]
Carray$i[j]
Carray
Carray$i
j
j=1
transition_matrix_C_array[Carray$i[j],Carray$j[j],i] += Crates_by_t[j,i]#
		transition_matrix_C_array[Carray$i[j],Carray$k[j],i] += Crates_by_t[j,i]
transition_matrix_C_array[Carray$i[j],Carray$j[j],i]
Crates_by_t[j,i]
transition_matrix_C = array(data=0.0, dim=c(numstates,numstates,1))#
transition_matrix_C_array = array(data=0.0, dim=c(numstates,numstates,length(time_grid)))#
for (i in 1:length(time_grid))#
	{#
	for (j in 1:nrow(Carray))#
		{#
		transition_matrix_C_array[Carray$i[j],Carray$j[j],i] = transition_matrix_C_array[Carray$i[j],Carray$j[j],i] + Crates_by_t[j,i]#
		transition_matrix_C_array[Carray$i[j],Carray$k[j],i] = transition_matrix_C_array[Carray$i[j],Carray$k[j],i] + Crates_by_t[j,i]#
		# Ignore, rates are already doubled if needed#
		# if (Carray$i[j] != Carray$j[j])#
		}#
	# Set the diagonal#
	diag(transition_matrix_C_array[,,i]) = 0.0#
	diag(transition_matrix_C_array[,,i]) = -rowSums(transition_matrix_C_array[,,i])#
	}#
transition_matrix_C = transition_matrix_C_array[,,dim(transition_matrix_C_array)[3]]
transition_matrix_C_array
transition_table_C = NULL#
transrates_table_C = NULL#
transition_table_probs_C_matrix = array(data=0.0, dim=c(nrow(Crates_by_t), 4, length(time_grid)))#
transition_table_rates_C_matrix = array(data=0.0, dim=c(nrow(Crates_by_t), 4, length(time_grid)))#
dim(transition_table_probs_C_matrix)#
dim(transition_table_rates_C_matrix)#
#
rates_sums_by_t = NULL
for (i in 1:length(time_grid))#
	{#
	tmprates = as.data.frame(cbind(Carray$i, Carray$j, Carray$k, Crates_by_t[,i]), stringsAsFactors=FALSE)#
	names(tmprates) = c("i", "j", "k", "rates_t")#
	# Convert rates to probabilities#
	rates_sums = aggregate(tmprates$rates_t, by=list(tmprates$i), FUN=sum)#
	# Column names#
	names(rates_sums) = c("i", "rates_sum")#
	# Make sure rates_sums are ordered by 'i' (ancestral state index)#
	tmporder = order(rates_sums$i)#
	rates_sums = rates_sums[tmporder,]#
	# Check for null range; add row for "i" if needed#
	if (rates_sums$i[1] == 2)#
		{#
		tmprow = as.data.frame(matrix(data=c(1,0.0), nrow=1), stringsAsFactors=FALSE)#
		names(tmprow) = c("i", "rates_sum")#
		rates_sums = rbind(tmprow, rates_sums)#
		}#
	rates_sums_by_t	= cbind(rates_sums_by_t, rates_sums$rates_sum)#
#
	# Convert rates to probabilities#
	tmpprobs = tmprates#
	names(tmpprobs) = c("i", "j", "k", "probs_t")#
	for (q in 1:nrow(rates_sums))#
		{#
		tmpi = rates_sums$i[q]#
		TF = tmprates$i == tmpi#
#
		tmpprobs$probs_t[TF] = tmprates$rates_t[TF] / rates_sums$rates_sum[q]#
		}#
	transition_table_rates_C_matrix[,,i] = as.matrix(tmprates)#
	transition_table_probs_C_matrix[,,i] = as.matrix(tmpprobs)#
	}
transition_matrix_C_array
transition_table_C = NULL#
transrates_table_C = NULL#
transition_table_probs_C_matrix = array(data=0.0, dim=c(nrow(Crates_by_t), 4, length(time_grid)))#
transition_table_rates_C_matrix = array(data=0.0, dim=c(nrow(Crates_by_t), 4, length(time_grid)))#
dim(transition_table_probs_C_matrix)#
dim(transition_table_rates_C_matrix)
rates_sums_by_t = NULL#
for (i in 1:length(time_grid))#
	{#
	tmprates = as.data.frame(cbind(Carray$i, Carray$j, Carray$k, Crates_by_t[,i]), stringsAsFactors=FALSE)#
	names(tmprates) = c("i", "j", "k", "rates_t")#
	# Convert rates to probabilities#
	rates_sums = aggregate(tmprates$rates_t, by=list(tmprates$i), FUN=sum)#
	# Column names#
	names(rates_sums) = c("i", "rates_sum")#
	# Make sure rates_sums are ordered by 'i' (ancestral state index)#
	tmporder = order(rates_sums$i)#
	rates_sums = rates_sums[tmporder,]#
	# Check for null range; add row for "i" if needed#
	if (rates_sums$i[1] == 2)#
		{#
		tmprow = as.data.frame(matrix(data=c(1,0.0), nrow=1), stringsAsFactors=FALSE)#
		names(tmprow) = c("i", "rates_sum")#
		rates_sums = rbind(tmprow, rates_sums)#
		}#
	rates_sums_by_t	= cbind(rates_sums_by_t, rates_sums$rates_sum)#
#
	# Convert rates to probabilities#
	tmpprobs = tmprates#
	names(tmpprobs) = c("i", "j", "k", "probs_t")#
	for (q in 1:nrow(rates_sums))#
		{#
		tmpi = rates_sums$i[q]#
		TF = tmprates$i == tmpi#
#
		tmpprobs$probs_t[TF] = tmprates$rates_t[TF] / rates_sums$rates_sum[q]#
		}#
	transition_table_rates_C_matrix[,,i] = as.matrix(tmprates)#
	transition_table_probs_C_matrix[,,i] = as.matrix(tmpprobs)#
	}
for (i in 1:length(time_grid))#
	{#
	tmpprobs = transition_table_probs_C_matrix[,,i]#
	probs_sum = aggregate(tmpprobs[,4], by=list(tmpprobs[,1]), FUN=sum)#
	tmprates = transition_table_rates_C_matrix[,,i]#
	rates_sum = aggregate(tmprates[,4], by=list(tmprates[,1]), FUN=sum)#
	sums_by_i = cbind(rates_sum, probs_sum[,2])#
	names(sums_by_i) = c("i", "rates_sum", "probs_sum")#
	print(sums_by_i)#
	}
transition_table_indices_C = transition_table_rates_C_matrix[,1:3,1] - 1#
# transition_table_probs_C1 = transition_table_C[,4]#
transition_table_probs_C1 = transition_table_probs_C_matrix[,4,1]
transition_matrix_C_array
dim9transition_matrix_C_array)
dim(transition_matrix_C_array)
transition_matrix_C_array
rates_sums_by_t
transition_table_probs_C
transition_table_indices_C
transition_table_rates_C_matrix
array(transition_table_indices_C = transition_table_rates_C_matrix[,1:3,1] - 1#
transition_table_indices_C_matrix = array(data=transition_table_indices_C, dim=c(dim(transition_table_indices_C),length(time_grid)))
transition_table_indices_C = transition_table_rates_C_matrix[,1:3,1] - 1#
transition_table_indices_C_matrix = array(data=transition_table_indices_C, dim=c(dim(transition_table_indices_C),length(time_grid)))
transition_table_indices_C_matrix
transition_table_indices_C
for (i in 1:length(time_grid))#
	{#
	tmpprobs = transition_table_probs_C_matrix[,,i]#
	probs_sum = aggregate(tmpprobs[,4], by=list(tmpprobs[,1]), FUN=sum)#
	tmprates = transition_table_rates_C_matrix[,,i]#
	rates_sum = aggregate(tmprates[,4], by=list(tmprates[,1]), FUN=sum)#
	sums_by_i = cbind(rates_sum, probs_sum[,2])#
	names(sums_by_i) = c("i", "rates_sum", "probs_sum")#
	print(sums_by_i)#
	}#
# convert from 1-based to 0-based indices (turns out this is NOT needed for the C++ code)#
# transition_table_indices_C = transition_table_C[,1:3] - 1#
transition_table_indices_C = transition_table_rates_C_matrix[,1:3,1] - 1#
transition_table_indices_C_matrix = array(data=transition_table_indices_C, dim=c(dim(transition_table_indices_C),length(time_grid)))#
# transition_table_probs_C1 = transition_table_C[,4]#
transition_table_probs_C1 = transition_table_probs_C_matrix[,4,1]
# Make the arrays for the parameters#
#
# Probs encoded in a num_clado_events * 2 * num_times array#
# the "2" just duplicates, ensures we have a 3D array#
transition_table_probs_C = array(data=0.0, dim=c(nrow(transition_table_indices_C), 2, length(time_grid)))#
#
# Fill in the transition_matrix_C and transition_table_probs#
for (i in 1:length(time_grid))#
	{#
	transition_table_probs_C[,1,i] = transition_table_probs_C_matrix[,4,i]#
	transition_table_probs_C[,2,i] = transition_table_probs_C_matrix[,4,i]#
	}#
parameters = list(birth_rates         = rates_sums_by_t,#
                  death_rates         = 0.0,#
                  transition_matrix_A = A,#
                  transition_matrix_C = transition_matrix_C_array,#
                  transition_table_indices_C = transition_table_indices_C,#
                  transition_table_probs_C = transition_table_probs_C )
transition_table_indices_C
transition_table_probs_C
parameters = list(birth_rates         = rates_sums_by_t,#
                  death_rates         = 0.0,#
                  transition_matrix_A = A,#
                  transition_matrix_C = transition_matrix_C_array,#
                  transition_table_indices_C = transition_table_indices_C_matrix,#
                  transition_table_probs_C = transition_table_probs_C )
simulation = simulate_tdsse2( Nstates = numstates, #
                            parameters = parameters, #
														splines_degree      = 1,#
                            start_state = 2,#
                            max_tips = 50,#
                            time_grid = time_grid,#
                            include_birth_times=TRUE,#
                            include_death_times=TRUE,#
                            coalescent=FALSE)
numstates = 8#
wd = "/GitHub/PhyBEARS.jl/ex/siminf_v12a/"#
setwd(wd)#
outfns = c(#
"timepoints.txt", #
"mu_vals_by_t.txt",#
"Qvals_by_t.txt",#
"Crates_by_t.txt",#
"Qarray.txt",#
"Carray.txt")#
# Set the random number seed, to make it repeatable#
set.seed(54321)#
# Set the max_simulation time -- whatever changing distances you have will be#
# extended with this timepoint, i.e. the final geography/rates will continue#
# to this timepoint#
max_simulation_time = NULL#
max_simulation_time = 100.0#
# Read timepoints#
# Read in Q/A matrix, populate one and array#
# Read in C matrix, populate one and array#
#
# Load the files#
#time_grid = seq(0,10,0.1) # About halfway through#
time_grid = c(read.table(outfns[1], header=FALSE))[[1]]#
# Change from time reading backwards to time reading forwards#
colnums = rev(1:length(time_grid))#
time_grid = -1*(max(time_grid) - time_grid) - min(-1*(max(time_grid) - time_grid))#
time_grid#
mu_vals_by_t = as.matrix(read.table(outfns[2], header=FALSE))[,colnums]#
Qvals_by_t = as.matrix(read.table(outfns[3], header=FALSE))[,colnums]#
Crates_by_t = as.matrix(read.table(outfns[4], header=FALSE))[,colnums]#
Qarray = read.table(outfns[5], header=TRUE)#
Carray = read.table(outfns[6], header=TRUE)#
#
# Add the final time at end of forward simulation, if needed#
if (is.null(max_simulation_time) == FALSE)#
	{#
	time_grid = c(time_grid, max_simulation_time)#
	mu_vals_by_t = cbind(mu_vals_by_t, mu_vals_by_t[,ncol(mu_vals_by_t)])#
	Qvals_by_t = cbind(Qvals_by_t, Qvals_by_t[,ncol(Qvals_by_t)])#
	Crates_by_t = cbind(Crates_by_t, Crates_by_t[,ncol(Crates_by_t)])#
	}#
# Produce the A transition matrix / array#
A = array(data=0.0, dim=c(numstates,numstates,length(time_grid)))#
for (i in 1:length(time_grid))#
	{#
	for (j in 1:nrow(Qarray))#
		{#
		A[Qarray$i[j],Qarray$j[j],i] = Qvals_by_t[j,i]#
		}#
	# Set the diagonal#
	diag(A[,,i]) = 0.0#
	diag(A[,,i]) = -rowSums(A[,,i])#
	}#
#
# All rows in A sum to 0.0!#
round(apply(X=A, MARGIN=3, rowSums), digits=10)#
transition_matrix_C = array(data=0.0, dim=c(numstates,numstates,1))#
transition_matrix_C_array = array(data=0.0, dim=c(numstates,numstates,length(time_grid)))#
for (i in 1:length(time_grid))#
	{#
	for (j in 1:nrow(Carray))#
		{#
		transition_matrix_C_array[Carray$i[j],Carray$j[j],i] = transition_matrix_C_array[Carray$i[j],Carray$j[j],i] + Crates_by_t[j,i]#
		transition_matrix_C_array[Carray$i[j],Carray$k[j],i] = transition_matrix_C_array[Carray$i[j],Carray$k[j],i] + Crates_by_t[j,i]#
		# Ignore, rates are already doubled if needed#
		# if (Carray$i[j] != Carray$j[j])#
		}#
	# DO NOT set the diagonal on the cladogenetic transition rates#
	#diag(transition_matrix_C_array[,,i]) = 0.0#
	#diag(transition_matrix_C_array[,,i]) = -rowSums(transition_matrix_C_array[,,i])#
	}#
transition_matrix_C = transition_matrix_C_array[,,dim(transition_matrix_C_array)[3]]#
#
ignore = '#
A = get_random_mk_transition_matrix(Nstates=numstates, rate_model="ER", max_rate=0.1)#
#
# Make it more like a DEC model (anagenetic)#
d_rate = 0.06 # range expansion#
e_rate = 0.01 # range contraction#
#
# 4 states are:#
# null, A, B, AB#
A[,] = 0#
A[2,4] = d_rate # A->AB#
A[3,4] = d_rate # B->AB#
A[2,1] = e_rate # A->null#
A[3,1] = e_rate # B->null#
A[4,2] = e_rate # AB->A#
A[4,3] = e_rate # AB->B#
A#
#
# In Q transition matrices, the diagonals = -sum(off-diagonal for that row)#
diag(A) = 0.0#
A#
diag(A) = -rowSums(A)#
A#
' # END Ignore#
#
# Cladogenetic part of the DEC model#
# At speciation, we have:#
# Specify probabilities of different events, given that speciation has occurred#
# (ADD THESE UP to provide the speciation rates / lambdas)#
#
# transition_table_C: columns are i, j, k, prob#
# transrates_table_C: columns are i, j, k, rate # (later, we will add up these rates to get the total lambda by state)#
transition_table_C = NULL#
transrates_table_C = NULL#
transition_table_probs_C_matrix = array(data=0.0, dim=c(nrow(Crates_by_t), 4, length(time_grid)))#
transition_table_rates_C_matrix = array(data=0.0, dim=c(nrow(Crates_by_t), 4, length(time_grid)))#
dim(transition_table_probs_C_matrix)#
dim(transition_table_rates_C_matrix)#
#
rates_sums_by_t = NULL#
for (i in 1:length(time_grid))#
	{#
	tmprates = as.data.frame(cbind(Carray$i, Carray$j, Carray$k, Crates_by_t[,i]), stringsAsFactors=FALSE)#
	names(tmprates) = c("i", "j", "k", "rates_t")#
	# Convert rates to probabilities#
	rates_sums = aggregate(tmprates$rates_t, by=list(tmprates$i), FUN=sum)#
	# Column names#
	names(rates_sums) = c("i", "rates_sum")#
	# Make sure rates_sums are ordered by 'i' (ancestral state index)#
	tmporder = order(rates_sums$i)#
	rates_sums = rates_sums[tmporder,]#
	# Check for null range; add row for "i" if needed#
	if (rates_sums$i[1] == 2)#
		{#
		tmprow = as.data.frame(matrix(data=c(1,0.0), nrow=1), stringsAsFactors=FALSE)#
		names(tmprow) = c("i", "rates_sum")#
		rates_sums = rbind(tmprow, rates_sums)#
		}#
	rates_sums_by_t	= cbind(rates_sums_by_t, rates_sums$rates_sum)#
#
	# Convert rates to probabilities#
	tmpprobs = tmprates#
	names(tmpprobs) = c("i", "j", "k", "probs_t")#
	for (q in 1:nrow(rates_sums))#
		{#
		tmpi = rates_sums$i[q]#
		TF = tmprates$i == tmpi#
#
		tmpprobs$probs_t[TF] = tmprates$rates_t[TF] / rates_sums$rates_sum[q]#
		}#
	transition_table_rates_C_matrix[,,i] = as.matrix(tmprates)#
	transition_table_probs_C_matrix[,,i] = as.matrix(tmpprobs)#
	}#
# Check probs#
for (i in 1:length(time_grid))#
	{#
	tmpprobs = transition_table_probs_C_matrix[,,i]#
	probs_sum = aggregate(tmpprobs[,4], by=list(tmpprobs[,1]), FUN=sum)#
	tmprates = transition_table_rates_C_matrix[,,i]#
	rates_sum = aggregate(tmprates[,4], by=list(tmprates[,1]), FUN=sum)#
	sums_by_i = cbind(rates_sum, probs_sum[,2])#
	names(sums_by_i) = c("i", "rates_sum", "probs_sum")#
	print(sums_by_i)#
	}#
# convert from 1-based to 0-based indices (turns out this is NOT needed for the C++ code)#
# transition_table_indices_C = transition_table_C[,1:3] - 1#
transition_table_indices_C = transition_table_rates_C_matrix[,1:3,1] - 1#
transition_table_indices_C_matrix = array(data=transition_table_indices_C, dim=c(dim(transition_table_indices_C),length(time_grid)))#
# transition_table_probs_C1 = transition_table_C[,4]#
transition_table_probs_C1 = transition_table_probs_C_matrix[,4,1]#
# Make the arrays for the parameters#
#
# Probs encoded in a num_clado_events * 2 * num_times array#
# the "2" just duplicates, ensures we have a 3D array#
transition_table_probs_C = array(data=0.0, dim=c(nrow(transition_table_indices_C), 2, length(time_grid)))#
#
# Fill in the transition_matrix_C and transition_table_probs#
for (i in 1:length(time_grid))#
	{#
	transition_table_probs_C[,1,i] = transition_table_probs_C_matrix[,4,i]#
	transition_table_probs_C[,2,i] = transition_table_probs_C_matrix[,4,i]#
	}#
parameters = list(birth_rates         = rates_sums_by_t,#
                  death_rates         = 0.0,#
                  transition_matrix_A = A,#
                  transition_matrix_C = transition_matrix_C_array,#
                  transition_table_indices_C = transition_table_indices_C_matrix,#
                  transition_table_probs_C = transition_table_probs_C )#
simulation = simulate_tdsse2( Nstates = numstates, #
                            parameters = parameters, #
														splines_degree      = 1,#
                            start_state = 2,#
                            max_tips = 50,#
                            time_grid = time_grid,#
                            include_birth_times=TRUE,#
                            include_death_times=TRUE,#
                            coalescent=FALSE)
transition_matrix_C = array(data=0.0, dim=c(numstates,numstates,1))#
transition_matrix_C_array = array(data=0.0, dim=c(numstates,numstates,length(time_grid)))#
for (i in 1:length(time_grid))#
	{#
	for (j in 1:nrow(Carray))#
		{#
		transition_matrix_C_array[Carray$i[j],Carray$j[j],i] = transition_table_probs_C_matrix[Carray$i[j],Carray$j[j],i] + Crates_by_t[j,i]#
		transition_matrix_C_array[Carray$i[j],Carray$k[j],i] = transition_table_probs_C_matrix[Carray$i[j],Carray$k[j],i] + Crates_by_t[j,i]#
		# Ignore, rates are already doubled if needed#
		# if (Carray$i[j] != Carray$j[j])#
		}#
	# DO NOT set the diagonal on the cladogenetic transition rates#
	#diag(transition_matrix_C_array[,,i]) = 0.0#
	#diag(transition_matrix_C_array[,,i]) = -rowSums(transition_matrix_C_array[,,i])#
	}#
transition_matrix_C = transition_matrix_C_array[,,dim(transition_matrix_C_array)[3]]
transition_table_probs_C_matrix
Cprobs_by_t
Carray$i[j]
rates_sums_by_t
# Square transition matrix (not used, but sanity check)#
transition_matrix_C = array(data=0.0, dim=c(numstates,numstates,1))#
transition_matrix_C_array = array(data=0.0, dim=c(numstates,numstates,length(time_grid)))#
for (i in 1:length(time_grid))#
	{#
	for (j in 1:nrow(Carray))#
		{#
		transition_matrix_C_array[Carray$i[j],Carray$j[j],i] = transition_matrix_C_array[Carray$i[j],Carray$j[j],i] + Cprobs_by_t[j,i] / rates_sums_by_t[Carray$i,i]#
		transition_matrix_C_array[Carray$i[j],Carray$k[j],i] = transition_matrix_C_array[Carray$i[j],Carray$k[j],i] + Cprobs_by_t[j,i] / rates_sums_by_t[Carray$i,i]#
		# Ignore, rates are already doubled if needed#
		# if (Carray$i[j] != Carray$j[j])#
		}#
	# DO NOT set the diagonal on the cladogenetic transition rates#
	#diag(transition_matrix_C_array[,,i]) = 0.0#
	#diag(transition_matrix_C_array[,,i]) = -rowSums(transition_matrix_C_array[,,i])#
	}#
transition_matrix_C = transition_matrix_C_array[,,dim(transition_matrix_C_array)[3]]#
transition_matrix_C
transition_matrix_C = array(data=0.0, dim=c(numstates,numstates,1))#
transition_matrix_C_array = array(data=0.0, dim=c(numstates,numstates,length(time_grid)))#
for (i in 1:length(time_grid))#
	{#
	for (j in 1:nrow(Carray))#
		{#
		transition_matrix_C_array[Carray$i[j],Carray$j[j],i] = transition_matrix_C_array[Carray$i[j],Carray$j[j],i] + Crates_by_t[j,i] / rates_sums_by_t[Carray$i,i]#
		transition_matrix_C_array[Carray$i[j],Carray$k[j],i] = transition_matrix_C_array[Carray$i[j],Carray$k[j],i] + Crates_by_t[j,i] / rates_sums_by_t[Carray$i,i]#
		# Ignore, rates are already doubled if needed#
		# if (Carray$i[j] != Carray$j[j])#
		}#
	# DO NOT set the diagonal on the cladogenetic transition rates#
	#diag(transition_matrix_C_array[,,i]) = 0.0#
	#diag(transition_matrix_C_array[,,i]) = -rowSums(transition_matrix_C_array[,,i])#
	}#
transition_matrix_C = transition_matrix_C_array[,,dim(transition_matrix_C_array)[3]]#
transition_matrix_C
transition_matrix_C_array
i
j
transition_matrix_C_array[Carray$i[j],Carray$j[j],i] = transition_matrix_C_array[Carray$i[j],Carray$j[j],i] + Crates_by_t[j,i] / rates_sums_by_t[Carray$i,i]
transition_matrix_C_array[Carray$i[j],Carray$j[j],i]
Crates_by_t[j,i]
j
Crates_by_t
Carray
rates_sums_by_t[Carray$i,i]
rates_sums_by_t
rates_sums_by_t[,i]
transition_matrix_C = array(data=0.0, dim=c(numstates,numstates,1))#
transition_matrix_C_array = array(data=0.0, dim=c(numstates,numstates,length(time_grid)))#
for (i in 1:length(time_grid))#
	{#
	for (j in 1:nrow(Carray))#
		{#
		transition_matrix_C_array[Carray$i[j],Carray$j[j],i] = transition_matrix_C_array[Carray$i[j],Carray$j[j],i] + Crates_by_t[j,i] / rates_sums_by_t[Carray$i[j],i]#
		transition_matrix_C_array[Carray$i[j],Carray$k[j],i] = transition_matrix_C_array[Carray$i[j],Carray$k[j],i] + Crates_by_t[j,i] / rates_sums_by_t[Carray$i[j],i]#
		# Ignore, rates are already doubled if needed#
		# if (Carray$i[j] != Carray$j[j])#
		}#
	# DO NOT set the diagonal on the cladogenetic transition rates#
	#diag(transition_matrix_C_array[,,i]) = 0.0#
	#diag(transition_matrix_C_array[,,i]) = -rowSums(transition_matrix_C_array[,,i])#
	}#
transition_matrix_C = transition_matrix_C_array[,,dim(transition_matrix_C_array)[3]]#
transition_matrix_C
rowSums(transition_matrix_C)
Carray
transition_matrix_C = array(data=0.0, dim=c(numstates,numstates,1))#
transition_matrix_C_array = array(data=0.0, dim=c(numstates,numstates,length(time_grid)))#
for (i in 1:length(time_grid))#
	{#
	for (j in 1:nrow(Carray))#
		{#
		if (Carray$i[j] == Carray$j[j])#
			{#
			transition_matrix_C_array[Carray$i[j],Carray$j[j],i] = transition_matrix_C_array[Carray$i[j],Carray$j[j],i] + Crates_by_t[j,i] / rates_sums_by_t[Carray$i[j],i] / 2#
			} else {#
			transition_matrix_C_array[Carray$i[j],Carray$j[j],i] = transition_matrix_C_array[Carray$i[j],Carray$j[j],i] + Crates_by_t[j,i] / rates_sums_by_t[Carray$i[j],i]#
			transition_matrix_C_array[Carray$i[j],Carray$k[j],i] = transition_matrix_C_array[Carray$i[j],Carray$k[j],i] + Crates_by_t[j,i] / rates_sums_by_t[Carray$i[j],i] / 2#
			}#
		# Ignore, rates are already doubled if needed#
		# if (Carray$i[j] != Carray$j[j])#
		}#
	# DO NOT set the diagonal on the cladogenetic transition rates#
	#diag(transition_matrix_C_array[,,i]) = 0.0#
	#diag(transition_matrix_C_array[,,i]) = -rowSums(transition_matrix_C_array[,,i])#
	}#
transition_matrix_C = transition_matrix_C_array[,,dim(transition_matrix_C_array)[3]]#
transition_matrix_C
transition_matrix_C = array(data=0.0, dim=c(numstates,numstates,1))#
transition_matrix_C_array = array(data=0.0, dim=c(numstates,numstates,length(time_grid)))#
for (i in 1:length(time_grid))#
	{#
	for (j in 1:nrow(Carray))#
		{#
		if (Carray$i[j] == Carray$j[j])#
			{#
			transition_matrix_C_array[Carray$i[j],Carray$j[j],i] = transition_matrix_C_array[Carray$i[j],Carray$j[j],i] + Crates_by_t[j,i] / rates_sums_by_t[Carray$i[j],i]#
			} else {#
			transition_matrix_C_array[Carray$i[j],Carray$j[j],i] = transition_matrix_C_array[Carray$i[j],Carray$j[j],i] + Crates_by_t[j,i] / rates_sums_by_t[Carray$i[j],i] / 2#
			transition_matrix_C_array[Carray$i[j],Carray$k[j],i] = transition_matrix_C_array[Carray$i[j],Carray$k[j],i] + Crates_by_t[j,i] / rates_sums_by_t[Carray$i[j],i] / 2#
			}#
		# Ignore, rates are already doubled if needed#
		# if (Carray$i[j] != Carray$j[j])#
		}#
	# DO NOT set the diagonal on the cladogenetic transition rates#
	#diag(transition_matrix_C_array[,,i]) = 0.0#
	#diag(transition_matrix_C_array[,,i]) = -rowSums(transition_matrix_C_array[,,i])#
	}#
transition_matrix_C = transition_matrix_C_array[,,dim(transition_matrix_C_array)[3]]#
transition_matrix_C
rowSums(transition_matrix_C)
# Square transition matrix (not used, but sanity check)#
transition_matrix_C = array(data=0.0, dim=c(numstates,numstates,1))#
transition_matrix_C_array = array(data=0.0, dim=c(numstates,numstates,length(time_grid)))#
for (i in 1:length(time_grid))#
	{#
	for (j in 1:nrow(Carray))#
		{#
		if (Carray$i[j] == Carray$j[j])#
			{#
			transition_matrix_C_array[Carray$i[j],Carray$j[j],i] = transition_matrix_C_array[Carray$i[j],Carray$j[j],i] + Crates_by_t[j,i] / rates_sums_by_t[Carray$i[j],i]#
			} else {#
			transition_matrix_C_array[Carray$i[j],Carray$j[j],i] = transition_matrix_C_array[Carray$i[j],Carray$j[j],i] + Crates_by_t[j,i] / rates_sums_by_t[Carray$i[j],i] / 2#
			transition_matrix_C_array[Carray$i[j],Carray$k[j],i] = transition_matrix_C_array[Carray$i[j],Carray$k[j],i] + Crates_by_t[j,i] / rates_sums_by_t[Carray$i[j],i] / 2#
			}#
		# Ignore, rates are already doubled if needed#
		# if (Carray$i[j] != Carray$j[j])#
		}#
	# DO NOT set the diagonal on the cladogenetic transition rates#
	#diag(transition_matrix_C_array[,,i]) = 0.0#
	#diag(transition_matrix_C_array[,,i]) = -rowSums(transition_matrix_C_array[,,i])#
#
	# Null range correction#
	if (rowSums(transition_matrix_C_array[,,i])[1] = 0.0)#
		{#
		transition_matrix_C_array[1,1,i] = 1.0#
		}#
	}#
transition_matrix_C = transition_matrix_C_array[,,dim(transition_matrix_C_array)[3]]#
transition_matrix_C#
rowSums(transition_matrix_C)
# Square transition matrix (not used, but sanity check)#
transition_matrix_C = array(data=0.0, dim=c(numstates,numstates,1))#
transition_matrix_C_array = array(data=0.0, dim=c(numstates,numstates,length(time_grid)))#
for (i in 1:length(time_grid))#
	{#
	for (j in 1:nrow(Carray))#
		{#
		if (Carray$i[j] == Carray$j[j])#
			{#
			transition_matrix_C_array[Carray$i[j],Carray$j[j],i] = transition_matrix_C_array[Carray$i[j],Carray$j[j],i] + Crates_by_t[j,i] / rates_sums_by_t[Carray$i[j],i]#
			} else {#
			transition_matrix_C_array[Carray$i[j],Carray$j[j],i] = transition_matrix_C_array[Carray$i[j],Carray$j[j],i] + Crates_by_t[j,i] / rates_sums_by_t[Carray$i[j],i] / 2#
			transition_matrix_C_array[Carray$i[j],Carray$k[j],i] = transition_matrix_C_array[Carray$i[j],Carray$k[j],i] + Crates_by_t[j,i] / rates_sums_by_t[Carray$i[j],i] / 2#
			}#
		# Ignore, rates are already doubled if needed#
		# if (Carray$i[j] != Carray$j[j])#
		}#
	# DO NOT set the diagonal on the cladogenetic transition rates#
	#diag(transition_matrix_C_array[,,i]) = 0.0#
	#diag(transition_matrix_C_array[,,i]) = -rowSums(transition_matrix_C_array[,,i])#
#
	# Null range correction#
	if (rowSums(transition_matrix_C_array[,,i])[1] == 0.0)#
		{#
		transition_matrix_C_array[1,1,i] = 1.0#
		}#
	}#
transition_matrix_C = transition_matrix_C_array[,,dim(transition_matrix_C_array)[3]]#
transition_matrix_C#
rowSums(transition_matrix_C)
for (i in 1:length(time_grid))#
	{#
	tmpprobs = transition_table_probs_C_matrix[,,i]#
	probs_sum = aggregate(tmpprobs[,4], by=list(tmpprobs[,1]), FUN=sum)#
	tmprates = transition_table_rates_C_matrix[,,i]#
	rates_sum = aggregate(tmprates[,4], by=list(tmprates[,1]), FUN=sum)#
	sums_by_i = cbind(rates_sum, probs_sum[,2])#
	names(sums_by_i) = c("i", "rates_sum", "probs_sum")#
	print(sums_by_i)#
	}#
# convert from 1-based to 0-based indices (turns out this is NOT needed for the C++ code)#
# transition_table_indices_C = transition_table_C[,1:3] - 1#
transition_table_indices_C = transition_table_rates_C_matrix[,1:3,1] - 1#
transition_table_indices_C_matrix = array(data=transition_table_indices_C, dim=c(dim(transition_table_indices_C),length(time_grid)))#
# transition_table_probs_C1 = transition_table_C[,4]#
transition_table_probs_C1 = transition_table_probs_C_matrix[,4,1]#
# Make the arrays for the parameters#
#
# Probs encoded in a num_clado_events * 2 * num_times array#
# the "2" just duplicates, ensures we have a 3D array#
transition_table_probs_C = array(data=0.0, dim=c(nrow(transition_table_indices_C), 2, length(time_grid)))#
#
# Fill in the transition_matrix_C and transition_table_probs#
for (i in 1:length(time_grid))#
	{#
	transition_table_probs_C[,1,i] = transition_table_probs_C_matrix[,4,i]#
	transition_table_probs_C[,2,i] = transition_table_probs_C_matrix[,4,i]#
	}#
parameters = list(birth_rates         = rates_sums_by_t,#
                  death_rates         = 0.0,#
                  transition_matrix_A = A,#
                  transition_matrix_C = transition_matrix_C_array,#
                  transition_table_indices_C = transition_table_indices_C_matrix,#
                  transition_table_probs_C = transition_table_probs_C )
simulation = simulate_tdsse2( Nstates = numstates, #
                            parameters = parameters, #
														splines_degree      = 1,#
                            start_state = 2,#
                            max_tips = 50,#
                            time_grid = time_grid,#
                            include_birth_times=TRUE,#
                            include_death_times=TRUE,#
                            coalescent=FALSE)
transition_table_indices_C
transition_table_indices_C_matrix
transition_table_indices_C
parameters = list(birth_rates         = rates_sums_by_t,#
                  death_rates         = 0.0,#
                  transition_matrix_A = A,#
                  transition_matrix_C = transition_matrix_C_array,#
                  transition_table_indices_C = transition_table_indices_C,#
                  transition_table_probs_C = transition_table_probs_C )#
simulation = simulate_tdsse2( Nstates = numstates, #
                            parameters = parameters, #
														splines_degree      = 1,#
                            start_state = 2,#
                            max_tips = 50,#
                            time_grid = time_grid,#
                            include_birth_times=TRUE,#
                            include_death_times=TRUE,#
                            coalescent=FALSE)
simulation
