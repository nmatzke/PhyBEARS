Methods(seqs)
tmpdata_rownames = attr(tmpdata, "dimnames")[[1]]#
tmpdata_rownames
seqs_rownames = attr(seqs, "dimnames")[[1]]#
seqs_rownames
attributes(seqs)
names(attributes(seqs))
attr(seqs, "class")#
attr(seqs, "dim")
class(seqs)#
attr(seqs, "class")#
#
dim(seqs)#
attr(seqs, "dim")
seqs_as_strings = DNAbin_to_list_of_strings(tmpdata=seqs)#
seqs_as_strings[1]
source('/GitHub/bioinfRhints/R/_R_tree_functions_v2.R', chdir = TRUE)
source("/GitHub/bioinfRhints/R/_R_tree_functions_v2.R")#
seqs_as_strings = DNAbin_to_list_of_strings(tmpdata=seqs)
seqs_as_strings[1]
seqs_as_characters[[1]]
source("/GitHub/bioinfRhints/R/_R_tree_functions_v2.R")#
seqs_as_characters = DNAbin_to_list_of_strings(tmpdata=seqs)#
seqs_as_characters[[1]]
lapply(lapply(X=seqs_as_characters, FUN=paste0, collapse="")
lapply(X=seqs_as_characters, FUN=paste0, collapse="")
# Each base as an individual string#
seqs_txt = read.dna(file=seqs_fn, format="fasta", skip=0, as.character=TRUE)#
dim(seqs_txt)#
# 69 2033#
seqs_txt[1,]#
# Paste a sequence into a single string#
first_seq = paste0(seqs_txt[1,], collapse="")#
first_seq#
# Subset of text sequence#
substr(first_seq, start=100, stop=110)
substr(seqs_as_list_of_strings[[1]], start=100, stop=110)
seqs_as_list_of_strings = lapply(X=seqs_as_characters, FUN=paste0, collapse="")#
substr(seqs_as_list_of_strings[[1]], start=100, stop=110)
seqs_txt = read.dna(file=seqs_fn, format="fasta", skip=0, as.character=TRUE)#
dim(seqs_txt)#
# 69 2033#
seqs_txt[1,]#
# Paste a sequence into a single string#
first_seq = paste0(seqs_txt[1,], collapse="")#
first_seq#
# Subset of text sequence#
substr(first_seq, start=100, stop=110)
dist.dna
?dist.dna
distmat1 = dist.dna(x=seqs, model="K80", gamma=FALSE, as.matrix=TRUE)
dim(distmat1)
head(distmat1)
distmat[1:5, 1:5]
distmat1 = dist.dna(x=seqs, model="K80", gamma=FALSE, as.matrix=TRUE)#
dim(distmat1)#
distmat1[1:5,1:5]
library(ape)
?attr
tr
names(tr)
names(seqs)
names(tr)
tr$Nnode
tr$tip.label
names(seqs)
rownames(seqs)
attributes(seqs)
names(attributes(seqs))
for (i in 100)#
	{#
	print(i)#
	}
for (i in 1:100)#
	{#
	print(i)#
	}
########################################################
# 2022-09-15#
##
# 1. Read in a sequence alignment#
# 2. Construct a distance matrix#
##
########################################################
#
# Loading a tree, printing to tree table (trtable)#
library(ape)#
# Data: 18S, ITS1, 5.8S rRNA sequences from#
# X-cells (protist parasites of e.g. Antarctic fishes)#
# Provided by Craig Miller#
##
# Request: distance matrix#
#
seqs_fn = "/GitHub/bioinfRhints/data/seqs.fasta"#
#
# Same effect -- produces an APE "DNAbin" object (DNA in binary format for compactness/speed)#
seqs = read.FASTA(file=seqs_fn, type="DNA")#
seqs = read.dna(file=seqs_fn, format="fasta", skip=0, as.character=FALSE)#
# 69 DNA sequences in binary format stored in a matrix.#
# #
# All sequences of same length: 2033 #
# #
# Labels:#
# MT299786.1 Parvilucifera catillosa strain Kokar2016a isolate...#
# KX519761.1 Parvilucifera corolla strain Lanzarote isolate 3 ...#
# KF359483.1 Parvilucifera rostrata strain RCC2800 18S ribosom...#
# EU502912.1 Parvilucifera sinerae#
# KF359485.1 Parvilucifera infectans strain RCC2816 18S riboso...#
# AF133909.1 Parvilucifera infectans 18S ribosomal RNA gene, p...#
# ...#
# #
# Base composition:#
#     a     c     g     t #
# 0.269 0.198 0.259 0.275 #
# (Total: 140.28 kb)#
#
# What's inside of 'seqs'?#
#
# Gene/locus names, method #1:#
rownames(seqs)#
#
# Gene/locus names, method #2:#
seqs_rownames = attr(seqs, "dimnames")[[1]]#
seqs_rownames#
#
# What all is in a DNAbin object?#
names(attributes(seqs))#
# "dim"      "dimnames" "class"   #
#
# Alternate methods:#
class(seqs)#
attr(seqs, "class")#
#
dim(seqs)#
attr(seqs, "dim")#
# Each base as an individual string#
seqs_txt = read.dna(file=seqs_fn, format="fasta", skip=0, as.character=TRUE)#
dim(seqs_txt)#
# 69 2033#
seqs_txt[1,]#
# Paste a sequence into a single string#
first_seq = paste0(seqs_txt[1,], collapse="")#
first_seq#
# Subset of text sequence#
substr(first_seq, start=100, stop=110)#
# I have written some functions to process/convert DNAbin objects#
source("/GitHub/bioinfRhints/R/_R_tree_functions_v2.R")#
seqs_as_characters = DNAbin_to_list_of_strings(tmpdata=seqs)#
seqs_as_characters[[1]]#
#
# Collapse all sequences to strings#
seqs_as_list_of_strings = lapply(X=seqs_as_characters, FUN=paste0, collapse="")#
substr(seqs_as_list_of_strings[[1]], start=100, stop=110)#
########################################################
# OK, make the distance matrix#
########################################################
distmat1 = dist.dna(x=seqs, model="K80", gamma=FALSE, as.matrix=TRUE)#
dim(distmat1)#
distmat1[1:5,1:5]#
# Subset for the distance-matrix figure#
nms = c("KY628815",#
"KY628818",#
"KF911018",#
"EU878172",#
"GU296509",#
"KY628817",#
"AB112470",#
"AB451874",#
"OL630144",#
"OL630145",#
"GU296508",#
"KY628819",#
"MY743280",#
"MW743279",#
"MW743281",#
"MW743278",#
"Bork")
rownames(seqs)
grepl(pattern="3", x="123")
grepl(i=1#
positions_in_seqs = rep("", times=length(tmpnames))
tmpname = tmpnames[i]#
	hits_TF = sapply(X=rownames(seqs), FUN=grepl, pattern=tmpname, ignore.case=TRUE)
tmpnames = c("KY628815",#
"KY628818",#
"KF911018",#
"EU878172",#
"GU296509",#
"KY628817",#
"AB112470",#
"AB451874",#
"OL630144",#
"OL630145",#
"GU296508",#
"KY628819",#
"MY743280",#
"MW743279",#
"MW743281",#
"MW743278",#
"Bork")#
#
i=1#
positions_in_seqs = rep("", times=length(tmpnames))#
for (i in 1:length(tmpnames))#
'
tmpname = tmpnames[i]#
	hits_TF = sapply(X=rownames(seqs), FUN=grepl, pattern=tmpname, ignore.case=TRUE)
hits_TF
sum(hits_TF)
tmpnames = c("KY628815",#
"KY628818",#
"KF911018",#
"EU878172",#
"GU296509",#
"KY628817",#
"AB112470",#
"AB451874",#
"OL630144",#
"OL630145",#
"GU296508",#
"KY628819",#
"MY743280",#
"MW743279",#
"MW743281",#
"MW743278",#
"Bork")#
#
i=1#
positions_in_seqs = rep("", times=length(tmpnames))#
for (i in 1:length(tmpnames))#
	{#
	tmpname = tmpnames[i]#
	hits_TF = sapply(X=rownames(seqs), FUN=grepl, pattern=tmpname, ignore.case=TRUE)#
	if (sum(hits_TF) != 1)#
		{#
		stop("STOP ERROR: number of hits should be == 1")#
		}#
	positions_in_seqs[i] = (1:length(rownames(seqs)))[hits_TF]#
	}#
#
positions_in_seqs
tmpnames = c("KY628815",#
"KY628818",#
"KF911018",#
"EU878172",#
"GU296509",#
"KY628817",#
"AB112470",#
"AB451874",#
"OL630144",#
"OL630145",#
"GU296508",#
"KY628819",#
"MY743280",#
"MW743279",#
"MW743281",#
"MW743278",#
"Bork")#
#
i=1#
positions_in_seqs = rep(NA, times=length(tmpnames))#
for (i in 1:length(tmpnames))#
	{#
	tmpname = tmpnames[i]#
	hits_TF = sapply(X=rownames(seqs), FUN=grepl, pattern=tmpname, ignore.case=TRUE)#
	if (sum(hits_TF) != 1)#
		{#
		cat("\nSTOP ERROR: number of hits should be == 1. Non-match=\n")#
		print(tmpname)#
		}#
	positions_in_seqs[i] = (1:length(rownames(seqs)))[hits_TF]#
	}
tmpnames = c("KY628815",#
"KY628818",#
"KF911018",#
"EU878172",#
"GU296509",#
"KY628817",#
"AB112470",#
"AB451874",#
"OL630144",#
"OL630145",#
"GU296508",#
"KY628819",#
"MW743280",#
"MW743279",#
"MW743281",#
"MW743278",#
"Bork")#
#
i=1#
positions_in_seqs = rep(NA, times=length(tmpnames))#
for (i in 1:length(tmpnames))#
	{#
	tmpname = tmpnames[i]#
	hits_TF = sapply(X=rownames(seqs), FUN=grepl, pattern=tmpname, ignore.case=TRUE)#
	if (sum(hits_TF) != 1)#
		{#
		cat("\nSTOP ERROR: number of hits should be == 1. Non-match=\n")#
		print(tmpname)#
		}#
	positions_in_seqs[i] = (1:length(rownames(seqs)))[hits_TF]#
	}
positions_in_seqs
subset_distmat1 = distmat1[positions_in_seqs,positions_in_seqs]
subset_distmat1
pwd()
pwd
/drives/od/__GDrive_projects/2019-08-22_Craig_Millar_notho_fish/08_distance_matrixwrite.table(
outfn = "/drives/od/__GDrive_projects/2019-08-22_Craig_Millar_notho_fish/08_distance_matrix/Xcellidae_distmat_K80_subset.txt"#
write.table(x=subset_distmat1, file=outfn, sep="\t")
?dist.dna
distmat1 = dist.dna(x=seqs, model="raw", gamma=FALSE, as.matrix=TRUE)#
dim(distmat1)#
distmat1[1:5,1:5]#
i=1#
positions_in_seqs = rep(NA, times=length(tmpnames))#
for (i in 1:length(tmpnames))#
	{#
	tmpname = tmpnames[i]#
	hits_TF = sapply(X=rownames(seqs), FUN=grepl, pattern=tmpname, ignore.case=TRUE)#
	if (sum(hits_TF) != 1)#
		{#
		cat("\nSTOP ERROR: number of hits should be == 1. Non-match=\n")#
		print(tmpname)#
		}#
	positions_in_seqs[i] = (1:length(rownames(seqs)))[hits_TF]#
	}#
positions_in_seqs#
#
subset_distmat1 = distmat1[positions_in_seqs,positions_in_seqs]#
#
outfn = "/drives/od/__GDrive_projects/2019-08-22_Craig_Millar_notho_fish/08_distance_matrix/Xcellidae_distmat_raw_subset.txt"#
write.table(x=subset_distmat1, file=outfn, sep="\t")#
distmat1 = dist.dna(x=seqs, model="K80", gamma=FALSE, as.matrix=TRUE)#
dim(distmat1)#
distmat1[1:5,1:5]#
i=1#
positions_in_seqs = rep(NA, times=length(tmpnames))#
for (i in 1:length(tmpnames))#
	{#
	tmpname = tmpnames[i]#
	hits_TF = sapply(X=rownames(seqs), FUN=grepl, pattern=tmpname, ignore.case=TRUE)#
	if (sum(hits_TF) != 1)#
		{#
		cat("\nSTOP ERROR: number of hits should be == 1. Non-match=\n")#
		print(tmpname)#
		}#
	positions_in_seqs[i] = (1:length(rownames(seqs)))[hits_TF]#
	}#
positions_in_seqs#
#
subset_distmat1 = distmat1[positions_in_seqs,positions_in_seqs]#
#
outfn = "/drives/od/__GDrive_projects/2019-08-22_Craig_Millar_notho_fish/08_distance_matrix/Xcellidae_distmat_K80_subset.txt"#
write.table(x=subset_distmat1, file=outfn, sep="\t")#
distmat1 = dist.dna(x=seqs, model="K80", gamma=1, as.matrix=TRUE)#
dim(distmat1)#
distmat1[1:5,1:5]#
i=1#
positions_in_seqs = rep(NA, times=length(tmpnames))#
for (i in 1:length(tmpnames))#
	{#
	tmpname = tmpnames[i]#
	hits_TF = sapply(X=rownames(seqs), FUN=grepl, pattern=tmpname, ignore.case=TRUE)#
	if (sum(hits_TF) != 1)#
		{#
		cat("\nSTOP ERROR: number of hits should be == 1. Non-match=\n")#
		print(tmpname)#
		}#
	positions_in_seqs[i] = (1:length(rownames(seqs)))[hits_TF]#
	}#
positions_in_seqs#
#
subset_distmat1 = distmat1[positions_in_seqs,positions_in_seqs]#
#
outfn = "/drives/od/__GDrive_projects/2019-08-22_Craig_Millar_notho_fish/08_distance_matrix/Xcellidae_distmat_K80_subset_gamma1.txt"#
write.table(x=subset_distmat1, file=outfn, sep="\t")#
distmat1 = dist.dna(x=seqs, model="K80", gamma=2, as.matrix=TRUE)#
dim(distmat1)#
distmat1[1:5,1:5]#
i=1#
positions_in_seqs = rep(NA, times=length(tmpnames))#
for (i in 1:length(tmpnames))#
	{#
	tmpname = tmpnames[i]#
	hits_TF = sapply(X=rownames(seqs), FUN=grepl, pattern=tmpname, ignore.case=TRUE)#
	if (sum(hits_TF) != 1)#
		{#
		cat("\nSTOP ERROR: number of hits should be == 1. Non-match=\n")#
		print(tmpname)#
		}#
	positions_in_seqs[i] = (1:length(rownames(seqs)))[hits_TF]#
	}#
positions_in_seqs#
#
subset_distmat1 = distmat1[positions_in_seqs,positions_in_seqs]#
#
outfn = "/drives/od/__GDrive_projects/2019-08-22_Craig_Millar_notho_fish/08_distance_matrix/Xcellidae_distmat_K80_subset_gamma2.txt"#
write.table(x=subset_distmat1, file=outfn, sep="\t")#
distmat2 = dist.dna(x=seqs, model="TN93", gamma=FALSE, as.matrix=TRUE)#
dim(distmat1)#
distmat2[1:5,1:5]#
i=1#
positions_in_seqs = rep(NA, times=length(tmpnames))#
for (i in 1:length(tmpnames))#
	{#
	tmpname = tmpnames[i]#
	hits_TF = sapply(X=rownames(seqs), FUN=grepl, pattern=tmpname, ignore.case=TRUE)#
	if (sum(hits_TF) != 1)#
		{#
		cat("\nSTOP ERROR: number of hits should be == 1. Non-match=\n")#
		print(tmpname)#
		}#
	positions_in_seqs[i] = (1:length(rownames(seqs)))[hits_TF]#
	}#
positions_in_seqs#
#
subset_distmat1 = distmat1[positions_in_seqs,positions_in_seqs]#
#
outfn = "/drives/od/__GDrive_projects/2019-08-22_Craig_Millar_notho_fish/08_distance_matrix/Xcellidae_distmat_TN93_subset.txt"#
write.table(x=subset_distmat1, file=outfn, sep="\t")#
distmat2 = dist.dna(x=seqs, model="TN93", gamma=0.5, as.matrix=TRUE)#
dim(distmat1)#
distmat2[1:5,1:5]#
i=1#
positions_in_seqs = rep(NA, times=length(tmpnames))#
for (i in 1:length(tmpnames))#
	{#
	tmpname = tmpnames[i]#
	hits_TF = sapply(X=rownames(seqs), FUN=grepl, pattern=tmpname, ignore.case=TRUE)#
	if (sum(hits_TF) != 1)#
		{#
		cat("\nSTOP ERROR: number of hits should be == 1. Non-match=\n")#
		print(tmpname)#
		}#
	positions_in_seqs[i] = (1:length(rownames(seqs)))[hits_TF]#
	}#
positions_in_seqs#
#
subset_distmat1 = distmat1[positions_in_seqs,positions_in_seqs]#
#
outfn = "/drives/od/__GDrive_projects/2019-08-22_Craig_Millar_notho_fish/08_distance_matrix/Xcellidae_distmat_TN93_subset_gamma0.5.txt"#
write.table(x=subset_distmat1, file=outfn, sep="\t")#
distmat2 = dist.dna(x=seqs, model="TN93", gamma=1, as.matrix=TRUE)#
dim(distmat1)#
distmat2[1:5,1:5]#
i=1#
positions_in_seqs = rep(NA, times=length(tmpnames))#
for (i in 1:length(tmpnames))#
	{#
	tmpname = tmpnames[i]#
	hits_TF = sapply(X=rownames(seqs), FUN=grepl, pattern=tmpname, ignore.case=TRUE)#
	if (sum(hits_TF) != 1)#
		{#
		cat("\nSTOP ERROR: number of hits should be == 1. Non-match=\n")#
		print(tmpname)#
		}#
	positions_in_seqs[i] = (1:length(rownames(seqs)))[hits_TF]#
	}#
positions_in_seqs#
#
subset_distmat1 = distmat1[positions_in_seqs,positions_in_seqs]#
#
outfn = "/drives/od/__GDrive_projects/2019-08-22_Craig_Millar_notho_fish/08_distance_matrix/Xcellidae_distmat_TN93_subset_gamma1.txt"#
write.table(x=subset_distmat1, file=outfn, sep="\t")#
distmat2 = dist.dna(x=seqs, model="TN93", gamma=2, as.matrix=TRUE)#
dim(distmat1)#
distmat2[1:5,1:5]#
i=1#
positions_in_seqs = rep(NA, times=length(tmpnames))#
for (i in 1:length(tmpnames))#
	{#
	tmpname = tmpnames[i]#
	hits_TF = sapply(X=rownames(seqs), FUN=grepl, pattern=tmpname, ignore.case=TRUE)#
	if (sum(hits_TF) != 1)#
		{#
		cat("\nSTOP ERROR: number of hits should be == 1. Non-match=\n")#
		print(tmpname)#
		}#
	positions_in_seqs[i] = (1:length(rownames(seqs)))[hits_TF]#
	}#
positions_in_seqs#
#
subset_distmat1 = distmat1[positions_in_seqs,positions_in_seqs]#
#
outfn = "/drives/od/__GDrive_projects/2019-08-22_Craig_Millar_notho_fish/08_distance_matrix/Xcellidae_distmat_TN93_subset_gamma2.txt"#
write.table(x=subset_distmat1, file=outfn, sep="\t")
?write.table
########################################################
# OK, make the distance matrix - Kimura 2-parameter#
########################################################
#
# Subset for the distance-matrix figure#
tmpnames = c("KY628815",#
"KY628818",#
"KF911018",#
"EU878172",#
"GU296509",#
"KY628817",#
"AB112470",#
"AB451874",#
"OL630144",#
"OL630145",#
"GU296508",#
"KY628819",#
"MW743280",#
"MW743279",#
"MW743281",#
"MW743278",#
"Bork")#
distmat1 = dist.dna(x=seqs, model="raw", gamma=FALSE, as.matrix=TRUE)#
dim(distmat1)#
distmat1[1:5,1:5]#
i=1#
positions_in_seqs = rep(NA, times=length(tmpnames))#
for (i in 1:length(tmpnames))#
	{#
	tmpname = tmpnames[i]#
	hits_TF = sapply(X=rownames(seqs), FUN=grepl, pattern=tmpname, ignore.case=TRUE)#
	if (sum(hits_TF) != 1)#
		{#
		cat("\nSTOP ERROR: number of hits should be == 1. Non-match=\n")#
		print(tmpname)#
		}#
	positions_in_seqs[i] = (1:length(rownames(seqs)))[hits_TF]#
	}#
positions_in_seqs#
#
subset_distmat1 = distmat1[positions_in_seqs,positions_in_seqs]#
#
outfn = "/drives/od/__GDrive_projects/2019-08-22_Craig_Millar_notho_fish/08_distance_matrix/Xcellidae_distmat_raw_subset.txt"#
write.table(x=subset_distmat1, file=outfn, sep="\t")#
distmat1 = dist.dna(x=seqs, model="K80", gamma=FALSE, as.matrix=TRUE)#
dim(distmat1)#
distmat1[1:5,1:5]#
i=1#
positions_in_seqs = rep(NA, times=length(tmpnames))#
for (i in 1:length(tmpnames))#
	{#
	tmpname = tmpnames[i]#
	hits_TF = sapply(X=rownames(seqs), FUN=grepl, pattern=tmpname, ignore.case=TRUE)#
	if (sum(hits_TF) != 1)#
		{#
		cat("\nSTOP ERROR: number of hits should be == 1. Non-match=\n")#
		print(tmpname)#
		}#
	positions_in_seqs[i] = (1:length(rownames(seqs)))[hits_TF]#
	}#
positions_in_seqs#
#
subset_distmat1 = distmat1[positions_in_seqs,positions_in_seqs]#
#
outfn = "/drives/od/__GDrive_projects/2019-08-22_Craig_Millar_notho_fish/08_distance_matrix/Xcellidae_distmat_K80_subset.txt"#
write.table(x=subset_distmat1, file=outfn, sep="\t")#
distmat1 = dist.dna(x=seqs, model="K80", gamma=1, as.matrix=TRUE)#
dim(distmat1)#
distmat1[1:5,1:5]#
i=1#
positions_in_seqs = rep(NA, times=length(tmpnames))#
for (i in 1:length(tmpnames))#
	{#
	tmpname = tmpnames[i]#
	hits_TF = sapply(X=rownames(seqs), FUN=grepl, pattern=tmpname, ignore.case=TRUE)#
	if (sum(hits_TF) != 1)#
		{#
		cat("\nSTOP ERROR: number of hits should be == 1. Non-match=\n")#
		print(tmpname)#
		}#
	positions_in_seqs[i] = (1:length(rownames(seqs)))[hits_TF]#
	}#
positions_in_seqs#
#
subset_distmat1 = distmat1[positions_in_seqs,positions_in_seqs]#
#
outfn = "/drives/od/__GDrive_projects/2019-08-22_Craig_Millar_notho_fish/08_distance_matrix/Xcellidae_distmat_K80_subset_gamma1.txt"#
write.table(x=subset_distmat1, file=outfn, sep="\t")#
distmat1 = dist.dna(x=seqs, model="K80", gamma=2, as.matrix=TRUE)#
dim(distmat1)#
distmat1[1:5,1:5]#
i=1#
positions_in_seqs = rep(NA, times=length(tmpnames))#
for (i in 1:length(tmpnames))#
	{#
	tmpname = tmpnames[i]#
	hits_TF = sapply(X=rownames(seqs), FUN=grepl, pattern=tmpname, ignore.case=TRUE)#
	if (sum(hits_TF) != 1)#
		{#
		cat("\nSTOP ERROR: number of hits should be == 1. Non-match=\n")#
		print(tmpname)#
		}#
	positions_in_seqs[i] = (1:length(rownames(seqs)))[hits_TF]#
	}#
positions_in_seqs#
#
subset_distmat1 = distmat1[positions_in_seqs,positions_in_seqs]#
#
outfn = "/drives/od/__GDrive_projects/2019-08-22_Craig_Millar_notho_fish/08_distance_matrix/Xcellidae_distmat_K80_subset_gamma2.txt"#
write.table(x=subset_distmat1, file=outfn, sep="\t")#
distmat1 = dist.dna(x=seqs, model="TN93", gamma=FALSE, as.matrix=TRUE)#
dim(distmat1)#
distmat1[1:5,1:5]#
i=1#
positions_in_seqs = rep(NA, times=length(tmpnames))#
for (i in 1:length(tmpnames))#
	{#
	tmpname = tmpnames[i]#
	hits_TF = sapply(X=rownames(seqs), FUN=grepl, pattern=tmpname, ignore.case=TRUE)#
	if (sum(hits_TF) != 1)#
		{#
		cat("\nSTOP ERROR: number of hits should be == 1. Non-match=\n")#
		print(tmpname)#
		}#
	positions_in_seqs[i] = (1:length(rownames(seqs)))[hits_TF]#
	}#
positions_in_seqs#
#
subset_distmat1 = distmat1[positions_in_seqs,positions_in_seqs]#
#
outfn = "/drives/od/__GDrive_projects/2019-08-22_Craig_Millar_notho_fish/08_distance_matrix/Xcellidae_distmat_TN93_subset.txt"#
write.table(x=subset_distmat1, file=outfn, sep="\t")#
distmat1 = dist.dna(x=seqs, model="TN93", gamma=0.5, as.matrix=TRUE)#
dim(distmat1)#
distmat1[1:5,1:5]#
i=1#
positions_in_seqs = rep(NA, times=length(tmpnames))#
for (i in 1:length(tmpnames))#
	{#
	tmpname = tmpnames[i]#
	hits_TF = sapply(X=rownames(seqs), FUN=grepl, pattern=tmpname, ignore.case=TRUE)#
	if (sum(hits_TF) != 1)#
		{#
		cat("\nSTOP ERROR: number of hits should be == 1. Non-match=\n")#
		print(tmpname)#
		}#
	positions_in_seqs[i] = (1:length(rownames(seqs)))[hits_TF]#
	}#
positions_in_seqs#
#
subset_distmat1 = distmat1[positions_in_seqs,positions_in_seqs]#
#
outfn = "/drives/od/__GDrive_projects/2019-08-22_Craig_Millar_notho_fish/08_distance_matrix/Xcellidae_distmat_TN93_subset_gamma0.5.txt"#
write.table(x=subset_distmat1, file=outfn, sep="\t")#
distmat1 = dist.dna(x=seqs, model="TN93", gamma=1, as.matrix=TRUE)#
dim(distmat1)#
distmat1[1:5,1:5]#
i=1#
positions_in_seqs = rep(NA, times=length(tmpnames))#
for (i in 1:length(tmpnames))#
	{#
	tmpname = tmpnames[i]#
	hits_TF = sapply(X=rownames(seqs), FUN=grepl, pattern=tmpname, ignore.case=TRUE)#
	if (sum(hits_TF) != 1)#
		{#
		cat("\nSTOP ERROR: number of hits should be == 1. Non-match=\n")#
		print(tmpname)#
		}#
	positions_in_seqs[i] = (1:length(rownames(seqs)))[hits_TF]#
	}#
positions_in_seqs#
#
subset_distmat1 = distmat1[positions_in_seqs,positions_in_seqs]#
#
outfn = "/drives/od/__GDrive_projects/2019-08-22_Craig_Millar_notho_fish/08_distance_matrix/Xcellidae_distmat_TN93_subset_gamma1.txt"#
write.table(x=subset_distmat1, file=outfn, sep="\t")#
distmat1 = dist.dna(x=seqs, model="TN93", gamma=2, as.matrix=TRUE)#
dim(distmat1)#
distmat1[1:5,1:5]#
i=1#
positions_in_seqs = rep(NA, times=length(tmpnames))#
for (i in 1:length(tmpnames))#
	{#
	tmpname = tmpnames[i]#
	hits_TF = sapply(X=rownames(seqs), FUN=grepl, pattern=tmpname, ignore.case=TRUE)#
	if (sum(hits_TF) != 1)#
		{#
		cat("\nSTOP ERROR: number of hits should be == 1. Non-match=\n")#
		print(tmpname)#
		}#
	positions_in_seqs[i] = (1:length(rownames(seqs)))[hits_TF]#
	}#
positions_in_seqs#
#
subset_distmat1 = distmat1[positions_in_seqs,positions_in_seqs]#
#
outfn = "/drives/od/__GDrive_projects/2019-08-22_Craig_Millar_notho_fish/08_distance_matrix/Xcellidae_distmat_TN93_subset_gamma2.txt"#
write.table(x=subset_distmat1, file=outfn, sep="\t")
# Subset for the distance-matrix figure#
tmpnames = c("KY628815",#
"KY628818",#
"KF911018",#
"EU878172",#
"GU296509",#
"KY628817",#
"AB112470",#
"AB451874",#
"OL630144",#
"OL630145",#
"GU296508",#
"KY628819",#
"MW743280",#
"MW743279",#
"MW743281",#
"MW743278",#
"Bork")#
distmat1 = dist.dna(x=seqs, model="raw", gamma=FALSE, as.matrix=TRUE)#
dim(distmat1)#
distmat1[1:5,1:5]#
i=1#
positions_in_seqs = rep(NA, times=length(tmpnames))#
for (i in 1:length(tmpnames))#
	{#
	tmpname = tmpnames[i]#
	hits_TF = sapply(X=rownames(seqs), FUN=grepl, pattern=tmpname, ignore.case=TRUE)#
	if (sum(hits_TF) != 1)#
		{#
		cat("\nSTOP ERROR: number of hits should be == 1. Non-match=\n")#
		print(tmpname)#
		}#
	positions_in_seqs[i] = (1:length(rownames(seqs)))[hits_TF]#
	}#
positions_in_seqs#
#
subset_distmat1 = distmat1[positions_in_seqs,positions_in_seqs]#
#
outfn = "/drives/od/__GDrive_projects/2019-08-22_Craig_Millar_notho_fish/08_distance_matrix/Xcellidae_distmat_raw_subset.txt"#
write.table(x=subset_distmat1, file=outfn, sep="\t", quote=FALSE)#
distmat1 = dist.dna(x=seqs, model="K80", gamma=FALSE, as.matrix=TRUE)#
dim(distmat1)#
distmat1[1:5,1:5]#
i=1#
positions_in_seqs = rep(NA, times=length(tmpnames))#
for (i in 1:length(tmpnames))#
	{#
	tmpname = tmpnames[i]#
	hits_TF = sapply(X=rownames(seqs), FUN=grepl, pattern=tmpname, ignore.case=TRUE)#
	if (sum(hits_TF) != 1)#
		{#
		cat("\nSTOP ERROR: number of hits should be == 1. Non-match=\n")#
		print(tmpname)#
		}#
	positions_in_seqs[i] = (1:length(rownames(seqs)))[hits_TF]#
	}#
positions_in_seqs#
#
subset_distmat1 = distmat1[positions_in_seqs,positions_in_seqs]#
#
outfn = "/drives/od/__GDrive_projects/2019-08-22_Craig_Millar_notho_fish/08_distance_matrix/Xcellidae_distmat_K80_subset.txt"#
write.table(x=subset_distmat1, file=outfn, sep="\t", quote=FALSE)#
distmat1 = dist.dna(x=seqs, model="K80", gamma=1, as.matrix=TRUE)#
dim(distmat1)#
distmat1[1:5,1:5]#
i=1#
positions_in_seqs = rep(NA, times=length(tmpnames))#
for (i in 1:length(tmpnames))#
	{#
	tmpname = tmpnames[i]#
	hits_TF = sapply(X=rownames(seqs), FUN=grepl, pattern=tmpname, ignore.case=TRUE)#
	if (sum(hits_TF) != 1)#
		{#
		cat("\nSTOP ERROR: number of hits should be == 1. Non-match=\n")#
		print(tmpname)#
		}#
	positions_in_seqs[i] = (1:length(rownames(seqs)))[hits_TF]#
	}#
positions_in_seqs#
#
subset_distmat1 = distmat1[positions_in_seqs,positions_in_seqs]#
#
outfn = "/drives/od/__GDrive_projects/2019-08-22_Craig_Millar_notho_fish/08_distance_matrix/Xcellidae_distmat_K80_subset_gamma1.txt"#
write.table(x=subset_distmat1, file=outfn, sep="\t", quote=FALSE)#
distmat1 = dist.dna(x=seqs, model="K80", gamma=2, as.matrix=TRUE)#
dim(distmat1)#
distmat1[1:5,1:5]#
i=1#
positions_in_seqs = rep(NA, times=length(tmpnames))#
for (i in 1:length(tmpnames))#
	{#
	tmpname = tmpnames[i]#
	hits_TF = sapply(X=rownames(seqs), FUN=grepl, pattern=tmpname, ignore.case=TRUE)#
	if (sum(hits_TF) != 1)#
		{#
		cat("\nSTOP ERROR: number of hits should be == 1. Non-match=\n")#
		print(tmpname)#
		}#
	positions_in_seqs[i] = (1:length(rownames(seqs)))[hits_TF]#
	}#
positions_in_seqs#
#
subset_distmat1 = distmat1[positions_in_seqs,positions_in_seqs]#
#
outfn = "/drives/od/__GDrive_projects/2019-08-22_Craig_Millar_notho_fish/08_distance_matrix/Xcellidae_distmat_K80_subset_gamma2.txt"#
write.table(x=subset_distmat1, file=outfn, sep="\t", quote=FALSE)#
distmat1 = dist.dna(x=seqs, model="TN93", gamma=FALSE, as.matrix=TRUE)#
dim(distmat1)#
distmat1[1:5,1:5]#
i=1#
positions_in_seqs = rep(NA, times=length(tmpnames))#
for (i in 1:length(tmpnames))#
	{#
	tmpname = tmpnames[i]#
	hits_TF = sapply(X=rownames(seqs), FUN=grepl, pattern=tmpname, ignore.case=TRUE)#
	if (sum(hits_TF) != 1)#
		{#
		cat("\nSTOP ERROR: number of hits should be == 1. Non-match=\n")#
		print(tmpname)#
		}#
	positions_in_seqs[i] = (1:length(rownames(seqs)))[hits_TF]#
	}#
positions_in_seqs#
#
subset_distmat1 = distmat1[positions_in_seqs,positions_in_seqs]#
#
outfn = "/drives/od/__GDrive_projects/2019-08-22_Craig_Millar_notho_fish/08_distance_matrix/Xcellidae_distmat_TN93_subset.txt"#
write.table(x=subset_distmat1, file=outfn, sep="\t", quote=FALSE)#
distmat1 = dist.dna(x=seqs, model="TN93", gamma=0.5, as.matrix=TRUE)#
dim(distmat1)#
distmat1[1:5,1:5]#
i=1#
positions_in_seqs = rep(NA, times=length(tmpnames))#
for (i in 1:length(tmpnames))#
	{#
	tmpname = tmpnames[i]#
	hits_TF = sapply(X=rownames(seqs), FUN=grepl, pattern=tmpname, ignore.case=TRUE)#
	if (sum(hits_TF) != 1)#
		{#
		cat("\nSTOP ERROR: number of hits should be == 1. Non-match=\n")#
		print(tmpname)#
		}#
	positions_in_seqs[i] = (1:length(rownames(seqs)))[hits_TF]#
	}#
positions_in_seqs#
#
subset_distmat1 = distmat1[positions_in_seqs,positions_in_seqs]#
#
outfn = "/drives/od/__GDrive_projects/2019-08-22_Craig_Millar_notho_fish/08_distance_matrix/Xcellidae_distmat_TN93_subset_gamma0.5.txt"#
write.table(x=subset_distmat1, file=outfn, sep="\t", quote=FALSE)#
distmat1 = dist.dna(x=seqs, model="TN93", gamma=1, as.matrix=TRUE)#
dim(distmat1)#
distmat1[1:5,1:5]#
i=1#
positions_in_seqs = rep(NA, times=length(tmpnames))#
for (i in 1:length(tmpnames))#
	{#
	tmpname = tmpnames[i]#
	hits_TF = sapply(X=rownames(seqs), FUN=grepl, pattern=tmpname, ignore.case=TRUE)#
	if (sum(hits_TF) != 1)#
		{#
		cat("\nSTOP ERROR: number of hits should be == 1. Non-match=\n")#
		print(tmpname)#
		}#
	positions_in_seqs[i] = (1:length(rownames(seqs)))[hits_TF]#
	}#
positions_in_seqs#
#
subset_distmat1 = distmat1[positions_in_seqs,positions_in_seqs]#
#
outfn = "/drives/od/__GDrive_projects/2019-08-22_Craig_Millar_notho_fish/08_distance_matrix/Xcellidae_distmat_TN93_subset_gamma1.txt"#
write.table(x=subset_distmat1, file=outfn, sep="\t", quote=FALSE)#
distmat1 = dist.dna(x=seqs, model="TN93", gamma=2, as.matrix=TRUE)#
dim(distmat1)#
distmat1[1:5,1:5]#
i=1#
positions_in_seqs = rep(NA, times=length(tmpnames))#
for (i in 1:length(tmpnames))#
	{#
	tmpname = tmpnames[i]#
	hits_TF = sapply(X=rownames(seqs), FUN=grepl, pattern=tmpname, ignore.case=TRUE)#
	if (sum(hits_TF) != 1)#
		{#
		cat("\nSTOP ERROR: number of hits should be == 1. Non-match=\n")#
		print(tmpname)#
		}#
	positions_in_seqs[i] = (1:length(rownames(seqs)))[hits_TF]#
	}#
positions_in_seqs#
#
subset_distmat1 = distmat1[positions_in_seqs,positions_in_seqs]#
#
outfn = "/drives/od/__GDrive_projects/2019-08-22_Craig_Millar_notho_fish/08_distance_matrix/Xcellidae_distmat_TN93_subset_gamma2.txt"#
write.table(x=subset_distmat1, file=outfn, sep="\t", quote=FALSE)
library(cladoRcpp)#
library(BioGeoBEARS)#
library(ape)#
library(castor)#
#
# Set the random number seed, to make it repeatable#
set.seed(54321)#
#
time_grid = seq(0,10,0.1) # About halfway through#
A = get_random_mk_transition_matrix(Nstates=4, rate_model="ER", max_rate=0.1)#
#
# Make it more like a DEC model (anagenetic)#
d_rate = 0.06 # range expansion#
e_rate = 0.01 # range contraction#
#
# 4 states are:#
# null, A, B, AB#
A[,] = 0#
A[2,4] = d_rate # A->AB#
A[3,4] = d_rate # B->AB#
A[2,1] = e_rate # A->null#
A[3,1] = e_rate # B->null#
A[4,2] = e_rate # AB->A#
A[4,3] = e_rate # AB->B#
A#
#
# In Q transition matrices, the diagonals = -sum(off-diagonal for that row)#
diag(A) = 0.0#
A#
diag(A) = -rowSums(A)#
A#
# Cladogenetic part of the DEC model#
# At speciation, we have:#
# Specify probabilities of different events, given that speciation has occurred#
########################################################
# 1st regime: vicariance, subset sympatry not allowed - BAYAREALIKE model#
########################################################
#
# Sympatry#
# null->null,null#
# A -> A,A  # 100#
# B -> B,B	# 100#
# Vicariance#
# AB -> A,B	# 0#
# AB -> B,A	# 0#
# Subset sympatry (speciation within widespread ancestor)#
# AB -> AB,A	# 0#
# AB -> A,AB	# 0#
# AB -> AB,B	# 0#
# AB -> B,AB	# 0#
# AB -> AB, AB # 1.0#
#
transition_matrix_C = get_random_mk_transition_matrix(Nstates=4, rate_model="ER", max_rate=0.1)#
transition_matrix_C[,] = 0.0#
transition_matrix_C#
transition_matrix_C[1,1] = 1.0 # null->null#
transition_matrix_C[2,2] = 1.0 # A->A#
transition_matrix_C[3,3] = 1.0 # B->B#
transition_matrix_C[4,] = 0.0#
transition_matrix_C[4,1] = 0.0#
transition_matrix_C[4,2] = 0.0 # AB->A#
transition_matrix_C[4,3] = 0.0 # AB->B#
transition_matrix_C[4,4] = 6/6 # AB->AB#
transition_matrix_C1 = transition_matrix_C#
transition_matrix_C#
#
# Rows of transition_table_C#
transition_table_C = NULL#
tmprow = c(1,1,1,1.0)#
transition_table_C = rbind(transition_table_C, tmprow)#
tmprow = c(2,2,2,1.0)#
transition_table_C = rbind(transition_table_C, tmprow)#
tmprow = c(3,3,3,1.0)#
transition_table_C = rbind(transition_table_C, tmprow)#
tmprow = c(4,2,3,0)#
transition_table_C = rbind(transition_table_C, tmprow)#
tmprow = c(4,2,4,0)#
transition_table_C = rbind(transition_table_C, tmprow)#
tmprow = c(4,3,4,0)#
transition_table_C = rbind(transition_table_C, tmprow)#
tmprow = c(4,4,4,1.0)#
transition_table_C = rbind(transition_table_C, tmprow)#
transition_table_C#
#
# convert from 1-based to 0-based indices (turns out this is NOT needed for the C++ code)#
transition_table_indices_C = transition_table_C[,1:3] - 1#
transition_table_probs_C1 = transition_table_C[,4]
transition_matrix_C = get_random_mk_transition_matrix(Nstates=4, rate_model="ER", max_rate=0.1)#
transition_matrix_C[,] = 0.0#
transition_matrix_C#
transition_matrix_C[1,1] = 1.0 # null->null#
transition_matrix_C[2,2] = 1.0 # A->A#
transition_matrix_C[3,3] = 1.0 # B->B#
transition_matrix_C[4,] = 0.0#
transition_matrix_C[4,1] = 0.0#
transition_matrix_C[4,2] = 2/6 # AB->A#
transition_matrix_C[4,3] = 2/6 # AB->B#
transition_matrix_C[4,4] = 2/6 # AB->AB#
transition_matrix_C2 = transition_matrix_C#
#
# Rows of transition_table_C#
transition_table_C = NULL#
tmprow = c(1,1,1,1.0)#
transition_table_C = rbind(transition_table_C, tmprow)#
tmprow = c(2,2,2,1.0)#
transition_table_C = rbind(transition_table_C, tmprow)#
tmprow = c(3,3,3,1.0)#
transition_table_C = rbind(transition_table_C, tmprow)#
tmprow = c(4,2,3,1/3)#
transition_table_C = rbind(transition_table_C, tmprow)#
tmprow = c(4,2,4,1/3)#
transition_table_C = rbind(transition_table_C, tmprow)#
tmprow = c(4,3,4,1/3)#
transition_table_C = rbind(transition_table_C, tmprow)#
tmprow = c(4,4,4,0.0)#
transition_table_C = rbind(transition_table_C, tmprow)#
transition_table_C#
#
# convert from 1-based to 0-based indices (turns out this is NOT needed for the C++ code)#
transition_table_indices_C = transition_table_C[,1:3] - 1#
transition_table_probs_C2 = transition_table_C[,4]#
# Make the arrays for the parameters#
transition_matrix_C_array = array(data=0.0, dim=c(nrow(transition_matrix_C1), ncol(transition_matrix_C), length(time_grid)))#
#
# Probs encoded in a num_clado_events * 2 * num_times array#
# the "2" just duplicates, ensures we have a 3D array#
transition_table_probs_C_matrix = array(data=0.0, dim=c(length(transition_table_probs_C1), 2, length(time_grid)))
trstr = "((A1:0.010,B2:0.012):0.10,(A2:0.013, B1:0.011):0.09);"#
tr=read.tree(file="", text=trstr)#
plot(tr)
library(ape)
trstr = "((A1:0.010,B2:0.012):0.10,(A2:0.013, B1:0.011):0.09);"#
tr=read.tree(file="", text=trstr)#
plot(tr)
install.packages("shipunov")
library(shipunov)
aa.d <- hclust(dist(t(atmospheres)))#
tree <- ape::unroot(ape::as.phylo(aa.d))#
#
cl <- data.frame(#
planet=c(#
 "Mercury",#
 "Venus",#
 "Earth",#
 "Mars",#
 "Jupiter",#
 "Saturn",#
 "Uranus",#
 "Neptune"),#
clade=c(#
 "Mercury",#
 "Mars group",#
 "Earth",#
 "Mars group",#
 "Close giants",#
 "Close giants",#
 "Distant giants",#
 "Distant giants"),#
stringsAsFactors=FALSE)#
#
Plot.phylocl(tree, cl, longer="5%", ct.off=0.1)
plot(tree)
ggtree
install.packages("ggtree")
BiocManager::install("ggtree")
library(ggtree)
BiocManager::install("ggtree")
library(ggtree)#
nwk <- system.file("extdata", "sample.nwk", package="treeio")#
tree <- read.tree(nwk)#
p <- ggtree(tree) + geom_tiplab()#
viewClade(p, MRCA(p, "I", "L"))
tree2 <- groupClade(tree, c(17, 21))
p <- ggtree(tree2, aes(color=group)) + theme(legend.position='none') +#
  scale_color_manual(values=c("black", "firebrick", "steelblue"))
scaleClade(p, node=17, scale=.1)
tree2 <- groupClade(tree, c(17, 21))
tree2
tree
names(tree2)
tree
plot(tree)
plot(tree2)
nwk <- system.file("extdata", "sample.nwk", package="treeio")
tree <- read.tree(nwk)#
p <- ggtree(tree) + geom_tiplab()
viewClade(p)
viewClade(p, node=MRCA(p, "I", "L"))
tree2 <- groupClade(tree, c(17, 21))
tree2
aes
?aes
tree2 <- groupClade(tree, c(17, 21))#
p <- ggtree(tree2, aes(color=group)) + theme(legend.position='none') +#
  scale_color_manual(values=c("black", "firebrick", "steelblue"))#
scaleClade(p, node=17, scale=1)
scaleClade(p, node=17, scale=.1)
p2 <- p %>% collapse(node=21) + #
  geom_point2(aes(subset=(node==21)), shape=21, size=5, fill='green')
p2 <- collapse(p2, node=23) + #
  geom_point2(aes(subset=(node==23)), shape=23, size=5, fill='red')
print(p2)
getMRCA
MRCA
?MRCA
mrca
library(BioGeoBEARS)
treestring = "(((human:6,chimp:6):1,gorilla:7):5,orang:12);"#
tr = read.tree(file="", text=treestring)#
plot(tr)
nodelabels(tr)
nodelabel(tr)
?nodelabel
tr
?nodelabels
nodelabels(tr)
library(ape)
ape::nodelabels(tr)
plot(tr)#
axisPhylo()#
nodelabels()#
tiplabels(1:length(tr$tip.label))
prt(
trtable = prt(tr, printflag=FALSE, get_tipnames=TRUE)=)
trtable = prt(tr, printflag=FALSE, get_tipnames=TRUE)
trtable
getMRCA(phy=tr, tip=c("human","gorilla"))
ree2 <- groupClade(tree, c(17, 21))#
p <- ggtree(tree2, aes(color=group)) + theme(legend.position='none') +#
  scale_color_manual(values=c("black", "firebrick", "steelblue"))#
scaleClade(p, node=17, scale=1) #
scaleClade(p, node=17, scale=.1) #
p2 <- p %>% collapse(node=21) + #
  geom_point2(aes(subset=(node==21)), shape=21, size=5, fill='green')#
p2 <- collapse(p2, node=23) + #
  geom_point2(aes(subset=(node==23)), shape=23, size=5, fill='red')#
print(p2)#
expand(p2, node=23) %>% expand(node=21)
p2 <- p + geom_tiplab()#
node <- 21#
collapse(p2, node, 'max') %>% expand(node)#
collapse(p2, node, 'min') %>% expand(node)#
collapse(p2, node, 'mixed') %>% expand(node)#
#
collapse(p, 21, 'mixed', fill='steelblue', alpha=.4) %>% #
  collapse(23, 'mixed', fill='firebrick', color='blue')
p2 <- p + geom_tiplab()#
node <- 21
p2 <- p %>% collapse(node=21) + #
  geom_point2(aes(subset=(node==21)), shape=21, size=5, fill='green')#
p2 <- collapse(p2, node=23) + #
  geom_point2(aes(subset=(node==23)), shape=23, size=5, fill='red')
print(p2)
expand(p2, node=23) %>% expand(node=21)
p2 <- p + geom_tiplab()
node <- 21
collapse(p2, node, 'max') %>% expand(node)
collapse(p2, node, 'min') %>% expand(node)
collapse(p2, node, 'mixed') %>% expand(node)
collapse(p, 21, 'mixed', fill='steelblue', alpha=.4) %>% #
  collapse(23, 'mixed', fill='firebrick', color='blue')
scaleClade(p, 23, .2) %>% collapse(23, 'min', fill="darkgreen")
data(iris)#
rn <- paste0(iris[,5], "_", 1:150)
rn
rownames(iris) <- rn#
d_iris <- dist(iris[,-5], method="man")
d_iris
tree_iris <- ape::bionj(d_iris)
grp <- list(setosa     = rn[1:50],#
            versicolor = rn[51:100],#
            virginica  = rn[101:150])
p_iris <- ggtree(tree_iris, layout = 'circular', branch.length='none')
groupOTU(p_iris, grp, 'Species') + aes(color=Species) +#
  theme(legend.position="right")
pdffn = "greatapes_tree.pdf"
pdf(file=pdffn, width=6, height=6)
plot(tr)
axisPhylo()#
nodelabels()
tiplabels(1:length(tr$tip.label))#
title("Great ape dated phylogeny")
dev.off()
cmdstr = paste0("open ", pdffn)
cmdstr
system(cmdstr)
pdffn = "greatapes_tree_no_tip_labels.pdf"#
pdf(file=pdffn, width=6, height=6)#
#
plot(tr, show.tip.label=FALSE)#
axisPhylo()#
nodelabels()#
tiplabels(1:length(tr$tip.label))#
title("Great ape dated phylogeny")#
#
dev.off()#
cmdstr = paste0("open ", pdffn)#
system(cmdstr)
pdffn = "greatapes_tree.pdf"#
pdf(file=pdffn, width=6, height=6)#
#
plot(tr, cex=0.4) # cex = character expansion#
axisPhylo()#
nodelabels()#
tiplabels(1:length(tr$tip.label))#
title("Great ape dated phylogeny")#
#
dev.off()#
cmdstr = paste0("open ", pdffn)#
system(cmdstr)
/GitHub/PhyBEARS.jl/ex/siminf_v12a
wd = "/GitHub/PhyBEARS.jl/ex/siminf_v12a/"#
start_state = 2 # number of the starting state#
max_simulation_time = 15.0 # Set to 0 if the user doesn't want to set a max simulation time#
min_numtaxa = 2#
simfns=default_simfns()#
seedval = 54321#
max_rate=10.0
source('/GitHub/PhyBEARS.jl/Rsrc/castor_helpers.R')#
#
wd = "/GitHub/PhyBEARS.jl/ex/siminf_v12a/"#
start_state = 2 # number of the starting state#
max_simulation_time = 15.0 # Set to 0 if the user doesn't want to set a max simulation time#
min_numtaxa = 2#
simfns=default_simfns()#
seedval = 54321#
max_rate=10.0
default_simfns <- function()#
	{#
	simfns = c("setup_df.txt",#
	"timepoints.txt", #
	"mu_vals_by_t.txt",#
	"Qvals_by_t.txt",#
	"Crates_by_t.txt",#
	"Qarray.txt",#
	"Carray.txt",#
	"area_names.txt")#
	return(simfns)#
	}
source('/GitHub/PhyBEARS.jl/Rsrc/castor_helpers.R')#
#
wd = "/GitHub/PhyBEARS.jl/ex/siminf_v12a/"#
start_state = 2 # number of the starting state#
max_simulation_time = 15.0 # Set to 0 if the user doesn't want to set a max simulation time#
min_numtaxa = 2#
simfns=default_simfns()#
seedval = 54321#
max_rate=10.0
area_names = c(read.table(simfns[8]))
# Add wd to the filename (stripping any prior paths from simfns)#
	for (i in 1:length(simfns))#
		{#
		simfns[i] = get_path_last(simfns[i])#
		simfns[i] = slashslash(paste0(wd, "/", simfns[i]))#
		}#
#
	# Get the area_names#
	area_names = c(read.table(simfns[8]))
library(BioGeoBEARS)#
source('/GitHub/PhyBEARS.jl/Rsrc/castor_helpers.R')#
#
wd = "/GitHub/PhyBEARS.jl/ex/siminf_v12a/"#
start_state = 2 # number of the starting state#
max_simulation_time = 15.0 # Set to 0 if the user doesn't want to set a max simulation time#
min_numtaxa = 2#
simfns=default_simfns()#
seedval = 54321#
max_rate=10.0
# Add wd to the filename (stripping any prior paths from simfns)#
	for (i in 1:length(simfns))#
		{#
		simfns[i] = get_path_last(simfns[i])#
		simfns[i] = slashslash(paste0(wd, "/", simfns[i]))#
		}#
#
	# Get the area_names#
	area_names = c(read.table(simfns[8]))
library(cladoRcpp)#
library(BioGeoBEARS)#
library(ape)#
library(castor)#
#
# for: reorder_castor_sim_to_default_ape_node_order(simulation)#
source("/GitHub/PhyBEARS.jl/Rsrc/castor_helpers.R")#
wd = "/GitHub/PhyBEARS.jl/ex/siminf_v12a/"#
setwd(wd)#
simfns = c("setup_df.txt",#
"timepoints.txt", #
"mu_vals_by_t.txt", #
"Qvals_by_t.txt",#
"Crates_by_t.txt",#
"Qarray.txt",#
"Carray.txt",#
"area_names.txt",#
"states_list.R")#
simulation2 = simulate_tdsse2_for_timeperiod(wd, start_state=2, max_simulation_time=15, min_numtaxa=50, max_tips=100, simfns=default_simfns(), seedval=54321, max_rate=10.0, numtries=1000)
simulation2
names(simulation2$simstates)
simulation2$simstates
simulation2$states
library(cladoRcpp)#
library(BioGeoBEARS)#
library(ape)#
library(castor)#
#
# for: reorder_castor_sim_to_default_ape_node_order(simulation)#
source("/GitHub/PhyBEARS.jl/Rsrc/castor_helpers.R")#
wd = "/GitHub/PhyBEARS.jl/ex/siminf_v12a/"#
setwd(wd)#
simfns = c("setup_df.txt",#
"timepoints.txt", #
"mu_vals_by_t.txt", #
"Qvals_by_t.txt",#
"Crates_by_t.txt",#
"Qarray.txt",#
"Carray.txt",#
"area_names.txt",#
"states_list.R")#
simulation2 = simulate_tdsse2_for_timeperiod(wd, start_state=2, max_simulation_time=15, min_numtaxa=50, max_tips=100, simfns=default_simfns(), seedval=54321, max_rate=10.0, numtries=1000)
start_state=2; max_simulation_time=15; min_numtaxa=50; max_tips=100; simfns=default_simfns(); seedval=54321; max_rate=10.0; numtries=1000
for (i in 1:length(simfns))#
		{#
		simfns[i] = get_path_last(simfns[i])#
		simfns[i] = slashslash(paste0(wd, "/", simfns[i]))#
		}#
#
	# Get the area_names and states_list#
	area_names = c(read.table(simfns[8]))[[1]]#
	# states_list = #
	source(simfns[9]) # Creates a states_list#
	# Read in the setup#
	setup_df = read.table(simfns[1], header=TRUE)#
	numareas = setup_df$numareas#
	numstates = setup_df$numstates#
	max_range_size = setup_df$max_range_size#
	if (tolower(setup_df$include_null_range) == "true")#
		{#
		include_null_range = TRUE#
		} else {#
		include_null_range = FALSE#
		}#
#
	# User sets these here!#
	# Set the random number seed, to make it repeatable#
	set.seed(seedval)#
	# Set the max_simulation time -- whatever changing distances you have will be#
	# extended with this timepoint, i.e. the final geography/rates will continue#
	# to this timepoint#
	#start_state = 8 # number of the starting state#
	#max_simulation_time = 15.0 # Set to 0 if the user doesn't want to set a max simulation time#
	#max_tips = NULL#
#
	# Set a maximum rate for extreme cases#
	#max_rate = 10.0#
	# Read timepoints#
	# Read in Q/A matrix, populate one and array#
	# Read in C matrix, populate one and array#
#
	# Load the files#
	#time_grid = seq(0,10,0.1) # About halfway through#
	time_grid = c(read.table(simfns[2], header=FALSE))[[1]]#
#
	# Change from time reading backwards to time reading forwards#
	colnums = rev(1:length(time_grid))#
	time_grid = -1*(max(time_grid) - time_grid) - min(-1*(max(time_grid) - time_grid))#
	time_grid#
	mu_vals_by_t = as.matrix(read.table(simfns[3], header=FALSE))[,colnums]#
	Qvals_by_t = as.matrix(read.table(simfns[4], header=FALSE))[,colnums]#
	Crates_by_t = as.matrix(read.table(simfns[5], header=FALSE))[,colnums]#
	Qarray = read.table(simfns[6], header=TRUE)#
	Carray = read.table(simfns[7], header=TRUE)#
#
	# Add the final time at end of forward simulation, if needed#
	if (max(time_grid) < max_simulation_time)#
		{#
		time_grid = c(time_grid, max_simulation_time)#
		mu_vals_by_t = cbind(mu_vals_by_t, mu_vals_by_t[,ncol(mu_vals_by_t)])#
		Qvals_by_t = cbind(Qvals_by_t, Qvals_by_t[,ncol(Qvals_by_t)])#
		Crates_by_t = cbind(Crates_by_t, Crates_by_t[,ncol(Crates_by_t)])#
		}#
	# Enforce maximum rate on Crates_by_t#
	Crates_by_t[Crates_by_t > max_rate] = max_rate#
	mu_vals_by_t[mu_vals_by_t > max_rate] = max_rate#
#
	# Produce the A transition matrix / array#
	A = array(data=0.0, dim=c(numstates,numstates,length(time_grid)))#
	for (i in 1:length(time_grid))#
		{#
		for (j in 1:nrow(Qarray))#
			{#
			A[Qarray$i[j],Qarray$j[j],i] = Qvals_by_t[j,i]#
			}#
		# Enforce maximum rate#
		A[A > max_rate] = max_rate#
		# Set the diagonal#
		diag(A[,,i]) = 0.0#
		diag(A[,,i]) = -rowSums(A[,,i])#
		}#
#
	# Cladogenetic part of the DEC model#
	# At speciation, we have:#
	# Specify probabilities of different events, given that speciation has occurred#
	# (ADD THESE UP to provide the speciation rates / lambdas)#
#
	# transition_table_C: columns are i, j, k, prob#
	# transition_table_rates_C_matrix: columns are i, j, k, rate #
	# (later, we will add up these rates to get the total lambda by state)#
	transition_table_C = NULL#
	transition_table_probs_C_matrix = array(data=0.0, dim=c(nrow(Crates_by_t), 4, length(time_grid)))#
	transition_table_rates_C_matrix = array(data=0.0, dim=c(nrow(Crates_by_t), 4, length(time_grid)))#
	dim(transition_table_probs_C_matrix)#
	dim(transition_table_rates_C_matrix)#
#
	rates_sums_by_t = NULL#
	for (i in 1:length(time_grid))#
		{#
		tmprates = as.data.frame(cbind(Carray$i, Carray$j, Carray$k, Crates_by_t[,i]), stringsAsFactors=FALSE)#
		names(tmprates) = c("i", "j", "k", "rates_t")#
		# Convert rates to probabilities#
		rates_sums = aggregate(tmprates$rates_t, by=list(tmprates$i), FUN=sum)#
		# Column names#
		names(rates_sums) = c("i", "rates_sum")#
		# Make sure rates_sums are ordered by 'i' (ancestral state index)#
		tmporder = order(rates_sums$i)#
		rates_sums = rates_sums[tmporder,]#
		# Check for null range; add row for "i" if needed#
		if (rates_sums$i[1] == 2)#
			{#
			tmprow = as.data.frame(matrix(data=c(1,0.0), nrow=1), stringsAsFactors=FALSE)#
			names(tmprow) = c("i", "rates_sum")#
			rates_sums = rbind(tmprow, rates_sums)#
			}#
		rates_sums_by_t	= cbind(rates_sums_by_t, rates_sums$rates_sum)#
#
		# Convert rates to probabilities#
		tmpprobs = tmprates#
		names(tmpprobs) = c("i", "j", "k", "probs_t")#
		for (q in 1:nrow(rates_sums))#
			{#
			tmpi = rates_sums$i[q]#
			TF = tmprates$i == tmpi#
#
			tmpprobs$probs_t[TF] = tmprates$rates_t[TF] / rates_sums$rates_sum[q]#
			}#
		transition_table_rates_C_matrix[,,i] = as.matrix(tmprates)#
		transition_table_probs_C_matrix[,,i] = as.matrix(tmpprobs)#
		}#
	# Square transition matrix (not used, but sanity check)#
	transition_matrix_C = array(data=0.0, dim=c(numstates,numstates,1))#
	transition_matrix_C_array = array(data=0.0, dim=c(numstates,numstates,length(time_grid)))#
	for (i in 1:length(time_grid))#
		{#
		for (j in 1:nrow(Carray))#
			{#
			if ((Carray$i[j] == Carray$j[j]) && (Carray$i[j] == Carray$k[j]))#
				{#
				# state i = state j = state k#
				transition_matrix_C_array[Carray$i[j],Carray$j[j],i] = transition_matrix_C_array[Carray$i[j],Carray$j[j],i] + Crates_by_t[j,i] / rates_sums_by_t[Carray$i[j],i]#
				} else {#
				# Otherwise, you have two different "anagenetic" events, with the probability split between them#
				transition_matrix_C_array[Carray$i[j],Carray$j[j],i] = transition_matrix_C_array[Carray$i[j],Carray$j[j],i] + Crates_by_t[j,i] / rates_sums_by_t[Carray$i[j],i] / 2#
				transition_matrix_C_array[Carray$i[j],Carray$k[j],i] = transition_matrix_C_array[Carray$i[j],Carray$k[j],i] + Crates_by_t[j,i] / rates_sums_by_t[Carray$i[j],i] / 2#
				}#
			# Ignore, rates are already doubled if needed#
			# if (Carray$i[j] != Carray$j[j])#
			}#
		# DO NOT set the diagonal on the cladogenetic transition rates#
		#diag(transition_matrix_C_array[,,i]) = 0.0#
		#diag(transition_matrix_C_array[,,i]) = -rowSums(transition_matrix_C_array[,,i])#
#
		# Null range correction#
		if (rowSums(transition_matrix_C_array[,,i])[1] == 0.0)#
			{#
			transition_matrix_C_array[1,1,i] = 1.0#
			}#
		}#
	transition_matrix_C = transition_matrix_C_array[,,dim(transition_matrix_C_array)[3]]#
	transition_matrix_C#
	rowSums(transition_matrix_C)#
	# Check probs#
	for (i in 1:length(time_grid))#
		{#
		tmpprobs = transition_table_probs_C_matrix[,,i]#
		probs_sum = aggregate(tmpprobs[,4], by=list(tmpprobs[,1]), FUN=sum)#
		tmprates = transition_table_rates_C_matrix[,,i]#
		rates_sum = aggregate(tmprates[,4], by=list(tmprates[,1]), FUN=sum)#
		sums_by_i = cbind(rates_sum, probs_sum[,2])#
		names(sums_by_i) = c("i", "rates_sum", "probs_sum")#
		print(sums_by_i)#
		}#
	# convert from 1-based to 0-based indices (turns out this is NOT needed for the C++ code)#
	# transition_table_indices_C = transition_table_C[,1:3] - 1#
	transition_table_indices_C = transition_table_rates_C_matrix[,1:3,1] - 1#
	transition_table_indices_C_matrix = array(data=transition_table_indices_C, dim=c(dim(transition_table_indices_C),length(time_grid)))#
	# transition_table_probs_C1 = transition_table_C[,4]#
	transition_table_probs_C1 = transition_table_probs_C_matrix[,4,1]#
	# Make the arrays for the parameters#
#
	# Probs encoded in a num_clado_events * 2 * num_times array#
	# the "2" just duplicates, ensures we have a 3D array#
	transition_table_probs_C = array(data=0.0, dim=c(nrow(transition_table_indices_C), 2, length(time_grid)))#
#
	# Fill in the transition_matrix_C and transition_table_probs#
	for (i in 1:length(time_grid))#
		{#
		transition_table_probs_C[,1,i] = transition_table_probs_C_matrix[,4,i]#
		transition_table_probs_C[,2,i] = transition_table_probs_C_matrix[,4,i]#
		}#
	parameters = list(birth_rates         = rates_sums_by_t,#
										death_rates         = mu_vals_by_t,#
										transition_matrix_A = A,#
										transition_matrix_C = transition_matrix_C_array,#
										transition_table_indices_C = transition_table_indices_C,#
										transition_table_probs_C = transition_table_probs_C )#
	# simulation#
	sim_done = FALSE#
	trynum = 1#
	while(sim_done == FALSE)#
		{#
		if (trynum > numtries)#
			{#
			txt = paste0("simulate_tdsse2() obtained no qualifying simulations after ", numtries, " tries. Increase numtries, increase max_simulation_time, or reduce max_tips.")#
			cat("\n")#
			cat(txt)#
			cat("\n")#
			sim_done = TRUE#
			break()#
			}#
#
		simulation = simulate_tdsse2( Nstates = numstates, #
																parameters = parameters, #
																splines_degree      = 1,#
																start_state = start_state,#
																max_tips = max_tips,#
																max_time = max_simulation_time,#
																time_grid = time_grid,#
																include_birth_times=TRUE,#
																include_death_times=TRUE,#
																coalescent=FALSE)#
#
		if (simulation$success == FALSE)#
			{ trynum=trynum+1; next() }#
#
		if (length(simulation$tree$tip.label) < 3)#
			{ trynum=trynum+1; next() }#
		# Otherwise, proceed#
		simulation2 = reorder_castor_sim_to_default_ape_node_order(simulation)#
		tip_ages_above_root = get_node_ages_of_tips(simulation2$tree)
if (simulation$success == FALSE)#
			{ trynum=trynum+1; next() }#
#
		if (length(simulation$tree$tip.label) < 3)#
			{ trynum=trynum+1; next() }#
		# Otherwise, proceed#
		simulation2 = reorder_castor_sim_to_default_ape_node_order(simulation)#
		tip_ages_above_root = get_node_ages_of_tips(simulation2$tree)#
		tip_age_tolerance = 1e-6#
		fossils_TF = (max(tip_ages_above_root) - tip_ages_above_root) > tip_age_tolerance#
		num_tips_in_present = sum(fossils_TF == FALSE)#
		# Check for successful simulation#
		if (num_tips_in_present < min_numtaxa)#
			{ trynum=trynum+1; next() }#
#
		} # END while(sim_done == FALSE)
}
}
}
}
}#
)
}#
)
}#
)
# Add wd to the filename (stripping any prior paths from simfns)#
	for (i in 1:length(simfns))#
		{#
		simfns[i] = get_path_last(simfns[i])#
		simfns[i] = slashslash(paste0(wd, "/", simfns[i]))#
		}#
#
	# Get the area_names and states_list#
	area_names = c(read.table(simfns[8]))[[1]]#
	# states_list = #
	source(simfns[9]) # Creates a states_list#
	# Read in the setup#
	setup_df = read.table(simfns[1], header=TRUE)#
	numareas = setup_df$numareas#
	numstates = setup_df$numstates#
	max_range_size = setup_df$max_range_size#
	if (tolower(setup_df$include_null_range) == "true")#
		{#
		include_null_range = TRUE#
		} else {#
		include_null_range = FALSE#
		}#
#
	# User sets these here!#
	# Set the random number seed, to make it repeatable#
	set.seed(seedval)#
	# Set the max_simulation time -- whatever changing distances you have will be#
	# extended with this timepoint, i.e. the final geography/rates will continue#
	# to this timepoint#
	#start_state = 8 # number of the starting state#
	#max_simulation_time = 15.0 # Set to 0 if the user doesn't want to set a max simulation time#
	#max_tips = NULL#
#
	# Set a maximum rate for extreme cases#
	#max_rate = 10.0#
	# Read timepoints#
	# Read in Q/A matrix, populate one and array#
	# Read in C matrix, populate one and array#
#
	# Load the files#
	#time_grid = seq(0,10,0.1) # About halfway through#
	time_grid = c(read.table(simfns[2], header=FALSE))[[1]]#
#
	# Change from time reading backwards to time reading forwards#
	colnums = rev(1:length(time_grid))#
	time_grid = -1*(max(time_grid) - time_grid) - min(-1*(max(time_grid) - time_grid))#
	time_grid#
	mu_vals_by_t = as.matrix(read.table(simfns[3], header=FALSE))[,colnums]#
	Qvals_by_t = as.matrix(read.table(simfns[4], header=FALSE))[,colnums]#
	Crates_by_t = as.matrix(read.table(simfns[5], header=FALSE))[,colnums]#
	Qarray = read.table(simfns[6], header=TRUE)#
	Carray = read.table(simfns[7], header=TRUE)#
#
	# Add the final time at end of forward simulation, if needed#
	if (max(time_grid) < max_simulation_time)#
		{#
		time_grid = c(time_grid, max_simulation_time)#
		mu_vals_by_t = cbind(mu_vals_by_t, mu_vals_by_t[,ncol(mu_vals_by_t)])#
		Qvals_by_t = cbind(Qvals_by_t, Qvals_by_t[,ncol(Qvals_by_t)])#
		Crates_by_t = cbind(Crates_by_t, Crates_by_t[,ncol(Crates_by_t)])#
		}#
	# Enforce maximum rate on Crates_by_t#
	Crates_by_t[Crates_by_t > max_rate] = max_rate#
	mu_vals_by_t[mu_vals_by_t > max_rate] = max_rate#
#
	# Produce the A transition matrix / array#
	A = array(data=0.0, dim=c(numstates,numstates,length(time_grid)))#
	for (i in 1:length(time_grid))#
		{#
		for (j in 1:nrow(Qarray))#
			{#
			A[Qarray$i[j],Qarray$j[j],i] = Qvals_by_t[j,i]#
			}#
		# Enforce maximum rate#
		A[A > max_rate] = max_rate#
		# Set the diagonal#
		diag(A[,,i]) = 0.0#
		diag(A[,,i]) = -rowSums(A[,,i])#
		}#
#
	# Cladogenetic part of the DEC model#
	# At speciation, we have:#
	# Specify probabilities of different events, given that speciation has occurred#
	# (ADD THESE UP to provide the speciation rates / lambdas)#
#
	# transition_table_C: columns are i, j, k, prob#
	# transition_table_rates_C_matrix: columns are i, j, k, rate #
	# (later, we will add up these rates to get the total lambda by state)#
	transition_table_C = NULL#
	transition_table_probs_C_matrix = array(data=0.0, dim=c(nrow(Crates_by_t), 4, length(time_grid)))#
	transition_table_rates_C_matrix = array(data=0.0, dim=c(nrow(Crates_by_t), 4, length(time_grid)))#
	dim(transition_table_probs_C_matrix)#
	dim(transition_table_rates_C_matrix)#
#
	rates_sums_by_t = NULL#
	for (i in 1:length(time_grid))#
		{#
		tmprates = as.data.frame(cbind(Carray$i, Carray$j, Carray$k, Crates_by_t[,i]), stringsAsFactors=FALSE)#
		names(tmprates) = c("i", "j", "k", "rates_t")#
		# Convert rates to probabilities#
		rates_sums = aggregate(tmprates$rates_t, by=list(tmprates$i), FUN=sum)#
		# Column names#
		names(rates_sums) = c("i", "rates_sum")#
		# Make sure rates_sums are ordered by 'i' (ancestral state index)#
		tmporder = order(rates_sums$i)#
		rates_sums = rates_sums[tmporder,]#
		# Check for null range; add row for "i" if needed#
		if (rates_sums$i[1] == 2)#
			{#
			tmprow = as.data.frame(matrix(data=c(1,0.0), nrow=1), stringsAsFactors=FALSE)#
			names(tmprow) = c("i", "rates_sum")#
			rates_sums = rbind(tmprow, rates_sums)#
			}#
		rates_sums_by_t	= cbind(rates_sums_by_t, rates_sums$rates_sum)#
#
		# Convert rates to probabilities#
		tmpprobs = tmprates#
		names(tmpprobs) = c("i", "j", "k", "probs_t")#
		for (q in 1:nrow(rates_sums))#
			{#
			tmpi = rates_sums$i[q]#
			TF = tmprates$i == tmpi#
#
			tmpprobs$probs_t[TF] = tmprates$rates_t[TF] / rates_sums$rates_sum[q]#
			}#
		transition_table_rates_C_matrix[,,i] = as.matrix(tmprates)#
		transition_table_probs_C_matrix[,,i] = as.matrix(tmpprobs)#
		}#
	# Square transition matrix (not used, but sanity check)#
	transition_matrix_C = array(data=0.0, dim=c(numstates,numstates,1))#
	transition_matrix_C_array = array(data=0.0, dim=c(numstates,numstates,length(time_grid)))#
	for (i in 1:length(time_grid))#
		{#
		for (j in 1:nrow(Carray))#
			{#
			if ((Carray$i[j] == Carray$j[j]) && (Carray$i[j] == Carray$k[j]))#
				{#
				# state i = state j = state k#
				transition_matrix_C_array[Carray$i[j],Carray$j[j],i] = transition_matrix_C_array[Carray$i[j],Carray$j[j],i] + Crates_by_t[j,i] / rates_sums_by_t[Carray$i[j],i]#
				} else {#
				# Otherwise, you have two different "anagenetic" events, with the probability split between them#
				transition_matrix_C_array[Carray$i[j],Carray$j[j],i] = transition_matrix_C_array[Carray$i[j],Carray$j[j],i] + Crates_by_t[j,i] / rates_sums_by_t[Carray$i[j],i] / 2#
				transition_matrix_C_array[Carray$i[j],Carray$k[j],i] = transition_matrix_C_array[Carray$i[j],Carray$k[j],i] + Crates_by_t[j,i] / rates_sums_by_t[Carray$i[j],i] / 2#
				}#
			# Ignore, rates are already doubled if needed#
			# if (Carray$i[j] != Carray$j[j])#
			}#
		# DO NOT set the diagonal on the cladogenetic transition rates#
		#diag(transition_matrix_C_array[,,i]) = 0.0#
		#diag(transition_matrix_C_array[,,i]) = -rowSums(transition_matrix_C_array[,,i])#
#
		# Null range correction#
		if (rowSums(transition_matrix_C_array[,,i])[1] == 0.0)#
			{#
			transition_matrix_C_array[1,1,i] = 1.0#
			}#
		}#
	transition_matrix_C = transition_matrix_C_array[,,dim(transition_matrix_C_array)[3]]#
	transition_matrix_C#
	rowSums(transition_matrix_C)#
	# Check probs#
	for (i in 1:length(time_grid))#
		{#
		tmpprobs = transition_table_probs_C_matrix[,,i]#
		probs_sum = aggregate(tmpprobs[,4], by=list(tmpprobs[,1]), FUN=sum)#
		tmprates = transition_table_rates_C_matrix[,,i]#
		rates_sum = aggregate(tmprates[,4], by=list(tmprates[,1]), FUN=sum)#
		sums_by_i = cbind(rates_sum, probs_sum[,2])#
		names(sums_by_i) = c("i", "rates_sum", "probs_sum")#
		print(sums_by_i)#
		}#
	# convert from 1-based to 0-based indices (turns out this is NOT needed for the C++ code)#
	# transition_table_indices_C = transition_table_C[,1:3] - 1#
	transition_table_indices_C = transition_table_rates_C_matrix[,1:3,1] - 1#
	transition_table_indices_C_matrix = array(data=transition_table_indices_C, dim=c(dim(transition_table_indices_C),length(time_grid)))#
	# transition_table_probs_C1 = transition_table_C[,4]#
	transition_table_probs_C1 = transition_table_probs_C_matrix[,4,1]#
	# Make the arrays for the parameters#
#
	# Probs encoded in a num_clado_events * 2 * num_times array#
	# the "2" just duplicates, ensures we have a 3D array#
	transition_table_probs_C = array(data=0.0, dim=c(nrow(transition_table_indices_C), 2, length(time_grid)))#
#
	# Fill in the transition_matrix_C and transition_table_probs#
	for (i in 1:length(time_grid))#
		{#
		transition_table_probs_C[,1,i] = transition_table_probs_C_matrix[,4,i]#
		transition_table_probs_C[,2,i] = transition_table_probs_C_matrix[,4,i]#
		}#
	parameters = list(birth_rates         = rates_sums_by_t,#
										death_rates         = mu_vals_by_t,#
										transition_matrix_A = A,#
										transition_matrix_C = transition_matrix_C_array,#
										transition_table_indices_C = transition_table_indices_C,#
										transition_table_probs_C = transition_table_probs_C )#
	# simulation#
	sim_done = FALSE#
	trynum = 1#
	while(sim_done == FALSE)#
		{#
		if (trynum > numtries)#
			{#
			txt = paste0("simulate_tdsse2() obtained no qualifying simulations after ", numtries, " tries. Increase numtries, increase max_simulation_time, or reduce max_tips.")#
			cat("\n")#
			cat(txt)#
			cat("\n")#
			sim_done = TRUE#
			return()#
			break()#
			}#
#
		simulation = simulate_tdsse2( Nstates = numstates, #
																parameters = parameters, #
																splines_degree      = 1,#
																start_state = start_state,#
																max_tips = max_tips,#
																max_time = max_simulation_time,#
																time_grid = time_grid,#
																include_birth_times=TRUE,#
																include_death_times=TRUE,#
																coalescent=FALSE)#
#
		if (simulation$success == FALSE)#
			{ trynum=trynum+1; next() }#
#
		if (length(simulation$tree$tip.label) < 3)#
			{ trynum=trynum+1; next() }#
		# Otherwise, proceed#
		simulation2 = reorder_castor_sim_to_default_ape_node_order(simulation)#
		tip_ages_above_root = get_node_ages_of_tips(simulation2$tree)#
		tip_age_tolerance = 1e-6#
		fossils_TF = (max(tip_ages_above_root) - tip_ages_above_root) > tip_age_tolerance#
		num_tips_in_present = sum(fossils_TF == FALSE)#
		# Check for successful simulation#
		if (num_tips_in_present < min_numtaxa)#
			{ trynum=trynum+1; next() }#
#
		} # END while(sim_done == FALSE)
start_state=2; max_simulation_time=15; min_numtaxa=50; max_tips=100; simfns=default_simfns(); seedval=54321; max_rate=10.0; numtries=1000
# Add wd to the filename (stripping any prior paths from simfns)#
	for (i in 1:length(simfns))#
		{#
		simfns[i] = get_path_last(simfns[i])#
		simfns[i] = slashslash(paste0(wd, "/", simfns[i]))#
		}#
#
	# Get the area_names and states_list#
	area_names = c(read.table(simfns[8]))[[1]]#
	# states_list = #
	source(simfns[9]) # Creates a states_list#
	# Read in the setup#
	setup_df = read.table(simfns[1], header=TRUE)#
	numareas = setup_df$numareas#
	numstates = setup_df$numstates#
	max_range_size = setup_df$max_range_size#
	if (tolower(setup_df$include_null_range) == "true")#
		{#
		include_null_range = TRUE#
		} else {#
		include_null_range = FALSE#
		}#
#
	# User sets these here!#
	# Set the random number seed, to make it repeatable#
	set.seed(seedval)#
	# Set the max_simulation time -- whatever changing distances you have will be#
	# extended with this timepoint, i.e. the final geography/rates will continue#
	# to this timepoint#
	#start_state = 8 # number of the starting state#
	#max_simulation_time = 15.0 # Set to 0 if the user doesn't want to set a max simulation time#
	#max_tips = NULL#
#
	# Set a maximum rate for extreme cases#
	#max_rate = 10.0#
	# Read timepoints#
	# Read in Q/A matrix, populate one and array#
	# Read in C matrix, populate one and array#
#
	# Load the files#
	#time_grid = seq(0,10,0.1) # About halfway through#
	time_grid = c(read.table(simfns[2], header=FALSE))[[1]]#
#
	# Change from time reading backwards to time reading forwards#
	colnums = rev(1:length(time_grid))#
	time_grid = -1*(max(time_grid) - time_grid) - min(-1*(max(time_grid) - time_grid))#
	time_grid#
	mu_vals_by_t = as.matrix(read.table(simfns[3], header=FALSE))[,colnums]#
	Qvals_by_t = as.matrix(read.table(simfns[4], header=FALSE))[,colnums]#
	Crates_by_t = as.matrix(read.table(simfns[5], header=FALSE))[,colnums]#
	Qarray = read.table(simfns[6], header=TRUE)#
	Carray = read.table(simfns[7], header=TRUE)#
#
	# Add the final time at end of forward simulation, if needed#
	if (max(time_grid) < max_simulation_time)#
		{#
		time_grid = c(time_grid, max_simulation_time)#
		mu_vals_by_t = cbind(mu_vals_by_t, mu_vals_by_t[,ncol(mu_vals_by_t)])#
		Qvals_by_t = cbind(Qvals_by_t, Qvals_by_t[,ncol(Qvals_by_t)])#
		Crates_by_t = cbind(Crates_by_t, Crates_by_t[,ncol(Crates_by_t)])#
		}#
	# Enforce maximum rate on Crates_by_t#
	Crates_by_t[Crates_by_t > max_rate] = max_rate#
	mu_vals_by_t[mu_vals_by_t > max_rate] = max_rate#
#
	# Produce the A transition matrix / array#
	A = array(data=0.0, dim=c(numstates,numstates,length(time_grid)))#
	for (i in 1:length(time_grid))#
		{#
		for (j in 1:nrow(Qarray))#
			{#
			A[Qarray$i[j],Qarray$j[j],i] = Qvals_by_t[j,i]#
			}#
		# Enforce maximum rate#
		A[A > max_rate] = max_rate#
		# Set the diagonal#
		diag(A[,,i]) = 0.0#
		diag(A[,,i]) = -rowSums(A[,,i])#
		}#
#
	# Cladogenetic part of the DEC model#
	# At speciation, we have:#
	# Specify probabilities of different events, given that speciation has occurred#
	# (ADD THESE UP to provide the speciation rates / lambdas)#
#
	# transition_table_C: columns are i, j, k, prob#
	# transition_table_rates_C_matrix: columns are i, j, k, rate #
	# (later, we will add up these rates to get the total lambda by state)#
	transition_table_C = NULL#
	transition_table_probs_C_matrix = array(data=0.0, dim=c(nrow(Crates_by_t), 4, length(time_grid)))#
	transition_table_rates_C_matrix = array(data=0.0, dim=c(nrow(Crates_by_t), 4, length(time_grid)))#
	dim(transition_table_probs_C_matrix)#
	dim(transition_table_rates_C_matrix)#
#
	rates_sums_by_t = NULL#
	for (i in 1:length(time_grid))#
		{#
		tmprates = as.data.frame(cbind(Carray$i, Carray$j, Carray$k, Crates_by_t[,i]), stringsAsFactors=FALSE)#
		names(tmprates) = c("i", "j", "k", "rates_t")#
		# Convert rates to probabilities#
		rates_sums = aggregate(tmprates$rates_t, by=list(tmprates$i), FUN=sum)#
		# Column names#
		names(rates_sums) = c("i", "rates_sum")#
		# Make sure rates_sums are ordered by 'i' (ancestral state index)#
		tmporder = order(rates_sums$i)#
		rates_sums = rates_sums[tmporder,]#
		# Check for null range; add row for "i" if needed#
		if (rates_sums$i[1] == 2)#
			{#
			tmprow = as.data.frame(matrix(data=c(1,0.0), nrow=1), stringsAsFactors=FALSE)#
			names(tmprow) = c("i", "rates_sum")#
			rates_sums = rbind(tmprow, rates_sums)#
			}#
		rates_sums_by_t	= cbind(rates_sums_by_t, rates_sums$rates_sum)#
#
		# Convert rates to probabilities#
		tmpprobs = tmprates#
		names(tmpprobs) = c("i", "j", "k", "probs_t")#
		for (q in 1:nrow(rates_sums))#
			{#
			tmpi = rates_sums$i[q]#
			TF = tmprates$i == tmpi#
#
			tmpprobs$probs_t[TF] = tmprates$rates_t[TF] / rates_sums$rates_sum[q]#
			}#
		transition_table_rates_C_matrix[,,i] = as.matrix(tmprates)#
		transition_table_probs_C_matrix[,,i] = as.matrix(tmpprobs)#
		}#
	# Square transition matrix (not used, but sanity check)#
	transition_matrix_C = array(data=0.0, dim=c(numstates,numstates,1))#
	transition_matrix_C_array = array(data=0.0, dim=c(numstates,numstates,length(time_grid)))#
	for (i in 1:length(time_grid))#
		{#
		for (j in 1:nrow(Carray))#
			{#
			if ((Carray$i[j] == Carray$j[j]) && (Carray$i[j] == Carray$k[j]))#
				{#
				# state i = state j = state k#
				transition_matrix_C_array[Carray$i[j],Carray$j[j],i] = transition_matrix_C_array[Carray$i[j],Carray$j[j],i] + Crates_by_t[j,i] / rates_sums_by_t[Carray$i[j],i]#
				} else {#
				# Otherwise, you have two different "anagenetic" events, with the probability split between them#
				transition_matrix_C_array[Carray$i[j],Carray$j[j],i] = transition_matrix_C_array[Carray$i[j],Carray$j[j],i] + Crates_by_t[j,i] / rates_sums_by_t[Carray$i[j],i] / 2#
				transition_matrix_C_array[Carray$i[j],Carray$k[j],i] = transition_matrix_C_array[Carray$i[j],Carray$k[j],i] + Crates_by_t[j,i] / rates_sums_by_t[Carray$i[j],i] / 2#
				}#
			# Ignore, rates are already doubled if needed#
			# if (Carray$i[j] != Carray$j[j])#
			}#
		# DO NOT set the diagonal on the cladogenetic transition rates#
		#diag(transition_matrix_C_array[,,i]) = 0.0#
		#diag(transition_matrix_C_array[,,i]) = -rowSums(transition_matrix_C_array[,,i])#
#
		# Null range correction#
		if (rowSums(transition_matrix_C_array[,,i])[1] == 0.0)#
			{#
			transition_matrix_C_array[1,1,i] = 1.0#
			}#
		}#
	transition_matrix_C = transition_matrix_C_array[,,dim(transition_matrix_C_array)[3]]#
	transition_matrix_C#
	rowSums(transition_matrix_C)#
	# Check probs#
	for (i in 1:length(time_grid))#
		{#
		tmpprobs = transition_table_probs_C_matrix[,,i]#
		probs_sum = aggregate(tmpprobs[,4], by=list(tmpprobs[,1]), FUN=sum)#
		tmprates = transition_table_rates_C_matrix[,,i]#
		rates_sum = aggregate(tmprates[,4], by=list(tmprates[,1]), FUN=sum)#
		sums_by_i = cbind(rates_sum, probs_sum[,2])#
		names(sums_by_i) = c("i", "rates_sum", "probs_sum")#
		print(sums_by_i)#
		}#
	# convert from 1-based to 0-based indices (turns out this is NOT needed for the C++ code)#
	# transition_table_indices_C = transition_table_C[,1:3] - 1#
	transition_table_indices_C = transition_table_rates_C_matrix[,1:3,1] - 1#
	transition_table_indices_C_matrix = array(data=transition_table_indices_C, dim=c(dim(transition_table_indices_C),length(time_grid)))#
	# transition_table_probs_C1 = transition_table_C[,4]#
	transition_table_probs_C1 = transition_table_probs_C_matrix[,4,1]#
	# Make the arrays for the parameters#
#
	# Probs encoded in a num_clado_events * 2 * num_times array#
	# the "2" just duplicates, ensures we have a 3D array#
	transition_table_probs_C = array(data=0.0, dim=c(nrow(transition_table_indices_C), 2, length(time_grid)))#
#
	# Fill in the transition_matrix_C and transition_table_probs#
	for (i in 1:length(time_grid))#
		{#
		transition_table_probs_C[,1,i] = transition_table_probs_C_matrix[,4,i]#
		transition_table_probs_C[,2,i] = transition_table_probs_C_matrix[,4,i]#
		}#
	parameters = list(birth_rates         = rates_sums_by_t,#
										death_rates         = mu_vals_by_t,#
										transition_matrix_A = A,#
										transition_matrix_C = transition_matrix_C_array,#
										transition_table_indices_C = transition_table_indices_C,#
										transition_table_probs_C = transition_table_probs_C )#
	# simulation#
	sim_done = FALSE#
	trynum = 1#
	while(sim_done == FALSE)#
		{#
		if (trynum > numtries)#
			{#
			txt = paste0("simulate_tdsse2() obtained no qualifying simulations after ", numtries, " tries. Increase numtries, increase max_simulation_time, or reduce max_tips.")#
			cat("\n")#
			cat(txt)#
			cat("\n")#
			sim_done = TRUE#
			return(warning(txt))#
			break()#
			}#
#
		simulation = simulate_tdsse2( Nstates = numstates, #
																parameters = parameters, #
																splines_degree      = 1,#
																start_state = start_state,#
																max_tips = max_tips,#
																max_time = max_simulation_time,#
																time_grid = time_grid,#
																include_birth_times=TRUE,#
																include_death_times=TRUE,#
																coalescent=FALSE)#
#
		if (simulation$success == FALSE)#
			{ trynum=trynum+1; next() }#
#
		if (length(simulation$tree$tip.label) < 3)#
			{ trynum=trynum+1; next() }#
		# Otherwise, proceed#
		simulation2 = reorder_castor_sim_to_default_ape_node_order(simulation)#
		tip_ages_above_root = get_node_ages_of_tips(simulation2$tree)#
		tip_age_tolerance = 1e-6#
		fossils_TF = (max(tip_ages_above_root) - tip_ages_above_root) > tip_age_tolerance#
		num_tips_in_present = sum(fossils_TF == FALSE)#
		# Check for successful simulation#
		if (num_tips_in_present < min_numtaxa)#
			{ trynum=trynum+1; next() }#
#
		} # END while(sim_done == FALSE)
source("/GitHub/PhyBEARS.jl/Rsrc/castor_helpers.R")#
wd = "/GitHub/PhyBEARS.jl/ex/siminf_v12a/"#
setwd(wd)#
simfns = c("setup_df.txt",#
"timepoints.txt", #
"mu_vals_by_t.txt", #
"Qvals_by_t.txt",#
"Crates_by_t.txt",#
"Qarray.txt",#
"Carray.txt",#
"area_names.txt",#
"states_list.R")#
simulation2 = simulate_tdsse2_for_timeperiod(wd, start_state=2, max_simulation_time=15, min_numtaxa=50, max_tips=100, simfns=default_simfns(), seedval=54321, max_rate=10.0, numtries=1000)
# for: reorder_castor_sim_to_default_ape_node_order(simulation)#
source("/GitHub/PhyBEARS.jl/Rsrc/castor_helpers.R")#
wd = "/GitHub/PhyBEARS.jl/ex/siminf_v12a/"#
setwd(wd)#
simfns = c("setup_df.txt",#
"timepoints.txt", #
"mu_vals_by_t.txt", #
"Qvals_by_t.txt",#
"Crates_by_t.txt",#
"Qarray.txt",#
"Carray.txt",#
"area_names.txt",#
"states_list.R")#
simulation2 = simulate_tdsse2_for_timeperiod(wd, start_state=2, max_simulation_time=12, min_numtaxa=50, max_tips=100, simfns=default_simfns(), seedval=54321, max_rate=10.0, numtries=1000)
# for: reorder_castor_sim_to_default_ape_node_order(simulation)#
source("/GitHub/PhyBEARS.jl/Rsrc/castor_helpers.R")#
wd = "/GitHub/PhyBEARS.jl/ex/siminf_v12a/"#
setwd(wd)#
simfns = c("setup_df.txt",#
"timepoints.txt", #
"mu_vals_by_t.txt", #
"Qvals_by_t.txt",#
"Crates_by_t.txt",#
"Qarray.txt",#
"Carray.txt",#
"area_names.txt",#
"states_list.R")#
simulation2 = simulate_tdsse2_for_timeperiod(wd, start_state=2, max_simulation_time=12, min_numtaxa=50, max_tips=100, simfns=default_simfns(), seedval=54321, max_rate=10.0, numtries=1000)
quantile
?quantile
quantile(num_living_tips, prob=0.025)
source("/GitHub/PhyBEARS.jl/Rsrc/castor_helpers.R")#
wd = "/GitHub/PhyBEARS.jl/ex/siminf_v12a/"#
setwd(wd)#
simfns = c("setup_df.txt",#
"timepoints.txt", #
"mu_vals_by_t.txt", #
"Qvals_by_t.txt",#
"Crates_by_t.txt",#
"Qarray.txt",#
"Carray.txt",#
"area_names.txt",#
"states_list.R")#
simulation2 = simulate_tdsse2_for_timeperiod(wd, start_state=2, max_simulation_time=12, min_numtaxa=50, max_tips=100, simfns=default_simfns(), seedval=54321, max_rate=10.0, numtries=250)
source("/GitHub/PhyBEARS.jl/Rsrc/castor_helpers.R")#
wd = "/GitHub/PhyBEARS.jl/ex/siminf_v12a/"#
setwd(wd)#
simfns = c("setup_df.txt",#
"timepoints.txt", #
"mu_vals_by_t.txt", #
"Qvals_by_t.txt",#
"Crates_by_t.txt",#
"Qarray.txt",#
"Carray.txt",#
"area_names.txt",#
"states_list.R")#
simulation2 = simulate_tdsse2_for_timeperiod(wd, start_state=2, max_simulation_time=12, min_numtaxa=50, max_tips=100, simfns=default_simfns(), seedval=54321, max_rate=10.0, numtries=250)
source("/GitHub/PhyBEARS.jl/Rsrc/castor_helpers.R")#
wd = "/GitHub/PhyBEARS.jl/ex/siminf_v12a/"#
setwd(wd)#
simfns = c("setup_df.txt",#
"timepoints.txt", #
"mu_vals_by_t.txt", #
"Qvals_by_t.txt",#
"Crates_by_t.txt",#
"Qarray.txt",#
"Carray.txt",#
"area_names.txt",#
"states_list.R")#
simulation2 = simulate_tdsse2_for_timeperiod(wd, start_state=2, max_simulation_time=12, min_numtaxa=50, max_tips=100, simfns=default_simfns(), seedval=54321, max_rate=10.0, numtries=250)
for (i in 1:length(simfns))#
		{#
		simfns[i] = get_path_last(simfns[i])#
		simfns[i] = slashslash(paste0(wd, "/", simfns[i]))#
		}#
#
	# Get the area_names and states_list#
	area_names = c(read.table(simfns[8]))[[1]]#
	# states_list = #
	source(simfns[9]) # Creates a states_list#
	# Read in the setup#
	setup_df = read.table(simfns[1], header=TRUE)#
	numareas = setup_df$numareas#
	numstates = setup_df$numstates#
	max_range_size = setup_df$max_range_size#
	if (tolower(setup_df$include_null_range) == "true")#
		{#
		include_null_range = TRUE#
		} else {#
		include_null_range = FALSE#
		}#
#
	# User sets these here!#
	# Set the random number seed, to make it repeatable#
	set.seed(seedval)#
	# Set the max_simulation time -- whatever changing distances you have will be#
	# extended with this timepoint, i.e. the final geography/rates will continue#
	# to this timepoint#
	#start_state = 8 # number of the starting state#
	#max_simulation_time = 15.0 # Set to 0 if the user doesn't want to set a max simulation time#
	#max_tips = NULL#
#
	# Set a maximum rate for extreme cases#
	#max_rate = 10.0#
	# Read timepoints#
	# Read in Q/A matrix, populate one and array#
	# Read in C matrix, populate one and array#
#
	# Load the files#
	#time_grid = seq(0,10,0.1) # About halfway through#
	time_grid = c(read.table(simfns[2], header=FALSE))[[1]]#
#
	# Change from time reading backwards to time reading forwards#
	colnums = rev(1:length(time_grid))#
	time_grid = -1*(max(time_grid) - time_grid) - min(-1*(max(time_grid) - time_grid))#
	time_grid#
	mu_vals_by_t = as.matrix(read.table(simfns[3], header=FALSE))[,colnums]#
	Qvals_by_t = as.matrix(read.table(simfns[4], header=FALSE))[,colnums]#
	Crates_by_t = as.matrix(read.table(simfns[5], header=FALSE))[,colnums]#
	Qarray = read.table(simfns[6], header=TRUE)#
	Carray = read.table(simfns[7], header=TRUE)#
#
	# Add the final time at end of forward simulation, if needed#
	if (max(time_grid) < max_simulation_time)#
		{#
		time_grid = c(time_grid, max_simulation_time)#
		mu_vals_by_t = cbind(mu_vals_by_t, mu_vals_by_t[,ncol(mu_vals_by_t)])#
		Qvals_by_t = cbind(Qvals_by_t, Qvals_by_t[,ncol(Qvals_by_t)])#
		Crates_by_t = cbind(Crates_by_t, Crates_by_t[,ncol(Crates_by_t)])#
		}#
	# Enforce maximum rate on Crates_by_t#
	Crates_by_t[Crates_by_t > max_rate] = max_rate#
	mu_vals_by_t[mu_vals_by_t > max_rate] = max_rate#
#
	# Produce the A transition matrix / array#
	A = array(data=0.0, dim=c(numstates,numstates,length(time_grid)))#
	for (i in 1:length(time_grid))#
		{#
		for (j in 1:nrow(Qarray))#
			{#
			A[Qarray$i[j],Qarray$j[j],i] = Qvals_by_t[j,i]#
			}#
		# Enforce maximum rate#
		A[A > max_rate] = max_rate#
		# Set the diagonal#
		diag(A[,,i]) = 0.0#
		diag(A[,,i]) = -rowSums(A[,,i])#
		}#
#
	# Cladogenetic part of the DEC model#
	# At speciation, we have:#
	# Specify probabilities of different events, given that speciation has occurred#
	# (ADD THESE UP to provide the speciation rates / lambdas)#
#
	# transition_table_C: columns are i, j, k, prob#
	# transition_table_rates_C_matrix: columns are i, j, k, rate #
	# (later, we will add up these rates to get the total lambda by state)#
	transition_table_C = NULL#
	transition_table_probs_C_matrix = array(data=0.0, dim=c(nrow(Crates_by_t), 4, length(time_grid)))#
	transition_table_rates_C_matrix = array(data=0.0, dim=c(nrow(Crates_by_t), 4, length(time_grid)))#
	dim(transition_table_probs_C_matrix)#
	dim(transition_table_rates_C_matrix)#
#
	rates_sums_by_t = NULL#
	for (i in 1:length(time_grid))#
		{#
		tmprates = as.data.frame(cbind(Carray$i, Carray$j, Carray$k, Crates_by_t[,i]), stringsAsFactors=FALSE)#
		names(tmprates) = c("i", "j", "k", "rates_t")#
		# Convert rates to probabilities#
		rates_sums = aggregate(tmprates$rates_t, by=list(tmprates$i), FUN=sum)#
		# Column names#
		names(rates_sums) = c("i", "rates_sum")#
		# Make sure rates_sums are ordered by 'i' (ancestral state index)#
		tmporder = order(rates_sums$i)#
		rates_sums = rates_sums[tmporder,]#
		# Check for null range; add row for "i" if needed#
		if (rates_sums$i[1] == 2)#
			{#
			tmprow = as.data.frame(matrix(data=c(1,0.0), nrow=1), stringsAsFactors=FALSE)#
			names(tmprow) = c("i", "rates_sum")#
			rates_sums = rbind(tmprow, rates_sums)#
			}#
		rates_sums_by_t	= cbind(rates_sums_by_t, rates_sums$rates_sum)#
#
		# Convert rates to probabilities#
		tmpprobs = tmprates#
		names(tmpprobs) = c("i", "j", "k", "probs_t")#
		for (q in 1:nrow(rates_sums))#
			{#
			tmpi = rates_sums$i[q]#
			TF = tmprates$i == tmpi#
#
			tmpprobs$probs_t[TF] = tmprates$rates_t[TF] / rates_sums$rates_sum[q]#
			}#
		transition_table_rates_C_matrix[,,i] = as.matrix(tmprates)#
		transition_table_probs_C_matrix[,,i] = as.matrix(tmpprobs)#
		}#
	# Square transition matrix (not used, but sanity check)#
	transition_matrix_C = array(data=0.0, dim=c(numstates,numstates,1))#
	transition_matrix_C_array = array(data=0.0, dim=c(numstates,numstates,length(time_grid)))#
	for (i in 1:length(time_grid))#
		{#
		for (j in 1:nrow(Carray))#
			{#
			if ((Carray$i[j] == Carray$j[j]) && (Carray$i[j] == Carray$k[j]))#
				{#
				# state i = state j = state k#
				transition_matrix_C_array[Carray$i[j],Carray$j[j],i] = transition_matrix_C_array[Carray$i[j],Carray$j[j],i] + Crates_by_t[j,i] / rates_sums_by_t[Carray$i[j],i]#
				} else {#
				# Otherwise, you have two different "anagenetic" events, with the probability split between them#
				transition_matrix_C_array[Carray$i[j],Carray$j[j],i] = transition_matrix_C_array[Carray$i[j],Carray$j[j],i] + Crates_by_t[j,i] / rates_sums_by_t[Carray$i[j],i] / 2#
				transition_matrix_C_array[Carray$i[j],Carray$k[j],i] = transition_matrix_C_array[Carray$i[j],Carray$k[j],i] + Crates_by_t[j,i] / rates_sums_by_t[Carray$i[j],i] / 2#
				}#
			# Ignore, rates are already doubled if needed#
			# if (Carray$i[j] != Carray$j[j])#
			}#
		# DO NOT set the diagonal on the cladogenetic transition rates#
		#diag(transition_matrix_C_array[,,i]) = 0.0#
		#diag(transition_matrix_C_array[,,i]) = -rowSums(transition_matrix_C_array[,,i])#
#
		# Null range correction#
		if (rowSums(transition_matrix_C_array[,,i])[1] == 0.0)#
			{#
			transition_matrix_C_array[1,1,i] = 1.0#
			}#
		}#
	transition_matrix_C = transition_matrix_C_array[,,dim(transition_matrix_C_array)[3]]#
	transition_matrix_C#
	rowSums(transition_matrix_C)#
	# Check probs#
	for (i in 1:length(time_grid))#
		{#
		tmpprobs = transition_table_probs_C_matrix[,,i]#
		probs_sum = aggregate(tmpprobs[,4], by=list(tmpprobs[,1]), FUN=sum)#
		tmprates = transition_table_rates_C_matrix[,,i]#
		rates_sum = aggregate(tmprates[,4], by=list(tmprates[,1]), FUN=sum)#
		sums_by_i = cbind(rates_sum, probs_sum[,2])#
		names(sums_by_i) = c("i", "rates_sum", "probs_sum")#
		#print(sums_by_i)#
		}#
	# convert from 1-based to 0-based indices (turns out this is NOT needed for the C++ code)#
	# transition_table_indices_C = transition_table_C[,1:3] - 1#
	transition_table_indices_C = transition_table_rates_C_matrix[,1:3,1] - 1#
	transition_table_indices_C_matrix = array(data=transition_table_indices_C, dim=c(dim(transition_table_indices_C),length(time_grid)))#
	# transition_table_probs_C1 = transition_table_C[,4]#
	transition_table_probs_C1 = transition_table_probs_C_matrix[,4,1]#
	# Make the arrays for the parameters#
#
	# Probs encoded in a num_clado_events * 2 * num_times array#
	# the "2" just duplicates, ensures we have a 3D array#
	transition_table_probs_C = array(data=0.0, dim=c(nrow(transition_table_indices_C), 2, length(time_grid)))#
#
	# Fill in the transition_matrix_C and transition_table_probs#
	for (i in 1:length(time_grid))#
		{#
		transition_table_probs_C[,1,i] = transition_table_probs_C_matrix[,4,i]#
		transition_table_probs_C[,2,i] = transition_table_probs_C_matrix[,4,i]#
		}#
	parameters = list(birth_rates         = rates_sums_by_t,#
										death_rates         = mu_vals_by_t,#
										transition_matrix_A = A,#
										transition_matrix_C = transition_matrix_C_array,#
										transition_table_indices_C = transition_table_indices_C,#
										transition_table_probs_C = transition_table_probs_C )#
	# simulation#
	sim_done = FALSE#
	trynum = 1#
	num_living_tips = NULL#
	while(sim_done == FALSE)#
		{#
		if (trynum > numtries)#
			{#
			meanval = round(mean(num_living_tips), digits=2)#
			lower95 = round(quantile(num_living_tips, prob=0.025), digits=2)#
			upper95 = round(quantile(num_living_tips, prob=0.975), digits=2)#
			minval = min(num_living_tips)#
			maxval = max(num_living_tips)#
			txt2 = paste0("Simulation averages: ", meanval, " (95% quantile: ", lower95, ", ", upper95, "), range: (", minval, ", ", maxval, ").")#
			txt = paste0("simulate_tdsse2() obtained no qualifying simulations after ", numtries, " tries. Increase numtries, increase max_simulation_time, or reduce max_tips.")#
			cat("\n")#
			cat(txt)#
			cat("\n")#
			cat(txt2)#
			cat("\n")#
			sim_done = TRUE#
			return(warning(txt))#
			break()#
			}#
#
		simulation = simulate_tdsse2( Nstates = numstates, #
																parameters = parameters, #
																splines_degree      = 1,#
																start_state = start_state,#
																max_tips = max_tips,#
																max_time = max_simulation_time,#
																time_grid = time_grid,#
																include_birth_times=TRUE,#
																include_death_times=TRUE,#
																coalescent=FALSE)#
#
		if (simulation$success == FALSE)#
			{ trynum=trynum+1; next() }#
#
		if (length(simulation$tree$tip.label) < 3)#
			{ trynum=trynum+1; next() }#
		# Otherwise, proceed#
		simulation2 = reorder_castor_sim_to_default_ape_node_order(simulation)#
		tip_ages_above_root = get_node_ages_of_tips(simulation2$tree)#
		tip_age_tolerance = 1e-6#
		fossils_TF = (max(tip_ages_above_root) - tip_ages_above_root) > tip_age_tolerance#
		num_tips_in_present = sum(fossils_TF == FALSE)#
		num_living_tips = c(num_living_tips, num_tips_in_present)#
		# Check for successful simulation#
		if (num_tips_in_present < min_numtaxa)#
			{ trynum=trynum+1; next() }#
		# All checks passed; so keep the tree#
		sim_done = TRUE#
		} # END while(sim_done == FALSE)#
		# Otherwise, proceed#
		# 1. output a successful simulation#
		# 2. save to a living tree and complete tree#
		tr = simulation2$tree#
		tr$node.label = paste0("in", (length(tr$tip.label):(length(tr$tip.label)+tr$Nnode)))#
		tr$tip.label = paste0("sp", tr$tip.label)#
		tips_to_drop = tr$tip.label[fossils_TF]#
		living_tree = drop.tip(phy=tr, tip=tips_to_drop)#
		full_tree_tipnode_labels = c(tr$node.label, tr$tip.label)#
		living_tree_tipnode_labels = c(living_tree$node.label, living_tree$tip.label)#
		index_in_fulltree_matching_living_tree_node = match(living_tree$node.label, table=tr$node.label)#
		length(index_in_fulltree_matching_living_tree_node)#
		length(living_tree$node.label)#
		length(tr$node.label)#
#
		index_in_fulltree_matching_living_tree_tipnode = match(living_tree_tipnode_labels, table=full_tree_tipnode_labels)#
		length(index_in_fulltree_matching_living_tree_tipnode)#
		length(living_tree_tipnode_labels)#
		length(full_tree_tipnode_labels)#
		#trtable_all = prt(t=tr, printflag=FALSE, get_tipnames=TRUE)#
		#trtable_living = prt(t=living_tree, printflag=FALSE, get_tipnames=TRUE)#
		outfn = slashslash(paste0(wd, "/", "living_tree.newick"))#
		write.tree(living_tree, file=outfn)#
		outfn = slashslash(paste0(wd, "/", "full_tree.newick"))#
		write.tree(tr, file=outfn)#
		outfn = slashslash(paste0(wd, "/", "tree_wFossils.newick"))#
		write.tree(tr, file=outfn)#
		#	3. geog files for both#
		# Write out the geography files#
		all_tip_states = simulation2$tip_states#
		tipnames = tr$tip.label#
		tmpdf = NULL#
		for (i in 1:length(all_tip_states))#
			{#
			tmprow = rep(0, times=length(area_names))#
			tmpstate = states_list[all_tip_states[i]][[1]]#
			tmprow[tmpstate] = 1#
			tmpdf = rbind(tmpdf, tmprow)#
			}#
		tmpdf = as.data.frame(tmpdf)#
		names(tmpdf) = area_names#
		row.names(tmpdf) = paste0("sp", names(all_tip_states))#
		tipranges = define_tipranges_object(tmpdf=tmpdf)#
		lgdata_fn = slashslash(paste0(wd, "/", "geog_wFossils.data"))#
		save_tipranges_to_LagrangePHYLIP(tipranges, lgdata_fn=lgdata_fn, areanames=area_names)#
		# Subset to living-only#
		rows_to_drop_TF = row.names(tmpdf) %in% tips_to_drop#
		rows_to_keep_TF = rows_to_drop_TF == FALSE#
		tmpdf2 = tmpdf[rows_to_keep_TF,]#
		tipranges2 = define_tipranges_object(tmpdf=tmpdf2)#
		lgdata_fn = slashslash(paste0(wd, "/", "geog_living.data"))#
		save_tipranges_to_LagrangePHYLIP(tipranges2, lgdata_fn=lgdata_fn, areanames=area_names)#
		#	4. save the Rdata file#
		outfn = slashslash(paste0(wd, "/", "simulation2.Rdata"))#
		save(simulation2, file=outfn)#
		#	5. save the states at tips & nodes#
		outfn = slashslash(paste0(wd, "/", "simstates_all.txt"))#
		write.table(unname(simulation2$simstates), file=outfn)#
#
		outfn = slashslash(paste0(wd, "/", "simstates_living.txt"))#
		write.table(unname(simulation2$simstates[index_in_fulltree_matching_living_tree_tipnode]), file=outfn)
simulation2$tree = tr#
		simulation2$tree_living = living_tree#
		simulation2$simstates_all = simulation2$simstates
simulation2$simstates_all
simulation2$simstates
simulation2$states
names(simulation2$tip_states)
length(tr$tip_states)
length(tr$tip.label)
tr$node.label
length( tr$node.label)
source("/GitHub/PhyBEARS.jl/Rsrc/castor_helpers.R")#
wd = "/GitHub/PhyBEARS.jl/ex/siminf_v12a/"#
setwd(wd)#
simfns = c("setup_df.txt",#
"timepoints.txt", #
"mu_vals_by_t.txt", #
"Qvals_by_t.txt",#
"Crates_by_t.txt",#
"Qarray.txt",#
"Carray.txt",#
"area_names.txt",#
"states_list.R")#
simulation2 = simulate_tdsse2_for_timeperiod(wd, start_state=2, max_simulation_time=12, min_numtaxa=50, max_tips=100, simfns=default_simfns(), seedval=54321, max_rate=10.0, numtries=250)
simulation2 = simulate_tdsse2_for_timeperiod(wd, start_state=2, max_simulation_time=12, min_numtaxa=1000, max_tips=1001, simfns=default_simfns(), seedval=54321, max_rate=10.0, numtries=250)
source("/GitHub/PhyBEARS.jl/Rsrc/castor_helpers.R")#
wd = "/GitHub/PhyBEARS.jl/ex/siminf_v12a/"#
setwd(wd)#
simfns = c("setup_df.txt",#
"timepoints.txt", #
"mu_vals_by_t.txt", #
"Qvals_by_t.txt",#
"Crates_by_t.txt",#
"Qarray.txt",#
"Carray.txt",#
"area_names.txt",#
"states_list.R")#
simulation2 = simulate_tdsse2_for_timeperiod(wd, start_state=2, max_simulation_time=12, min_numtaxa=1000, max_tips=1001, simfns=default_simfns(), seedval=54321, max_rate=10.0, numtries=250)
simulation2 = simulate_tdsse2_for_timeperiod(wd, start_state=2, max_simulation_time=12, min_numtaxa=50, max_tips=10, simfns=default_simfns(), seedval=54321, max_rate=10.0, numtries=250)
library(cladoRcpp)#
library(BioGeoBEARS)#
library(ape)#
library(castor)#
#
# for: reorder_castor_sim_to_default_ape_node_order(simulation)#
source("/GitHub/PhyBEARS.jl/Rsrc/castor_helpers.R")#
#
wd = "/GitHub/PhyBEARS.jl/ex/siminf_v12a/"#
setwd(wd)#
simfns = c("setup_df.txt",#
"timepoints.txt", #
"mu_vals_by_t.txt", #
"Qvals_by_t.txt",#
"Crates_by_t.txt",#
"Qarray.txt",#
"Carray.txt",#
"area_names.txt",#
"states_list.R")#
simulation2 = simulate_tdsse2_for_timeperiod(wd, start_state=2, max_simulation_time=12, min_numtaxa=50, max_tips=10, simfns=default_simfns(), seedval=54321, max_rate=10.0, numtries=250)
source("/GitHub/PhyBEARS.jl/Rsrc/castor_helpers.R")#
#
wd = "/GitHub/PhyBEARS.jl/ex/siminf_v12a/"#
setwd(wd)#
simfns = c("setup_df.txt",#
"timepoints.txt", #
"mu_vals_by_t.txt", #
"Qvals_by_t.txt",#
"Crates_by_t.txt",#
"Qarray.txt",#
"Carray.txt",#
"area_names.txt",#
"states_list.R")#
simulation2 = simulate_tdsse2_for_timeperiod(wd, start_state=2, max_simulation_time=12, min_numtaxa=50, max_numtaxa=10, simfns=default_simfns(), seedval=54321, max_rate=10.0, numtries=250)
simulation2 = simulate_tdsse2_for_timeperiod(wd, start_state=2, max_simulation_time=12, min_numtaxa=50, max_numtaxa=50, simfns=default_simfns(), seedval=54321, max_rate=10.0, numtries=250)
source("/GitHub/PhyBEARS.jl/Rsrc/castor_helpers.R")#
#
wd = "/GitHub/PhyBEARS.jl/ex/siminf_v12a/"#
setwd(wd)#
simfns = c("setup_df.txt",#
"timepoints.txt", #
"mu_vals_by_t.txt", #
"Qvals_by_t.txt",#
"Crates_by_t.txt",#
"Qarray.txt",#
"Carray.txt",#
"area_names.txt",#
"states_list.R")#
simulation2 = simulate_tdsse2_for_timeperiod(wd, start_state=2, max_simulation_time=12, min_numtaxa=50, max_numtaxa=50, simfns=default_simfns(), seedval=54321, max_rate=10.0, numtries=250)
# for: reorder_castor_sim_to_default_ape_node_order(simulation)#
source("/GitHub/PhyBEARS.jl/Rsrc/castor_helpers.R")#
#
wd = "/GitHub/PhyBEARS.jl/ex/siminf_v12a/"#
setwd(wd)#
simfns = c("setup_df.txt",#
"timepoints.txt", #
"mu_vals_by_t.txt", #
"Qvals_by_t.txt",#
"Crates_by_t.txt",#
"Qarray.txt",#
"Carray.txt",#
"area_names.txt",#
"states_list.R")#
simulation2 = simulate_tdsse2_for_timeperiod(wd, start_state=2, max_simulation_time=12, min_tips=50, max_tips=10, simfns=default_simfns(), seedval=54321, max_rate=10.0, numtries=250)
simulation2 = simulate_tdsse2_for_timeperiod(wd, start_state=2, max_simulation_time=12, min_tips=50, max_tips=50, simfns=default_simfns(), seedval=54321, max_rate=10.0, numtries=250)
/GitHub/PhyBEARS.jl/sims/sunkNZ_v1/sunkNZ_generate_files_v1.jl
library(cladoRcpp)#
library(BioGeoBEARS)#
library(ape)#
library(castor)#
#
# for: reorder_castor_sim_to_default_ape_node_order(simulation)#
source("/GitHub/PhyBEARS.jl/Rsrc/castor_helpers.R")#
#
wd = "/GitHub/PhyBEARS.jl/ex/siminf_v12a/"#
setwd(wd)#
simfns = c("setup_df.txt",#
"timepoints.txt", #
"mu_vals_by_t.txt", #
"Qvals_by_t.txt",#
"Crates_by_t.txt",#
"Qarray.txt",#
"Carray.txt",#
"area_names.txt",#
"states_list.R")#
simulation2 = simulate_tdsse2_for_timeperiod(wd, start_state=2, max_simulation_time=12, min_tips=50, max_tips=50, simfns=default_simfns(), seedval=54321, max_rate=10.0, numtries=250)
library(cladoRcpp)#
library(BioGeoBEARS)#
library(ape)#
library(castor)#
#
# for: reorder_castor_sim_to_default_ape_node_order(simulation)#
source("/GitHub/PhyBEARS.jl/Rsrc/castor_helpers.R")#
#
wd = "/GitHub/PhyBEARS.jl/sims/sunkNZ_v1/"#
setwd(wd)#
simfns = c("setup_df.txt",#
"timepoints.txt", #
"mu_vals_by_t.txt", #
"Qvals_by_t.txt",#
"Crates_by_t.txt",#
"Qarray.txt",#
"Carray.txt",#
"area_names.txt",#
"states_list.R")#
simulation2 = simulate_tdsse2_for_timeperiod(wd, start_state=2, max_simulation_time=12, min_tips=50, max_tips=50, simfns=default_simfns(), seedval=54321, max_rate=10.0, numtries=250)
get_node_ages_of_tips
# for: reorder_castor_sim_to_default_ape_node_order(simulation)#
source("/GitHub/PhyBEARS.jl/Rsrc/castor_helpers.R")#
#
wd = "/GitHub/PhyBEARS.jl/sims/sunkNZ_v1/"#
setwd(wd)#
simfns = c("setup_df.txt",#
"timepoints.txt", #
"mu_vals_by_t.txt", #
"Qvals_by_t.txt",#
"Crates_by_t.txt",#
"Qarray.txt",#
"Carray.txt",#
"area_names.txt",#
"states_list.R")#
simulation2 = simulate_tdsse2_for_timeperiod(wd, start_state=2, max_simulation_time=12, min_tips=50, max_tips=50, simfns=default_simfns(), seedval=54321, max_rate=10.0, numtries=250)
round(root_age, digits2)
root_age=23.2352
round(root_age, digits2)
round(root_age, digits)
round(root_age, digits=2)
library(cladoRcpp)#
library(BioGeoBEARS)#
library(ape)#
library(castor)#
#
# for: reorder_castor_sim_to_default_ape_node_order(simulation)#
source("/GitHub/PhyBEARS.jl/Rsrc/castor_helpers.R")#
#
wd = "/GitHub/PhyBEARS.jl/sims/sunkNZ_v1/"#
setwd(wd)#
simfns = c("setup_df.txt",#
"timepoints.txt", #
"mu_vals_by_t.txt", #
"Qvals_by_t.txt",#
"Crates_by_t.txt",#
"Qarray.txt",#
"Carray.txt",#
"area_names.txt",#
"states_list.R")#
simulation2 = simulate_tdsse2_for_timeperiod(wd, start_state=2, max_simulation_time=100.0, min_tips=50, max_tips=500, simfns=default_simfns(), seedval=54321, max_rate=10.0, numtries=250)
pars = optx;#
inputs.bmo.est[inputs.bmo.type .== "free"] .= pars;#
inputs.bmo.est[bmo.rownames = "birthRate"] = inputs.bmo.est[bmo.rownames = "birthRate"] / 20
library(cladoRcpp)#
library(BioGeoBEARS)#
library(ape)#
library(castor)#
#
# for: reorder_castor_sim_to_default_ape_node_order(simulation)#
source("/GitHub/PhyBEARS.jl/Rsrc/castor_helpers.R")#
#
wd = "/GitHub/PhyBEARS.jl/sims/sunkNZ_v1/"#
setwd(wd)#
simfns = c("setup_df.txt",#
"timepoints.txt", #
"mu_vals_by_t.txt", #
"Qvals_by_t.txt",#
"Crates_by_t.txt",#
"Qarray.txt",#
"Carray.txt",#
"area_names.txt",#
"states_list.R")#
simulation2 = simulate_tdsse2_for_timeperiod(wd, start_state=2, max_simulation_time=100.0, min_tips=50, max_tips=500, simfns=default_simfns(), seedval=54321, max_rate=10.0, numtries=250)
pars = optx;#
inputs.bmo.est[inputs.bmo.type .== "free"] .= pars;#
inputs.bmo.est[bmo.rownames .== "birthRate"] = inputs.bmo.est[bmo.rownames .== "birthRate"] / 10#
bmo_updater_v1!(inputs.bmo);#
res = inputs.res;#
#
# Solution, under best ML parameters#
p_Ds_v5_updater_v1!(p_Ds_v12, inputs);#
p_Es_v12 = TimeDep.construct_QC_interpolators(p_Ds_v12, p_Ds_v12.interpolators.times_for_SSE_interpolators);
library(cladoRcpp)#
library(BioGeoBEARS)#
library(ape)#
library(castor)#
#
# for: reorder_castor_sim_to_default_ape_node_order(simulation)#
source("/GitHub/PhyBEARS.jl/Rsrc/castor_helpers.R")#
#
wd = "/GitHub/PhyBEARS.jl/sims/sunkNZ_v1/"#
setwd(wd)#
simfns = c("setup_df.txt",#
"timepoints.txt", #
"mu_vals_by_t.txt", #
"Qvals_by_t.txt",#
"Crates_by_t.txt",#
"Qarray.txt",#
"Carray.txt",#
"area_names.txt",#
"states_list.R")#
simulation2 = simulate_tdsse2_for_timeperiod(wd, start_state=2, max_simulation_time=100.0, min_tips=50, max_tips=500, simfns=default_simfns(), seedval=54321, max_rate=10.0, numtries=250)
pars = optx;#
inputs.bmo.est[inputs.bmo.type .== "free"] .= pars;#
inputs.bmo.est[bmo.rownames .== "birthRate"] = inputs.bmo.est[bmo.rownames .== "birthRate"] / 10
library(cladoRcpp)#
library(BioGeoBEARS)#
library(ape)#
library(castor)#
#
# for: reorder_castor_sim_to_default_ape_node_order(simulation)#
source("/GitHub/PhyBEARS.jl/Rsrc/castor_helpers.R")#
#
wd = "/GitHub/PhyBEARS.jl/sims/sunkNZ_v1/"#
setwd(wd)#
simfns = c("setup_df.txt",#
"timepoints.txt", #
"mu_vals_by_t.txt", #
"Qvals_by_t.txt",#
"Crates_by_t.txt",#
"Qarray.txt",#
"Carray.txt",#
"area_names.txt",#
"states_list.R")#
simulation2 = simulate_tdsse2_for_timeperiod(wd, start_state=2, max_simulation_time=100.0, min_tips=50, max_tips=500, simfns=default_simfns(), seedval=54321, max_rate=10.0, numtries=250)
library(cladoRcpp)#
library(BioGeoBEARS)#
library(ape)#
library(castor)#
#
# for: reorder_castor_sim_to_default_ape_node_order(simulation)#
source("/GitHub/PhyBEARS.jl/Rsrc/castor_helpers.R")#
#
wd = "/GitHub/PhyBEARS.jl/sims/sunkNZ_v1/"#
setwd(wd)#
simfns = c("setup_df.txt",#
"timepoints.txt", #
"mu_vals_by_t.txt", #
"Qvals_by_t.txt",#
"Crates_by_t.txt",#
"Qarray.txt",#
"Carray.txt",#
"area_names.txt",#
"states_list.R")#
simulation2 = simulate_tdsse2_for_timeperiod(wd, start_state=2, max_simulation_time=100.0, min_tips=50, max_tips=500, simfns=default_simfns(), seedval=54321, max_rate=10.0, numtries=250)
library(cladoRcpp)#
library(BioGeoBEARS)#
library(ape)#
library(castor)#
#
# for: reorder_castor_sim_to_default_ape_node_order(simulation)#
source("/GitHub/PhyBEARS.jl/Rsrc/castor_helpers.R")#
#
wd = "/GitHub/PhyBEARS.jl/sims/sunkNZ_v1/"#
setwd(wd)#
simfns = c("setup_df.txt",#
"timepoints.txt", #
"mu_vals_by_t.txt", #
"Qvals_by_t.txt",#
"Crates_by_t.txt",#
"Qarray.txt",#
"Carray.txt",#
"area_names.txt",#
"states_list.R")#
simulation2 = simulate_tdsse2_for_timeperiod(wd, start_state=2, max_simulation_time=100.0, min_tips=50, max_tips=500, simfns=default_simfns(), seedval=54321, max_rate=10.0, numtries=250)
library(cladoRcpp)#
library(BioGeoBEARS)#
library(ape)#
library(castor)#
#
# for: reorder_castor_sim_to_default_ape_node_order(simulation)#
source("/GitHub/PhyBEARS.jl/Rsrc/castor_helpers.R")#
#
wd = "/GitHub/PhyBEARS.jl/sims/sunkNZ_v1/"#
setwd(wd)#
simfns = c("setup_df.txt",#
"timepoints.txt", #
"mu_vals_by_t.txt", #
"Qvals_by_t.txt",#
"Crates_by_t.txt",#
"Qarray.txt",#
"Carray.txt",#
"area_names.txt",#
"states_list.R")#
simulation2 = simulate_tdsse2_for_timeperiod(wd, start_state=2, max_simulation_time=100.0, min_tips=50, max_tips=500, simfns=default_simfns(), seedval=54321, max_rate=10.0, numtries=250)
library(cladoRcpp)#
library(BioGeoBEARS)#
library(ape)#
library(castor)#
#
# for: reorder_castor_sim_to_default_ape_node_order(simulation)#
source("/GitHub/PhyBEARS.jl/Rsrc/castor_helpers.R")#
#
wd = "/GitHub/PhyBEARS.jl/sims/sunkNZ_v1/"#
setwd(wd)#
simfns = c("setup_df.txt",#
"timepoints.txt", #
"mu_vals_by_t.txt", #
"Qvals_by_t.txt",#
"Crates_by_t.txt",#
"Qarray.txt",#
"Carray.txt",#
"area_names.txt",#
"states_list.R")#
simulation2 = simulate_tdsse2_for_timeperiod(wd, start_state=2, max_simulation_time=100.0, min_tips=50, max_tips=500, simfns=default_simfns(), seedval=54321, max_rate=10.0, numtries=250)
simulation2 = simulate_tdsse2_for_timeperiod(wd, start_state=2, max_simulation_time=100.0, min_tips=50, max_tips=500, simfns=default_simfns(), seedval=543221, max_rate=10.0, numtries=250)
library(cladoRcpp)#
library(BioGeoBEARS)#
library(ape)#
library(castor)#
#
# for: reorder_castor_sim_to_default_ape_node_order(simulation)#
source("/GitHub/PhyBEARS.jl/Rsrc/castor_helpers.R")#
#
wd = "/GitHub/PhyBEARS.jl/sims/sunkNZ_v1/"#
setwd(wd)#
simfns = c("setup_df.txt",#
"timepoints.txt", #
"mu_vals_by_t.txt", #
"Qvals_by_t.txt",#
"Crates_by_t.txt",#
"Qarray.txt",#
"Carray.txt",#
"area_names.txt",#
"states_list.R")#
simulation2 = simulate_tdsse2_for_timeperiod(wd, start_state=2, max_simulation_time=100.0, min_tips=50, max_tips=500, simfns=default_simfns(), seedval=543221, max_rate=10.0, numtries=250)
get_root_age(simulation2)
get_root_age(simulation2)get_root_age <= function(tr)#
	{#
	tip_ages_above_root = get_node_ages_of_tips(simulation2$tree)#
	root_age = max(tip_ages_above_root)#
	return(root_age)#
	}
get_root_age <= function(tr)#
	{#
	tip_ages_above_root = get_node_ages_of_tips(simulation2$tree)#
	root_age = max(tip_ages_above_root)#
	return(root_age)#
	}
get_root_age <- function(tr)#
	{#
	tip_ages_above_root = get_node_ages_of_tips(simulation2$tree)#
	root_age = max(tip_ages_above_root)#
	return(root_age)#
	}
simulation2 = simulate_tdsse2_for_timeperiod(wd, start_state=2, max_simulation_time=100.0, min_tips=50, max_tips=500, simfns=default_simfns(), seedval=543221, max_rate=10.0, numtries=250)#
get_root_age(simulation2$tree)#
get_root_age(simulation2$living_tree)
library(cladoRcpp)#
library(BioGeoBEARS)#
library(ape)#
library(castor)#
#
# for: reorder_castor_sim_to_default_ape_node_order(simulation)#
source("/GitHub/PhyBEARS.jl/Rsrc/castor_helpers.R")#
#
wd = "/GitHub/PhyBEARS.jl/sims/sunkNZ_v1/"#
setwd(wd)#
simfns = c("setup_df.txt",#
"timepoints.txt", #
"mu_vals_by_t.txt", #
"Qvals_by_t.txt",#
"Crates_by_t.txt",#
"Qarray.txt",#
"Carray.txt",#
"area_names.txt",#
"states_list.R")#
simulation2 = simulate_tdsse2_for_timeperiod(wd, start_state=2, max_simulation_time=100.0, min_tips=50, max_tips=500, simfns=default_simfns(), seedval=543221, max_rate=10.0, numtries=250)#
get_root_age(simulation2$tree)#
get_root_age(simulation2$living_tree)
library(cladoRcpp)#
library(BioGeoBEARS)#
library(ape)#
library(castor)#
#
# for: reorder_castor_sim_to_default_ape_node_order(simulation)#
source("/GitHub/PhyBEARS.jl/Rsrc/castor_helpers.R")#
#
wd = "/GitHub/PhyBEARS.jl/sims/sunkNZ_v1/"#
setwd(wd)#
simfns = c("setup_df.txt",#
"timepoints.txt", #
"mu_vals_by_t.txt", #
"Qvals_by_t.txt",#
"Crates_by_t.txt",#
"Qarray.txt",#
"Carray.txt",#
"area_names.txt",#
"states_list.R")#
simulation2 = simulate_tdsse2_for_timeperiod(wd, start_state=2, max_simulation_time=100.0, min_tips=50, max_tips=500, simfns=default_simfns(), seedval=543221, max_rate=10.0, numtries=250)#
get_root_age(simulation2$tree)#
get_root_age(simulation2$living_tree)
using Interpolations	# for Linear, Gridded, interpolate#
using LinearAlgebra  	# for "I" in: Matrix{Float64}(I, 2, 2)#
										 	# https://www.reddit.com/r/Julia/comments/9cfosj/identity_matrix_in_julia_v10/#
using Sundials				# for CVODE_BDF#
using Test						# for @test, @testset#
using PhyloBits#
using DataFrames#
using CSV#
#
using PhyBEARS#
#using PhyBEARS.Parsers#
# Change the working directory as needed#
wd = "/GitHub/PhyBEARS.jl/sims/sunkNZ_v1/"#
cd(wd)#
#
# This simulation has 148 living species#
trfn = "living_tree.newick"#
tr = readTopology(trfn)
library(cladoRcpp)#
library(BioGeoBEARS)#
library(ape)#
library(castor)#
#
# for: reorder_castor_sim_to_default_ape_node_order(simulation)#
source("/GitHub/PhyBEARS.jl/Rsrc/castor_helpers.R")#
#
wd = "/GitHub/PhyBEARS.jl/sims/sunkNZ_v1/"#
setwd(wd)#
simfns = c("setup_df.txt",#
"timepoints.txt", #
"mu_vals_by_t.txt", #
"Qvals_by_t.txt",#
"Crates_by_t.txt",#
"Qarray.txt",#
"Carray.txt",#
"area_names.txt",#
"states_list.R")#
simulation2 = simulate_tdsse2_for_timeperiod(wd, start_state=2, max_simulation_time=100.0, min_tips=50, max_tips=500, simfns=default_simfns(), seedval=543221, max_rate=10.0, numtries=250)#
get_root_age(simulation2$tree)#
get_root_age(simulation2$living_tree)
simulation2
moref(files.area_of_areas_fn)
library(cladoRcpp)#
library(BioGeoBEARS)#
library(ape)#
library(castor)#
#
# for: reorder_castor_sim_to_default_ape_node_order(simulation)#
source("/GitHub/PhyBEARS.jl/Rsrc/castor_helpers.R")#
#
wd = "/GitHub/PhyBEARS.jl/sims/sunkNZ_v1/"#
setwd(wd)#
simfns = c("setup_df.txt",#
"timepoints.txt", #
"mu_vals_by_t.txt", #
"Qvals_by_t.txt",#
"Crates_by_t.txt",#
"Qarray.txt",#
"Carray.txt",#
"area_names.txt",#
"states_list.R")#
simulation2 = simulate_tdsse2_for_timeperiod(wd, start_state=2, max_simulation_time=100.0, min_tips=50, max_tips=500, simfns=default_simfns(), seedval=543221, max_rate=10.0, numtries=250)#
get_root_age(simulation2$tree)#
get_root_age(simulation2$living_tree)
library(cladoRcpp)#
library(BioGeoBEARS)#
library(ape)#
library(castor)#
#
# for: reorder_castor_sim_to_default_ape_node_order(simulation)#
source("/GitHub/PhyBEARS.jl/Rsrc/castor_helpers.R")#
#
wd = "/GitHub/PhyBEARS.jl/sims/sunkNZ_v1/"#
setwd(wd)#
simfns = c("setup_df.txt",#
"timepoints.txt", #
"mu_vals_by_t.txt", #
"Qvals_by_t.txt",#
"Crates_by_t.txt",#
"Qarray.txt",#
"Carray.txt",#
"area_names.txt",#
"states_list.R")#
simulation2 = simulate_tdsse2_for_timeperiod(wd, start_state=2, max_simulation_time=100.0, min_tips=50, max_tips=500, simfns=default_simfns(), seedval=543221, max_rate=10.0, numtries=250)#
get_root_age(simulation2$tree)#
get_root_age(simulation2$living_tree)
library(cladoRcpp)#
library(BioGeoBEARS)#
library(ape)#
library(castor)#
#
# for: reorder_castor_sim_to_default_ape_node_order(simulation)#
source("/GitHub/PhyBEARS.jl/Rsrc/castor_helpers.R")#
#
wd = "/GitHub/PhyBEARS.jl/sims/sunkNZ_v1/"#
setwd(wd)#
simfns = c("setup_df.txt",#
"timepoints.txt", #
"mu_vals_by_t.txt", #
"Qvals_by_t.txt",#
"Crates_by_t.txt",#
"Qarray.txt",#
"Carray.txt",#
"area_names.txt",#
"states_list.R")#
simulation2 = simulate_tdsse2_for_timeperiod(wd, start_state=2, max_simulation_time=100.0, min_tips=50, max_tips=500, simfns=default_simfns(), seedval=543221, max_rate=10.0, numtries=250)#
get_root_age(simulation2$tree)#
get_root_age(simulation2$living_tree)
moref("mu_vals_by_t.txt")
system("open mu_vals_by_t.txt")
